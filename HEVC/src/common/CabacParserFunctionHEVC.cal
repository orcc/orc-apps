/******************************************************************************
 * Definition of CabacContextFunction
 *****************************************************************************/
package common;

import  std.util.Math.*;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  org.sc29.wg11.common.CabacDecodeBinFunction.*;
import  org.sc29.wg11.common.CabacDebinarizationFunction.*;

import  common.CommonConstantHEVC.*;
import  common.CabacContextConstantHEVC.*;
import  common.CabacContextTableHEVC.*;
import  common.CabacContextFunctionHEVC.*;

unit CabacParserFunctionHEVC :

	/*************************************************************************
	 * decodeBinTop
	 *************************************************************************/
	procedure decodeBinTop(
		uint(size= 9) ctxIdx,
		bool 		   bypassFlag,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size= 8) se,
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=7) state[1]	:= [0],
		uint(size=1) mps[1] 	:= [0],
		uint(size=1) binVal[1]	:= [0]
	begin
		if bypassFlag = true then
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
			if DEBUG_CABAC then
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);
			end		
		else
			if se = SE_DUMMY and ctxIdx = 0 then
				decodeTerminate(codIRange, codIOffset, binVal, fifo);
				if DEBUG_CABAC then
					println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);
				end		
			else
				state[0]  := ctxTable[se][ctxIdx] >> 1;
				mps[0]    := ctxTable[se][ctxIdx]  & 1;
				if DEBUG_CABAC then
					println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]);
				end		
				decodeDecision(codIRange, codIOffset, state, mps, binVal, fifo);
				ctxTable[se][ctxIdx] := (state[0] << 1) + mps[0];
				if DEBUG_CABAC then
					println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]+" binVal := "+binVal[0]);
				end		
			end
		end
		binString[0] := (binString[0] << 1) + binVal[0];
	end
	/*************************************************************************
	 * decodeBinTopTerminate
	 *************************************************************************/
	procedure decodeBinTopTerminate(
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	begin
		decodeTerminate(codIRange, codIOffset, binString, fifo);
		if DEBUG_CABAC then
			println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binString[0]);
		end		
	end
	/*************************************************************************
	 * decodeNumSubseqIPCM
	 *************************************************************************/
	procedure decodeNumSubseqIPCM(
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=32) res[1],
		uint(size=8) bit := 0,
		uint(size=8) numSubseqIPCM := 0
	begin
  		while( bit != 0 && (numSubseqIPCM < 3 )) do
    		codIOffset[0] := codIOffset[0] << 1;
    		vld_u(  1, fifo, res);
			codIOffset[0]	:= (codIOffset[0] << 1) + res[0];
		    bit := codIOffset[0] & 1;
    		numSubseqIPCM := numSubseqIPCM + 1;
		end
  		if bit != 0 && numSubseqIPCM = 3 then
    		numSubseqIPCM := numSubseqIPCM + 1;
    	end
    	binString[0] := numSubseqIPCM - 1;
		if DEBUG_CABAC then
			println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binString[0]);
		end		
	end
	/*************************************************************************
	 * decodeBinsEP
	 *************************************************************************/
	procedure decodeBinsEP(
		uint(size= 8) numBins,
		uint(size=32) binString[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=1) binVal[1]
	begin
		binString[0] := 0;
		if (numBins!=1) then
			foreach int i in 0 .. numBins-1 do
				binVal[0] := 0;
				decodeBypass(codIRange, codIOffset, binVal, fifo);			
				binString[0] := (binString[0] << 1) + binVal[0];
				if DEBUG_CABAC then
					println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);		
				end
			end
		else
			binVal[0] := 0;
			decodeBypass(codIRange, codIOffset, binVal, fifo);			
			binString[0] := (binString[0] << 1) + binVal[0];
			if DEBUG_CABAC then
				println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binVal[0]);
			end		
		end
	end
	/*************************************************************************
	 * get_SAO_Uflc
	 *************************************************************************/
	procedure get_SAO_Uflc(
		uint(size= 8) length,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		decodeBinsEP(length, debinValue, codIRange, codIOffset, fifo);
	end
	/*************************************************************************
	 * get_SAO_MaxUvlc
	 *************************************************************************/
	procedure get_SAO_MaxUvlc(
		uint(size= 8) maxSymbol,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=8) i := 1,
		uint(size=32) binString[1] := [0]
	begin
		debinValue[0] := 0;
		if maxSymbol != 0 then
			decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
			if binString[0] != 0 then
				while i != maxSymbol do
					binString[0] := 0;
					decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
					if binString[0] = 0 then
						debinValue[0] := i;
						i := maxSymbol-1;
					elsif i = maxSymbol-1 then
						debinValue[0] := maxSymbol;
					end
					i := i + 1;
				end
			end		
		end
	end
	/*************************************************************************
	 * xReadEpExGolomb
	 *************************************************************************/
	procedure xReadEpExGolomb(
		uint(size=32) count_int,
		uint(size=32) debinValue[1],
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
	)
	var
		uint(size=32) count  := count_int,
		uint(size=32) bit[1] := [1],
		uint(size=32) binString[1] := [0]
	begin
		debinValue[0] := 0;
		while bit[0] = 1 do
			decodeBinsEP(1, bit, codIRange, codIOffset, fifo);
			debinValue[0] := debinValue[0] + (bit[0] << count); 
			count := count + 1;
		end
		count := count - 1;
		if count != 0 then
			decodeBinsEP(count, binString, codIRange, codIOffset, fifo);
			debinValue[0] := debinValue[0] + binString[0];
		end
	end
	/*************************************************************************
	 * xReadUnaryMaxSymbol
	 *************************************************************************/
	procedure xReadUnaryMaxSymbol(
		uint(size= 9) ctxIdx,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size= 8) se,		
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size=32) maxSymbol
	)
	var
		uint(size=32) symbol := 0,
		uint(size=32) binString[1] := [0]
	begin
		if maxSymbol = 0 then
			debinValue[0] := 0;
		else
			decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, se, fifo);
			debinValue[0] := binString[0];
			if binString[0] != 0 and maxSymbol != 1 then
				while binString[0] = 1 and symbol < maxSymbol - 1 do
					binString[0] := 0;
					decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, se, fifo);
					symbol := symbol + 1;		
				end
				if binString[0] = 1 and symbol = maxSymbol - 1 then
					symbol := symbol + 1;
				end
				debinValue[0] := symbol;
			end
		end
	end
	/*************************************************************************
	 * get_SAO_MERGE_FLAG
	 *************************************************************************/
	procedure get_SAO_MERGE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" SAO_MERGE_FLAG ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SAO_MERGE_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_TYPE_IDX
	 *************************************************************************/
	procedure get_SAO_TYPE_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_SAO_TYPE_IDX, fifo);
		if binString[0] = 0 then
			debinValue[0] := SAO_NOT_APPLIED;
		else
			binString[0] := 0;
			decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
			if binString[0] = 0 then
				debinValue[0] := SAO_BAND;
			else
				debinValue[0] := SAO_EDGE;
			end
		end
		if DEBUG_CABAC then
			println(" SAO_TYPE_IDX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_OFFSET_ABS
	 *************************************************************************/
	procedure get_SAO_OFFSET_ABS(
		uint(size= 8) offsetTh,
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" SAO_OFFSET_ABS ==> "+offsetTh);
		end
		get_SAO_MaxUvlc(offsetTh, codIRange, codIOffset, fifo, debinValue);
		if DEBUG_CABAC then
			println(" SAO_OFFSET_ABS = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_OFFSET_SIGN
	 *************************************************************************/
	procedure get_SAO_OFFSET_SIGN(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" SAO_OFFSET_SIGN ==>");
		end
		debinValue[0] := 0;
		decodeBinsEP(1, debinValue, codIRange, codIOffset, fifo);
		if DEBUG_CABAC then
			println(" SAO_OFFSET_SIGN = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_BAND_POSITION
	 *************************************************************************/
	procedure get_SAO_BAND_POSITION(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" SAO_BAND_POSITION ==>");
		end
		get_SAO_Uflc(5, codIRange, codIOffset, fifo, debinValue);
		if DEBUG_CABAC then
			println(" SAO_BAND_POSITION = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SAO_EO
	 *************************************************************************/
	procedure get_SAO_EO(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" SAO_EO ==>");
		end
		decodeBinsEP(2, binString, codIRange, codIOffset, fifo);
		debinValue[0] := binString[0];
		if DEBUG_CABAC then
			println(" SAO_EO = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SPLIT_CODING_UNIT_FLAG
	 *************************************************************************/
	procedure get_SPLIT_CODING_UNIT_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		//
		uint(size= 8) depthSubPart,
		bool		  availableA,
		uint(size= 8) depthSubPartA,
		bool		  availableB,
		uint(size= 8) depthSubPartB
	)
	var
		uint(size= 9) ctxIdx,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		ctxIdx	  := context_93311_SKIP_CU_FLAG(depthSubPart, availableA, depthSubPartA, availableB, depthSubPartB);
		if DEBUG_CABAC then
			println(" SPLIT_CODING_UNIT_FLAG ==> ctxIdx := "+ctxIdx);
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_CODING_UNIT_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SPLIT_CODING_UNIT_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_PRED_MODE_FLAG
	 *************************************************************************/
	procedure get_PRED_MODE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PRED_MODE_FLAG ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PRED_MODE_FLAG, fifo);
		debinValue[0] := MODE_INTER + binString[0];
		if DEBUG_CABAC then
			println(" PRED_MODE_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_PART_SIZE
	 *************************************************************************/
	procedure get_PART_SIZE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		
		bool          isIntra,
		uint(size= 8) cu_log2CbSize,
		uint(size= 8) Log2MinCbSize
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" PART_MODE ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
		debinValue[0] := PART_NxN;                  // 000
		if binString[0] = 1 then 
			debinValue[0] := PART_2Nx2N;            // 1
		elsif cu_log2CbSize = Log2MinCbSize then
			if isIntra then 
				debinValue[0] := PART_NxN;          // 0
			else
				binString[0] := 0;
				decodeBinTop(1, false, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
				if binString[0] = 1 then 
					debinValue[0] := PART_2NxN;     // 01
				elsif cu_log2CbSize = 3 then 
					debinValue[0] := PART_Nx2N;     // 00
				else
					binString[0] := 0;
					decodeBinTop(2, false, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
					if binString[0] = 1 then 
						debinValue[0] := PART_Nx2N; // 001
					end
				end
			end
		else
			binString[0] := 0;
			decodeBinTop(1, false, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
			if binString[0] = 1 then
				binString[0] := 0;
				decodeBinTop(2, false, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
				if binString[0] = 1 then 
					debinValue[0] := PART_2NxN;       // 011
				else
//					binString[0] := 0;
//					decodeBinTop(3, false, binString, codIRange, codIOffset, ctxTable, SE_PART_SIZE, fifo);
					decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
					if binString[0] = 1 then
						debinValue[0] := PART_2NxnD;  // 0101
					else
						debinValue[0] := PART_2NxnU;  // 0100
					end
				end
			else
				binString[0] := 0;
				decodeBinTop(2, false, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
				if binString[0] = 1 then 
					debinValue[0] := PART_Nx2N;       // 001
				else
					decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
					if binString[0] = 1 then
						debinValue[0] := PART_nRx2N;  // 0001
					else
						debinValue[0] := PART_nLx2N;  // 0000
					end
				end
			end
		end
		if DEBUG_CABAC then
			println(" PART_MODE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_PREV_INTRA_LUMA_PRED_FLAG
	 *************************************************************************/
	procedure get_PREV_INTRA_LUMA_PRED_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" PREV_INTRA_LUMA_PRED_FLAG ==>");
		end
		debinValue[0] := 0;
		decodeBinTop(0, false, debinValue, codIRange, codIOffset, ctxTable, SE_PREV_INTRA_LUMA_PRED_FLAG, fifo);
		if DEBUG_CABAC then
			println(" PREV_INTRA_LUMA_PRED_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_REM_INTRA_LUMA_PRED_MODE
	 *************************************************************************/
	procedure get_REM_INTRA_LUMA_PRED_MODE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" REM_INTRA_LUMA_PRED_MODE ==>");
		end
		decodeBinsEP(5, binString, codIRange, codIOffset, fifo);
		debinValue[0] := binString[0];
		if DEBUG_CABAC then
			println(" REM_INTRA_LUMA_PRED_MODE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_MPM_IDX
	 *************************************************************************/
	procedure get_MPM_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
 		uint(size=32) debinValue[1]
	)
	var
		uint(size= 8) binIdx := 0,
		uint(size= 1) debinCompleted[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],		
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" MPM_IDX ==>");
		end
		debinValue[0] := 0;
		while debinCompleted[0] = 0 do
			decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
			debinTU(binString[0], binIdx, DEBIN_TU2, debinCompleted, debinValue, discard_suffix);
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" MPM_IDX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_INTRA_CHROMA_PRED_MODE
	 *************************************************************************/
	procedure get_INTRA_CHROMA_PRED_MODE(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	var
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" INTRA_CHROMA_PRED_MODE ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_INTRA_CHROMA_PRED_MODE, fifo);
		if binString[0] = 0 then
			debinValue[0] := 4;
		else
			binString[0] := 0;
			decodeBinsEP(2, binString, codIRange, codIOffset, fifo);
			debinValue[0] := binString[0];
		end
		if DEBUG_CABAC then
			println(" INTRA_CHROMA_PRED_MODE = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SPLIT_TRANSFORM_FLAG
	 *************************************************************************/
	procedure get_SPLIT_TRANSFORM_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) log2TransformBlockSize
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" SPLIT_TRANSFORM_FLAG ==> "+(5 - log2TransformBlockSize));
		end
		decodeBinTop(5 - log2TransformBlockSize, false, binString, codIRange, codIOffset, ctxTable, SE_SPLIT_TRANSFORM_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SPLIT_TRANSFORM_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_CBF_LUMA
	 *************************************************************************/
	procedure get_CBF_LUMA(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) trafoDepth
	)
	var
		uint(size= 9) ctxIdx = if (trafoDepth = 0) then 1 else 0 end,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" CBF_LUMA ==> "+ctxIdx);
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_CBF_LUMA, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" CBF_LUMA = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_CBF_CB_CR
	 *************************************************************************/
	procedure get_CBF_CB_CR(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 3) trafoDepth
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" CBF_CB_CR ==> "+trafoDepth);
		end
		decodeBinTop(trafoDepth, false, binString, codIRange, codIOffset, ctxTable, SE_CBF_CB_CR, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" CBF_CB_CR = "+debinValue[0]);
		end
	end

	/*************************************************************************
	 * get_TRANSFORM_SKIP_FLAG
	 *************************************************************************/
	procedure get_TRANSFORM_SKIP_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) rc_TType
		
	)
	var
		uint(size= 9) ctxIdx = if  rc_TType = TEXT_LUMA then 0 else 1 end,
		uint(size=32) binString[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" TRANSFORM_SKIP_FLAG ==>");
		end
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_TRANSFORM_SKIP_FLAG, fifo);
		debinValue[0] := binString[0]; 
		if DEBUG_CABAC then
			println(" TRANSFORM_SKIP_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_X_PREFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_X_PREFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) log2TrafoWidth,
		uint(size= 8) cIdx
	)
	var
		uint(size= 9) ctxIdx,
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_X_PREFIX ==> "+(1<<log2TrafoWidth));
		end
		while debinCompleted[0] = 0 do
			ctxIdx := context_93312(binIdx, log2TrafoWidth, cIdx);
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_X_PREFIX, fifo);
			debinTU(binString[0], binIdx, (log2TrafoWidth << 1 ) - 2, debinCompleted, debinValue, discard_suffix);
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_X_PREFIX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_Y_PREFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_Y_PREFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) log2TrafoHeight,
		uint(size= 8) cIdx
	)
	var
		uint(size= 9) ctxIdx,
		uint(size= 8) binIdx := 0,
		uint(size=32) binString[1] := [0],
		uint(size= 1) discard_suffix[1] := [0],
		uint(size= 1) debinCompleted[1] := [0]
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX ==> "+(1<<log2TrafoHeight));
		end		
		while debinCompleted[0] = 0 do
			ctxIdx := context_93312(binIdx, log2TrafoHeight, cIdx);
			decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_Y_PREFIX, fifo);
			debinTU(binString[0], binIdx, (log2TrafoHeight << 1 ) - 2, debinCompleted, debinValue, discard_suffix);
			binIdx := binIdx + 1;
		end
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX
	 *************************************************************************/
	procedure get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) prefix
	)
	begin
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_XY_SUFFIX ==>");
		end
		debinValue[0] := 0;
		decodeBinsEP((prefix>>1)-1, debinValue, codIRange, codIOffset, fifo);		
		if DEBUG_CABAC then
			println(" LAST_SIGNIFICANT_COEFF_XY_SUFFIX = "+debinValue[0]);
		end
	end	
	/*************************************************************************
	 * get_CODED_SUB_BLOCK_FLAG
	 *************************************************************************/
	procedure get_CODED_SUB_BLOCK_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],

		uint(size= 1) coded_sub_block_flag[8][8],
		uint(size=16) xC,
		uint(size=16) yC,
		uint(size= 8) cIdx,	
		uint(size= 8) log2TrafoSize
	)
	var
		uint(size= 9) ctxIdx[1],
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		context_93313(coded_sub_block_flag, xC, yC, cIdx, log2TrafoSize, ctxIdx);		
		if DEBUG_CABAC then
			println(" CODED_SUB_BLOCK_FLAG ==> "+(ctxIdx[0]&1));
		end
		decodeBinTop(ctxIdx[0], false, binString, codIRange, codIOffset, ctxTable, SE_CODED_SUB_BLOCK_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" CODED_SUB_BLOCK_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_SIGNIFICANT_COEFF_FLAG
	 *************************************************************************/
	procedure get_SIGNIFICANT_COEFF_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],

		uint(size= 1) coded_sub_block_flag[8][8],
		uint(size=16) xC,
		uint(size=16) yC,
		uint(size= 8) cIdx,	
		uint(size= 8) log2TrafoSize,
		uint(size= 8) scanIdx
	)
	var
		uint(size= 9) ctxIdx[1],
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		context_93314(coded_sub_block_flag, xC, yC, cIdx, log2TrafoSize, scanIdx, ctxIdx);		
		if DEBUG_CABAC then
			println(" SIGNIFICANT_COEFF_FLAG ==> "+ctxIdx[0]);
		end
		decodeBinTop(ctxIdx[0], false, binString, codIRange, codIOffset, ctxTable, SE_SIGNIFICANT_COEFF_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);
		if DEBUG_CABAC then
			println(" SIGNIFICANT_COEFF_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_COEFF_ABS_LEVEL_GREATER1_FLAG
	 *************************************************************************/
	procedure get_COEFF_ABS_LEVEL_GREATER1_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		 int(size=32) debinValue[1],
		
		uint(size= 9) ctxIdx
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL_GREATER1_FLAG ==> "+ctxIdx);
		end
		debinValue[0] := 0;
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_COEFF_ABS_LEVEL_GREATER1_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);		
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL_GREATER1_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_COEFF_ABS_LEVEL_GREATER2_FLAG
	 *************************************************************************/
	procedure get_COEFF_ABS_LEVEL_GREATER2_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		
		uint(size= 8) cIdx,
		uint(size= 8) ctxSet
	)
	var
		uint(size= 9) ctxIdx = ctxSet + if cIdx != 0 then 4 else 0 end,
		uint(size=32) binString[1] := [0],
		uint(size= 1) debinCompleted[1]
	begin
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL_GREATER2_FLAG ==> "+ctxIdx);
		end
		debinValue[0] := 0;
		decodeBinTop(ctxIdx, false, binString, codIRange, codIOffset, ctxTable, SE_COEFF_ABS_LEVEL_GREATER2_FLAG, fifo);
		debinFL(binString[0], 0, DEBIN_FL1, debinCompleted, debinValue);		
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL_GREATER2_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_COEFF_SIGN_FLAG
	 *************************************************************************/
	procedure get_COEFF_SIGN_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) nb
	)
	begin
		if DEBUG_CABAC then
			println(" COEFF_SIGN_FLAG ==>");
		end
		debinValue[0] := 0;
		decodeBinsEP(nb, debinValue, codIRange, codIOffset, fifo);		
		if DEBUG_CABAC then
			println(" COEFF_SIGN_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_COEFF_ABS_LEVEL
	 *************************************************************************/
	procedure get_COEFF_ABS_LEVEL(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		//
		uint(size= 8) rParam
	)
	var
		uint(size=16) prefix := 0,
		uint(size=32) codeWord[1] := [1]
	begin
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL ==> "+rParam);
		end
		while codeWord[0] = 1 do
			prefix      := prefix + 1;
			codeWord[0] := 0;
			decodeBinsEP(1, codeWord, codIRange, codIOffset, fifo);
		end
		codeWord[0] := 1 - codeWord[0];
		prefix		:= prefix - codeWord[0];
		if prefix < 3 then
			decodeBinsEP(rParam, codeWord, codIRange, codIOffset, fifo);
			debinValue[0] := (prefix<<rParam) + codeWord[0];
		else 
			decodeBinsEP(prefix-3+rParam, codeWord, codIRange, codIOffset, fifo);
			debinValue[0] := (((1<<(prefix-3))+3-1)<<rParam) + codeWord[0];
		end
		if DEBUG_CABAC then
			println(" COEFF_ABS_LEVEL = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_END_OF_SLICE_FLAG
	 *************************************************************************/
	procedure get_END_OF_SLICE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" END_OF_SLICE_FLAG ==>");
		end
		decodeBinTopTerminate(debinValue, codIRange, codIOffset, fifo);
		if DEBUG_CABAC then
			println(" END_OF_SLICE_FLAG = "+debinValue[0]);
		end
		if CHECK_CABAC and debinValue[0] = 1 then
			println(" END_OF_SLICE_FLAG ==>");
			println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
		end
	end
	/*************************************************************************
	 * get_SKIP_FLAG
	 *************************************************************************/
	procedure get_SKIP_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		
		uint(size= 1) skip_flag[CTB_ADDR_TS_MAX][2],
		uint(size=16) cu_x0,
		uint(size=16) cu_y0
	)
	var
		uint(size= 9) ctxIdx,
		uint(size= 1) availableA = if cu_x0 > 0 then skip_flag[cu_y0][1] else 0 end,
		uint(size= 1) availableB = if cu_y0 > 0 then skip_flag[cu_x0][0] else 0 end
	begin
		ctxIdx	  := availableA + availableB;
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" SKIP_FLAG ==> "+ctxIdx);
		end
		decodeBinTop(ctxIdx, false, debinValue, codIRange, codIOffset, ctxTable, SE_SKIP_FLAG, fifo);
		if DEBUG_CABAC then
			println(" SKIP_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_MERGE_FLAG
	 *************************************************************************/
	procedure get_MERGE_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" MERGE_FLAG ==>");
		end
		decodeBinTop(0, false, debinValue, codIRange, codIOffset, ctxTable, SE_MERGE_FLAG, fifo);
		if DEBUG_CABAC then
			println(" MERGE_FLAG = "+debinValue[0]);
		end
	end	
	/*************************************************************************
	 * get_MERGE_IDX
	 *************************************************************************/
	procedure get_MERGE_IDX(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 5) MaxNumMergeCand
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 8) binIdx := 1
	begin
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" MERGE_IDX ==>");
		end
		if MaxNumMergeCand > 1 then
			decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_MERGE_IDX, fifo);
			while binString[0] != 0 and binIdx < MaxNumMergeCand-1 do
				decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
				binIdx := binIdx + 1;
			end
		end
		debinValue[0] := if binString[0] = 0 then binIdx - 1 else binIdx end;
		if DEBUG_CABAC then
			println(" MERGE_IDX = "+debinValue[0]);
		end
	end	
	/*************************************************************************
	 * get_INTER_PRED_IDC
	 *************************************************************************/
	procedure get_INTER_PRED_IDC(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		
		uint(size= 8) partMode,
		uint(size= 8) PbW,
		uint(size= 8) PbH,
		uint(size= 8) ctDepth
	)
	var
		uint(size= 8) PbMax  = max(PbW,PbH),
		uint(size=32) binString[1] := [0]
	begin
		
		if DEBUG_CABAC then
			println(" INTER_PRED_IDC ==> "+ctDepth);
		end
		if partMode = PART_2Nx2N or PbMax != 8 then
			decodeBinTop(ctDepth, false, binString, codIRange, codIOffset, ctxTable, SE_INTER_PRED_IDC, fifo);
			debinValue[0] := Pred_L0 + binString[0];
		end
		if binString[0] = 0 then
			decodeBinTop(4, false, binString, codIRange, codIOffset, ctxTable, SE_INTER_PRED_IDC, fifo);
			debinValue[0] := Pred_L0 + binString[0];
		else
			debinValue[0] := Pred_BI;
		end       
		if DEBUG_CABAC then
			println(" INTER_PRED_IDC = "+debinValue[0]);
		end
	end	
	/*************************************************************************
	 * get_REF_IDX_L0
	 *************************************************************************/
	procedure get_REF_IDX_L0(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1],
		uint(size= 8) num_ref_idx_l0_active_minus1
		
	)
	var
		uint(size=32) binString[1] := [0],
		uint(size= 8) binIdx := 1
	begin
		
		if DEBUG_CABAC then
			println(" REF_IDX_L0 ==>");
		end
		decodeBinTop(0, false, binString, codIRange, codIOffset, ctxTable, SE_REF_IDX_L0, fifo);
		debinValue[0] := binString[0];
		if binString[0] = 1 and num_ref_idx_l0_active_minus1 > 1 then
			binString[0] := 0;
			decodeBinTop(1, false, binString, codIRange, codIOffset, ctxTable, SE_REF_IDX_L0, fifo);
			binIdx := binIdx + 1;
			while binString[0] != 0 and binIdx < num_ref_idx_l0_active_minus1 do
				decodeBinsEP(1, binString, codIRange, codIOffset, fifo);
				binIdx := binIdx + 1;
			end
			debinValue[0] := if binString[0] = 0 then binIdx - 1 else binIdx end;
		end
		if DEBUG_CABAC then
			println(" REF_IDX_L0 = "+debinValue[0]);
		end
	end	
	/*************************************************************************
	 * get_PCM_FLAG
	 *************************************************************************/
	procedure get_PCM_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" PCM_FLAG ==>");
		end
		decodeBinTopTerminate(debinValue, codIRange, codIOffset, fifo);
		if DEBUG_CABAC then
			println(" PCM_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_NUM_SUBSEQUENT_PCM
	 *************************************************************************/
	procedure get_NUM_SUBSEQUENT_PCM(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		if DEBUG_CABAC then
			println(" NUM_SUBSEQUENT_PCM ==>");
		end
		decodeNumSubseqIPCM(debinValue, codIRange, codIOffset, fifo);
		if DEBUG_CABAC then
			println(" NUM_SUBSEQUENT_PCM = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_ABS_MVD_GREATER0_FLAG
	 *************************************************************************/
	procedure get_ABS_MVD_GREATER0_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" ABS_MVD_GREATER0_FLAG ==>");
		end
		decodeBinTop(0, false, debinValue, codIRange, codIOffset, ctxTable, SE_ABS_MVD_GREATER0_FLAG, fifo);
		if DEBUG_CABAC then
			println(" ABS_MVD_GREATER0_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_ABS_MVD_GREATER1_FLAG
	 *************************************************************************/
	procedure get_ABS_MVD_GREATER1_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" ABS_MVD_GREATER1_FLAG ==>");
		end
		decodeBinTop(1, false, debinValue, codIRange, codIOffset, ctxTable, SE_ABS_MVD_GREATER0_FLAG, fifo);
		if DEBUG_CABAC then
			println(" ABS_MVD_GREATER1_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_ABS_MVD_MINUS2
	 *************************************************************************/
	procedure get_ABS_MVD_MINUS2(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" ABS_MVD_MINUS2 ==>");
		end
		xReadEpExGolomb(1, debinValue, codIRange, codIOffset, fifo);
		if DEBUG_CABAC then
			println(" ABS_MVD_MINUS2 = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_MVD_SIGN_FLAG
	 *************************************************************************/
	procedure get_MVD_SIGN_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" MVD_SIGN_FLAG ==>");
		end
		decodeBinsEP(1, debinValue, codIRange, codIOffset, fifo);
		if DEBUG_CABAC then
			println(" MVD_SIGN_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_MVP_LX_FLAG
	 *************************************************************************/
	procedure get_MVP_LX_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" MVP_LX_FLAG ==>");
		end
		xReadUnaryMaxSymbol(1, codIRange, codIOffset, ctxTable, SE_MVP_LX_FLAG, fifo, debinValue, 1);
		if DEBUG_CABAC then
			println(" MVP_LX_FLAG = "+debinValue[0]);
		end
	end
	/*************************************************************************
	 * get_NO_RESIDUAL_SYNTAX_FLAG
	 *************************************************************************/
	procedure get_NO_RESIDUAL_SYNTAX_FLAG(
		uint(size= 9) codIRange[1],
		uint(size=16) codIOffset[1],
		uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
		uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
		uint(size=32) debinValue[1]
	)
	begin
		debinValue[0] := 0;
		if DEBUG_CABAC then
			println(" NO_RESIDUAL_SYNTAX_FLAG ==>");
		end
		decodeBinTop(0, false, debinValue, codIRange, codIOffset, ctxTable, SE_NO_RESIDUAL_SYNTAX_FLAG, fifo);
		if DEBUG_CABAC then
			println(" NO_RESIDUAL_SYNTAX_FLAG = "+debinValue[0]);
		end
	end
end