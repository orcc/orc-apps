/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * Decoding process for inter prediction samples
 * 
 * 
 * @input CuMode : mode (Intra, Inter or Skip mode) of all Cu sent.
 * 
 * @input CuSize : size of all Cu sent.
 * 
 * @input IsBiPredOrLx : Indicates when the current Cu is using Bi-prediction.
 * 
 * @input Mv : movement vectors of the current Cu.
 * 
 * @input PartMode : Giving the partitioning mode of the current Cu.
 * 
 * @input Poc : Picture Order Count of the current slice.
 * 
 * @input RefList : Reference Lists (L0 and L1) of the current slice.
 * 
 * @input Sample : Samples from the DPB, used for the inter prediction.
 * 
 * @input SliceType : slice type (I, P or B) of the current slice.
 * 
 * @input WeightedPredSe : syntax elements for the weighted prediction decoded
 * 	by the parser.
 * 
 * 
 * @output PredSample : Interpolated samples according to the movement
 *		components given.
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */

package interPrediction;

import std.util.Math.*;
import common.CommonConstantHEVC.*;
import interPrediction.NaluType.*;

actor InterPrediction()
	uint(size=16) CUInfo,
	uint(size=2)  IsBiPredOrLx,
	int (size=16) Mv,
	uint(size=4)  PartMode,
	uint(size=16)  Poc,
	uint(size=3)  RefIdx,
	int (size=16) RefList,
	uint(size=8)  Sample,
	uint(size=2)  SliceType,
	int (size=16) WeightedPredSe // is size correct ?
		==>
	uint(size=8) PredSample
		:

	int shift1 = 6;
	/* Fix me !! */
	uint(size=4) bitDepth = 8;
	uint(size=4) bitDepthC = 8;
	uint(size=10) maxPixVal = (1<<bitDepth)-1;

	bool refPicListComb = false; /* Fix me !! */

	int(size=16)  currPoc;
	uint(size=2)  listIdx;
	uint(size=7)  iLoop;
	uint(size=7)  jLoop;
	int (size=16) refListX[2][6];
	uint(size=2)  wpIdc;
	uint(size=4)  numRefIdxLxAct[2];
	bool          isBSlice;
	uint(size=4)  refIdxLxAct;
	bool          weightLxFlag;
	uint(size=3)  log2WeightDenom[3];
	int           weight[6][2][3];
	int           offset[6][2][3];
	uint(size=3)  numPartDecoded;
	uint(size=3)  numPart;
	uint(size=7)  cuSize[2];
	uint(size=2)  cuMode;
	int logWD[3];
	int weightCu[3][2];
	int offsetCu[3][2];
	uint(size=2)  isBiPredOrLx;
	int (size=4)  refIdxLx[2];
	int (size=16) mvLx[2][2];
	uint(size=2)  numList;
	int(size=32)  pixVal;
	uint(size=7)  predCuSize;
	int logWDTab[8][8][3];
	int weightCuTab[8][8][3][2];
	int offsetCuTab[8][8][3][2];

	int(size=16) refSamples[3][64+7][64+7];
	int(size=16) predSamples[3][64][64];

/* Coefficients used for the 8-tap filter (luma component) and 4-tap filter
 * (chroma component).
 */
int(size=8) interPredCoeff[3][8][8] = 
[
	[//LumaCoeff
	[ 0, 0,   0,  0,  0,   0, 0,  0],
	[-1, 4, -10, 58, 17,  -5, 1,  0],
	[-1, 4, -11, 40, 40, -11, 4, -1],
	[ 0, 1,  -5, 17, 58, -10, 4, -1]],
	[//ChromaCoeff
	[ 0,  0,  0,  0],
	[-2, 58, 10, -2],
	[-4, 54, 16, -2],
	[-6, 46, 28, -4],
	[-4, 36, 36, -4],
	[-4, 28, 46, -6],
	[-2, 16, 54, -4],
	[-2, 10, 58, -2]],
	[//ChromaCoeff
	[ 0,  0,  0,  0],
	[-2, 58, 10, -2],
	[-4, 54, 16, -2],
	[-6, 46, 28, -4],
	[-4, 36, 36, -4],
	[-4, 28, 46, -6],
	[-2, 16, 54, -4],
	[-2, 10, 58, -2]]
];

	/* Computing the weighted prediction coefficients (logWd, w0, w1, o0, o1),
	 * according to the picture(s) used for the prediction.
	 */
	procedure computeWeights(int refIdxL0, int refIdxL1)
	var
		int(size=16) pocL0,
		int(size=16) pocL1,
		int          tb,
		int          td,
		int          tx,
		int          weightScalFact,
		int          w0,
		int          w1,
		uint(size=3) idxL0 = (refIdxL0+1)&7,
		uint(size=3) idxL1 = (refIdxL1+1)&7
	begin
		/*Implicit weighted prediction : we compute the weights thanks the the
		 * poc value of the reference pictures
		 */
		if(wpIdc = 2) then
			if(refIdxL0 >=0 && refIdxL1 >= 0) then
				if(refIdxL0>=0) then
					pocL0 := refListX[0][refIdxL0];
				end
				if(refIdxL1>=0) then
					pocL1 := refListX[1][refIdxL1];
				end
				tb := clip_i32(currPoc- pocL0, -128, 127);
				td := clip_i32(pocL1-pocL0, -128, 127);
				if(td != 0) then
					tx := (16384 + (abs(td)>>1))/td;
					weightScalFact := clip_i32((tb*tx +32)>>6, -1024, 1023);
				end
				if(pocL0 = pocL1 || (weightScalFact>>2)<-64 ||
					(weightScalFact>>2)>128) then
					w0 := 32;
					w1 := 32;
				else
					w0 := 64 - (weightScalFact>>2);
					w1 := weightScalFact>>2;
				end
				foreach int component in 0 .. 2
				do
					logWDTab[idxL0][idxL1][component] := 5+shift1;
					offsetCuTab[idxL0][idxL1][component][0] := 0;
					offsetCuTab[idxL0][idxL1][component][1] := 0;
					weightCuTab[idxL0][idxL1][component][0] := w0;
					weightCuTab[idxL0][idxL1][component][1] := w1;
				end
			else
				foreach int component in 0 .. 2
				do
					logWDTab[idxL0][idxL1][component] := shift1;
					offsetCuTab[idxL0][idxL1][component][0] := 0;
					offsetCuTab[idxL0][idxL1][component][1] := 0;
					weightCuTab[idxL0][idxL1][component][0] := 1;
					weightCuTab[idxL0][idxL1][component][1] := 1;
				end
			end
		/*Explicit weighted prediction : we get the coefficients thanks to the
		 * predWeight table (decoded at the beginning of each slice).
		 */
		else if (wpIdc = 1) then
			foreach int component in 0 .. 2
			do
				logWDTab[idxL0][idxL1][component] := log2WeightDenom[component] + shift1;
				if(refIdxL0 >=0) then
					weightCuTab[idxL0][idxL1][component][0] := weight[refIdxL0][0][component];
					offsetCuTab[idxL0][idxL1][component][0] := offset[refIdxL0][0][component];
				end
				if(refIdxL1 >=0) then
					weightCuTab[idxL0][idxL1][component][1] := weight[refIdxL1][1][component];
					offsetCuTab[idxL0][idxL1][component][1] := offset[refIdxL1][1][component];
				end
			end
		end end
	end

	/* 8-tap filter or 4-tap filter (it depends on idxMax). */
	procedure predictionFiltering(uint idxMax, bool isHoriz, int coord[2],
		int(size=8) coeffIdx, int finalOffset, int finalShift,
		uint(size=2) component)
	var
		int xOrig = coord[0],
		int yOrig = coord[1]
	begin
		pixVal := 0;
		/* We get the 4 or 8 pixels needed for the filter and
		 * we multiply these values with some coefficients. These coefficients
		 * depend on the movement vector (if it's equal to a 8th, 4th or half
		 * of pixel).
		 */
		if(isHoriz) then
			foreach int idx in 0 .. idxMax-1
			do
				pixVal := pixVal +  interPredCoeff[component][coeffIdx][idx] *
					refSamples[component][xOrig+idx][yOrig];
			end
		else
			foreach int idx in 0 .. idxMax-1
			do
				pixVal := pixVal +  interPredCoeff[component][coeffIdx][idx] *
					refSamples[component][xOrig][yOrig+idx];
			end
		end
		pixVal := pixVal + finalOffset;
		pixVal := pixVal >> finalShift;
	end

	procedure interpolOneSample(int x, int y, int mvQuartPix[2],
		uint(size=4) numCoeff, uint(size=2) component
	)
	var
		int(size=16) sampleTab[8],
		uint(size=2) idxOff[3] = [3,1,1],
		int (size=32) coord[2]
	begin
		if(mvQuartPix[0]=0 && mvQuartPix[1]=0) then
			/* When we mvQuartPix is equal to [0,0], we multiply by 1^shift1,
			 * because after this procedure we will have the weighted prediction.
			 */
			pixVal := refSamples[component][x+idxOff[component]]
				[y+idxOff[component]]<<shift1;
		else if(mvQuartPix[1]=0) then /* Horizontal interpolation */
			coord := [x, y+idxOff[component]];
			predictionFiltering(numCoeff, true, coord, mvQuartPix[0], 0, 0,
				component);		
		else if(mvQuartPix[0]=0) then /* Vertical interpolation */
			coord := [x+idxOff[component], y];
			predictionFiltering(numCoeff, false, coord, mvQuartPix[1], 0, 0,
				component);
		else
			/* if quartPix (or eighthPix for chroma) is not equal to 0 for both
			 * x and y, we realize the interpolation in 2 steps.
			 */
			/* We do the horizontal interpolation for all the samples which
			 * will be needed for the vertical interpolation.
			 */
			foreach int idxSample in 0 .. numCoeff-1
			do
				coord := [x, y+idxSample];
				predictionFiltering(numCoeff, true, coord,  mvQuartPix[0],
					-8192, 0, component);
				sampleTab[idxSample] := pixVal;
			end
			pixVal := 0;
			/* Then we do the vertical interpolation with the result from the
			 * previous part.
			 */
			foreach int idx in 0 .. numCoeff-1
			do
				pixVal := pixVal +  interPredCoeff[component][mvQuartPix[1]]
					[idx] * sampleTab[idx];
			end
			pixVal := (pixVal + 524288) >> 6;
		end end end
	end

	/* Computing the weighted prediction of the current pixel */
	procedure weightedPred(uint(size=2) component, uint x, uint y)
	var
		int wX,
		int oX,
		int locLogWD,
		int w0,
		int w1,
		int o0,
		int o1
	begin
		/* If we have a mono-prediction */
		if(numList = 1) then
			if(wpIdc = 0) then
				/* When we don't have a weighted prediction, we do the
				 * average.
				 */
				pixVal := (pixVal + (1 <<(shift1-1)))>>shift1;
			else
				/* If we had a bi-prediction both pictures used and movement
				 * vectors where identical
				 */
				if(isBiPredOrLx != BI_PRED) then
					/* We use the bi-prediction way */
					wX := weightCu[component][listIdx];
					oX := offsetCu[component][listIdx];
					locLogWD := logWD[component];
					pixVal :=
						if(locLogWD >= 1) then
							((pixVal*wX + (1<<(locLogWD-1))) >> locLogWD)+oX
						else
							pixVal*wX +oX
						end;
				else
					/* Weighted prediction for mono-prediction. */
					wX := weightCu[component][0] + weightCu[component][1];
					oX := offsetCu[component][0] + offsetCu[component][1] +1;
					locLogWD := logWD[component] +1;
					pixVal := ((pixVal*wX + (oX<<(locLogWD-1))) >>locLogWD);
				end
			end
			/* We apply a threashold according to bitDepth
			 * (which is equal to 8, 10 or 12 bits).
			 */
			predSamples[component][x][y] := clip_i32(pixVal, 0 , maxPixVal);
		/* If we have a bi-prediction */
		else
			if(wpIdc = 0) then
				/* When we don't have a weighted prediction, we do the average
				 * of both pixels.
				 */
				pixVal := pixVal - 8192;
				if(listIdx=0) then /* First pixel predicted */
					predSamples[component][x][y] := pixVal;
				else /* Second pixel predicted */
					pixVal := (predSamples[component][x][y] + pixVal + 16448)
						>> 7;
					/* We apply a threashold according to bitDepth
					 * (which is equal to 8, 10 or 12 bits).
					 */
					predSamples[component][x][y] := clip_i32(pixVal, 0 ,
						maxPixVal);
				end
			else /* When we have weighted prediction for bi-prediction */
				if(listIdx=0) then
					/* We save the first prediction. */
					predSamples[component][x][y] := pixVal;
				else
					/* Then we realize the weighted prediction with the pixel
					 * values and the coefficients.
					 */
					w0 := weightCu[component][0];
					w1 := weightCu[component][1];
					o0 := offsetCu[component][0];
					o1 := offsetCu[component][1];
					locLogWD := logWD[component];
					pixVal := (predSamples[component][x][y]*w0 + pixVal*w1 +
						((o0+o1+1)<<locLogWD))>>(locLogWD+1);
					/* We apply a threashold according to bitDepth
					 * (which is equal to 8, 10 or 12 bits).
					 */
					predSamples[component][x][y] := clip_i32(pixVal, 0 ,
						maxPixVal);
				end
			end
		end
	end

	/* We have a new slice, we will update differents value then get the new
	 * refList and weights
	 */
	isNewSlice: action PartMode:[partMode], Poc:[poc], SliceType:[sliceType],
		WeightedPredSe:[weightPredIdc] ==>
	guard
		partMode = NEW_SLICE || partMode = NEW_PICT
	do
		isBSlice := sliceType = B_SLICE;
		currPoc := poc;
		wpIdc := weightPredIdc;
		listIdx := 0;
	end

	/* We have a New Cu in the Slice */
	getPartMode: action PartMode:[partMode] ==>
	guard
		partMode != NEW_SLICE && partMode != NEW_PICT
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
	end

	/** Getting the size of each reference list  **/
	getSizeRefList.launch: action RefList:[sizeList] ==>
	guard
		listIdx < 2
	do
		numRefIdxLxAct[listIdx] := sizeList;
		iLoop := 0;
	end

	getSizeRefList.done: action ==>
	guard
		listIdx = 2
	end

	/** Getting the poc contained in each reference list **/
	getRefList.launch: action RefList:[refPoc] ==>
	guard
		iLoop < numRefIdxLxAct[listIdx]
	do
		refListX[listIdx][iLoop] := refPoc;
		iLoop := iLoop + 1;
	end

	getRefList.done: action ==>
	guard
		iLoop = numRefIdxLxAct[listIdx]
	do
		listIdx := listIdx + 1;
	end

	/* Getting the syntax elements for the weighted prediction when we have
	 * weighted prediction in explicit mode
	 */
	getWeightDenom.launch: action WeightedPredSe:[weightDenom] repeat 2 ==>
	guard
		wpIdc = 1
	do
		listIdx := 0;
		log2WeightDenom[0] := weightDenom[0];
		log2WeightDenom[1] := weightDenom[0] + weightDenom[1];
		log2WeightDenom[2] := weightDenom[0] + weightDenom[1];
	end

	getWeightDenom.skip: action ==>
	guard
		wpIdc != 1
	do
		if(wpIdc = 2) then
			foreach int idxL0 in -1 .. numRefIdxLxAct[0]-1
			do
				foreach int idxL1 in -1 .. numRefIdxLxAct[1]-1
				do
					computeWeights(idxL0, idxL1);
				end
			end
		end
	end

	getWeightLX.launch: action ==>
	guard
		listIdx = 0 && (not isBSlice || not refPicListComb) ||
		listIdx = 1 && isBSlice
	do
		iLoop := 0;
		if(listIdx = 0) then
			refIdxLxAct := numRefIdxLxAct[0];
		else
			if(not refPicListComb) then
				refIdxLxAct := numRefIdxLxAct[1];
			else
				println(" Actor InterPrediction : we don't manage LC yet");
				while(true) do end
			end
		end
	end

	getWeightLX.skip: action ==>
	guard
		listIdx != 2
	do
		listIdx := listIdx + 1;
	end

	getWeightLX.done: action ==>
	guard
		listIdx = 2
	do
		foreach int idxL0 in -1 .. numRefIdxLxAct[0]-1
		do
			foreach int idxL1 in -1 .. numRefIdxLxAct[1]-1
			do
				computeWeights(idxL0, idxL1);
			end
		end
	end

	getLumaWeightLX.launch: action WeightedPredSe:[lumWeightFlag] ==>
	guard
		iLoop < refIdxLxAct
	do
		weightLxFlag := lumWeightFlag != 0;
	end

	getLumaWeightLX.done: action ==>
	guard
		iLoop = refIdxLxAct
	do
		listIdx := listIdx + 1;
	end

	getDeltaLumaWeight: action WeightedPredSe:[wpSyntElem] repeat 3 ==>
	guard
		weightLxFlag
	do
		weight[iLoop][listIdx][0] := (1<<log2WeightDenom[0]) + wpSyntElem[0];
		offset[iLoop][listIdx][0] := wpSyntElem[1];
		weightLxFlag := wpSyntElem[2] != 0;
	end

	getChromaWeightLX: action WeightedPredSe:[chrWeightFlag] ==>
	guard
		not weightLxFlag
	do
		weight[iLoop][listIdx][0] := (1<<log2WeightDenom[0]);
		offset[iLoop][listIdx][0] := 0;
		weightLxFlag := chrWeightFlag != 0;
	end

	getDeltaChromaWeight.launch: action WeightedPredSe:[wpSyntElem] repeat 4 ==>
	guard
		weightLxFlag
	var
		int chromaWeight,
		uint(size=13) shift = ((1<<bitDepthC)-1)>>1
	do
		weight[iLoop][listIdx][1] := (1<<log2WeightDenom[1]) + wpSyntElem[0];
		chromaWeight := weight[iLoop][listIdx][1];
		offset[iLoop][listIdx][1] :=
			wpSyntElem[1] - ((shift*chromaWeight)>>log2WeightDenom[1])+shift;

		weight[iLoop][listIdx][2] := (1<<log2WeightDenom[2]) + wpSyntElem[2];
		chromaWeight := weight[iLoop][listIdx][2];
		offset[iLoop][listIdx][2] :=
			wpSyntElem[3] - ((shift*chromaWeight)>>log2WeightDenom[2])+shift;

		iLoop := iLoop + 1;
	end

	getDeltaChromaWeight.done: action ==>
	guard
		not weightLxFlag
	do
		weight[iLoop][listIdx][1] := (1<<log2WeightDenom[1]);
		offset[iLoop][listIdx][1] := 0;
		weight[iLoop][listIdx][2] := (1<<log2WeightDenom[2]);
		offset[iLoop][listIdx][2] := 0;
		iLoop := iLoop + 1;
	end

	/* Get the size of each part of the current Cu. */
	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		cuSize := [cuInfo[i]: for int i in 3 .. 4];
		predCuSize := max(cuInfo[3], cuInfo[4]);
		numPartDecoded := numPartDecoded + 1;
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	/* We launch the InterPrediction code only if we have an
	 * inter prediction :)
	 */
	getCuMode.isNotInter: action ==>
	guard
		not(cuMode = INTER || cuMode = SKIP)
	end

	getCuMode.isInter: action IsBiPredOrLx:[isBiPredOrPredLX] ==>
	guard
		cuMode = INTER || cuMode = SKIP
	do
		isBiPredOrLx := isBiPredOrPredLX;
	end

	/* Getting the prediction components for mono or bi-prediction */
	getRefIdx.monoPred: action RefIdx:[refIndexLx], Mv:[mv] repeat 2 ==>
	guard
		isBiPredOrLx != BI_PRED
	var
		uint idxL0,
		uint idxL1
	do
		if(isBiPredOrLx = PRED_L0) then
			mvLx[0] := [mv[i]:for int i in 0 .. 1];
			mvLx[1] := [0,0];
			refIdxLx := [refIndexLx&7, -1];
			listIdx := 0;
		else
			mvLx[1] := [mv[i]:for int i in 0 .. 1];
			mvLx[0] := [0,0];
			refIdxLx := [-1, refIndexLx&7];
			listIdx := 1;
		end
		idxL0 := (refIdxLx[0]+1)&7;
		idxL1 := (refIdxLx[1]+1)&7;
		foreach int component in 0 .. 2
		do
			logWD[component] := logWDTab[idxL0][idxL1][component];
			foreach int list in 0 .. 1
			do
				weightCu[component][list] := weightCuTab[idxL0][idxL1][component][list];
				offsetCu[component][list] := offsetCuTab[idxL0][idxL1][component][list];
			end
		end
		numList := 1;
	end

	getRefIdx.biPred: action RefIdx:[refIndexLx] repeat 2, Mv:[mv] repeat 4 ==>
	guard
		isBiPredOrLx = BI_PRED
	var
		uint idxL0,
		uint idxL1
	do
		mvLx := [[mv[2*i+j]:for uint j in 0 ..1]: for int i in 0 .. 1];
		refIdxLx := [refIndexLx[i]: for uint i in 0 .. 1];
		idxL0 := (refIdxLx[0]+1)&7;
		idxL1 := (refIdxLx[1]+1)&7;
		foreach int component in 0 .. 2
		do
			logWD[component] := logWDTab[idxL0][idxL1][component];
			foreach int list in 0 .. 1
			do
				weightCu[component][list] := weightCuTab[idxL0][idxL1][component][list];
				offsetCu[component][list] := offsetCuTab[idxL0][idxL1][component][list];
			end
		end
		listIdx := 0;
		numList :=
			/* If we have the same picture with the same movement vectors we 
			 * can don't need to do the same interpolation twice :)
			 */
			if(refListX[0][refIdxLx[0]] = refListX[1][refIdxLx[1]] &&
				mvLx[0][0] = mvLx[1][0] && mvLx[0][1] = mvLx[1][1] &&
				refIdxLx[0] = refIdxLx[1]) then
				1
			else
				2
			end;
	end

	/* Getting the samples from the DPB and realizing the interpolation. */
	getSamples.launch.is64x64: action Sample:[sample] repeat (64+7)*(64+7)+
		(32+3)*(32+3)*2 ==>
	guard
		listIdx=0 || listIdx=1 && (isBiPredOrLx = BI_PRED ||
			isBiPredOrLx = PRED_L1),
		predCuSize = 64
	do
		refSamples[0] := [[sample[x+y*(64+7)]:for uint y in 0 .. 64+7-1]:
			for uint x in 0 .. 64+7-1];
		refSamples[1] := [[sample[x+y*(32+3)+5041]:for uint y in 0 .. 32+3-1]:
			for uint x in 0 .. 32+3-1];
		refSamples[2] := [[sample[x+y*(32+3)+6266]:for uint y in 0 .. 32+3-1]:
			for uint x in 0 .. 32+3-1];
	end

	getSamples.launch.is32x32: action Sample:[sample] repeat (32+7)*(32+7)+
		(16+3)*(16+3)*2 ==>
	guard
		listIdx=0 || listIdx=1 && (isBiPredOrLx = BI_PRED ||
			isBiPredOrLx = PRED_L1),
		predCuSize = 32
	do
		refSamples[0] := [[sample[x+y*(32+7)]:for uint y in 0 .. 32+7-1]:
			for uint x in 0 .. 32+7-1];
		refSamples[1] := [[sample[x+y*(16+3)+1521]:for uint y in 0 .. 16+3-1]:
			for uint x in 0 .. 16+3-1];
		refSamples[2] := [[sample[x+y*(16+3)+1882]:for uint y in 0 .. 16+3-1]:
			for uint x in 0 .. 16+3-1];
	end

	getSamples.launch.is16x16: action Sample:[sample] repeat (16+7)*(16+7)+
		(8+3)*(8+3)*2 ==>
	guard
		listIdx=0 || listIdx=1 && (isBiPredOrLx = BI_PRED ||
			isBiPredOrLx = PRED_L1),
		predCuSize = 16
	do
		refSamples[0] := [[sample[x+y*(16+7)]:for uint y in 0 .. 16+7-1]:
			for uint x in 0 .. 16+7-1];
		refSamples[1] := [[sample[x+y*(8+3)+529]:for uint y in 0 .. 8+3-1]:
			for uint x in 0 .. 8+3-1];
		refSamples[2] := [[sample[x+y*(8+3)+650]:for uint y in 0 .. 8+3-1]:
			for uint x in 0 .. 8+3-1];
	end

	getSamples.launch.is8x8: action Sample:[sample] repeat (8+7)*(8+7)+
		(4+3)*(4+3)*2 ==>
	guard
		listIdx=0 || listIdx=1 && (isBiPredOrLx = BI_PRED ||
			isBiPredOrLx = PRED_L1),
		predCuSize = 8
	do
		refSamples[0] := [[sample[x+y*(8+7)]:for uint y in 0 .. 8+7-1]:
			for uint x in 0 .. 8+7-1];
		refSamples[1] := [[sample[x+y*(4+3)+225]:for uint y in 0 .. 4+3-1]:
			for uint x in 0 .. 4+3-1];
		refSamples[2] := [[sample[x+y*(4+3)+274]:for uint y in 0 .. 4+3-1]:
			for uint x in 0 .. 4+3-1];
	end

	getSamples.launch.is4x4: action Sample:[sample] repeat (4+7)*(4+7)+
		(2+3)*(2+3)*2 ==>
	guard
		listIdx=0 || listIdx=1 && (isBiPredOrLx = BI_PRED ||
			isBiPredOrLx = PRED_L1),
		predCuSize = 4
	do
		refSamples[0] := [[sample[x+y*(4+7)]:for uint y in 0 .. 4+7-1]:
			for uint x in 0 .. 4+7-1];
		refSamples[1] := [[sample[x+y*(2+3)+225]:for uint y in 0 .. 2+3-1]:
			for uint x in 0 .. 2+3-1];
		refSamples[2] := [[sample[x+y*(2+3)+274]:for uint y in 0 .. 2+3-1]:
			for uint x in 0 .. 2+3-1];
	end

	interpolateSamples: action ==>
	var
		uint maskMv[3] = [3, 7, 7],
		uint(size=4) numCoeff[3] = [8, 4, 4],
		int mvQuartPix[2],
		uint(size=1) componentShift[3] = [0,1,1]
	do
		if( not (refIdxLx[listIdx] = -1 || listIdx = 1 && numList = 1 &&
			refIdxLx[0]!=-1)) then
			foreach int component in 0 .. 2 /* Y, Cb, Cr */
			do
				/* We just need to do the fractionnal part of the movement
				 * interpolation.
				 */
				mvQuartPix := [mvLx[listIdx][i] & maskMv[component]:
					for int i in 0 .. 1];
	
				/* We realize the interpolation then the weighted prediction
				 * for all pixel of the Cu.
				 */
				foreach int y in 0 .. (cuSize[1]>>componentShift[component])-1
				do
					foreach int x in 0 ..
						(cuSize[0]>>componentShift[component])-1
					do
						interpolOneSample(x, y, mvQuartPix, numCoeff[component],
							component);
						weightedPred(component, x, y);
					end
				end
			end
		end
		listIdx := listIdx + 1;
	end

	getSamples.done: action ==>
	guard
		listIdx=2 || listIdx=1 && isBiPredOrLx = PRED_L0
	do
		iLoop := 0;
		jLoop := 0;
	end

	sendCu.launch: action ==> PredSample:[pix] repeat 16+2*4
	guard
		jLoop < cuSize[1]
	var
		uint(size=8) pix[16+2*4],
		uint(size=5) off
	do
		foreach uint y in 0 .. 3
		do
			foreach uint x in 0 .. 3
			do
				pix[y*4+x] := predSamples[0][iLoop+x][jLoop+y];
			end
		end
		off := 16;
		foreach uint component in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pix[y*2+x+off] := predSamples[component][iLoop/2+x][jLoop/2+y];
				end
			end
			off := off + 4;
		end
		iLoop := iLoop + 4;
		if(iLoop = cuSize[0]) then
			iLoop := 0;
			jLoop := jLoop + 4;
		end
	end

	sendCu.done: action ==>
	guard
		jLoop = cuSize[1]
	do
		iLoop := 0;
		jLoop := 0;
	end

	schedule fsm GetPartMode:
		GetPartMode (isNewSlice  )--> GetSizeRefList;
		GetPartMode (getPartMode )--> GetCuInfo;

		GetSizeRefList (getSizeRefList.launch )--> GetRefList;
		GetSizeRefList (getSizeRefList.done   )--> GetWeightDenom;

		GetRefList (getRefList.launch )--> GetRefList;
		GetRefList (getRefList.done   )--> GetSizeRefList;

		GetWeightDenom (getWeightDenom.launch )--> GetWeightLX;
		GetWeightDenom (getWeightDenom.skip   )--> GetPartMode;

		GetWeightLX (getWeightLX.launch )--> GetLumaWeightLX;
		GetWeightLX (getWeightLX.skip   )--> GetWeightLX;
		GetWeightLX (getWeightLX.done   )--> GetPartMode;

		GetLumaWeightLX (getLumaWeightLX.launch )--> GetDeltaLumWtLX;
		GetLumaWeightLX (getLumaWeightLX.done   )--> GetWeightLX;

		GetDeltaLumWtLX (getDeltaLumaWeight     )--> GetDeltaChrWtLX;
		GetDeltaLumWtLX (getChromaWeightLX      )--> GetDeltaChrWtLX;

		GetDeltaChrWtLX (getDeltaChromaWeight   )--> GetLumaWeightLX;

		GetCuInfo (getCuInfo.launch )--> GetCuMode;
		GetCuInfo (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotInter )--> GetCuInfo;
		GetCuMode (getCuMode.isInter )--> GetRefIdx;

		GetRefIdx (getRefIdx )--> GetSamples;

		GetSamples (getSamples.launch )--> InterpolateSamples;
		GetSamples (getSamples.done   )--> SendCu;

		InterpolateSamples (interpolateSamples )--> GetSamples;

		SendCu (sendCu.launch )--> SendCu;
		SendCu (sendCu.done   )--> GetCuInfo;
	end
	priority
		getWeightLX.launch > getWeightLX.skip >getWeightLX.done;
	end
end