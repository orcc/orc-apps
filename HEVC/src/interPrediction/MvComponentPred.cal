/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * This actor generates the components needed for the inter prediction
 * (mv and refIdx).
 *
 * 
 * @input ColocInfo : Informations concerning the colocation picture.
 * 
 * @input CuAddr : Address in pixel of all Cu sent.
 * 
 * @input CuMode : Mode (Intra, Inter or Skip mode) of all Cu sent.
 * 
 * @input CuSize : Size of all Cu sent.
 * 
 * @input PartMode : Giving the partitioning mode of the current Cu.
 * 
 * @input Poc : Picture Order Count of the current slice.
 * 
 * @input RefList : Reference Lists (L0 and L1) of the current slice.
 * 
 * @input RpsPoc : Poc present in the Reference Picture Set of the current slice.
 * 
 * @input SliceType : Slice type (I, P or B) of the current slice.
 * 
 * @input SyntaxElem : Syntax elements decoded by the parser.
 * 
 * 
 * @output IsBiPredOrLx : Indicates when the current Cu is using Bi-prediction.
 * 
 * @output IsReadOrNewSlc : Indicates if samples are asked from the current Rps
 *		or if there is a new picture.
 * 
 * @output Mv : movement vectors of the current Cu.
 * 
 * @output PocRef : Poc used for the prediction of the current Cu.
 * 
 * @output PredCuSize : Size of the largest side of the current Cu.
 * 
 * @output RefIdx : Reference indexes of the lists (L0 and L1) of the current
 *		slice.
 *
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */

package interPrediction;

import std.util.Math.*;
import common.CommonConstantHEVC.*;
import interPrediction.NaluType.*;

actor MvComponentPred(bool FIX_TMVP_REFIDX0)
	uint(size=3)  ColocInfo,
	uint(size=16) CUInfo,
	uint(size=4)  PartMode,
	uint(size=16) PicSize,
	uint(size=16) Poc,
	int (size=16) RefList,
	int (size=16) RpsPoc,
	uint(size=2)  SliceType,
	int (size=16) SyntaxElem
		==>
	uint(size=2)  IsBiPredOrLx,
	uint(size=1)  IsReadOrNewSlice,
	int (size=16) Mv,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize,
	uint(size=3)  RefIdx
		:


	/* Constants representing all the neighbour required during for predicting
	 * the differents components
	 */
	int LEFT_BOTTOM = 0;
	int LEFT = 1;
	int ABOVE_RIGHT = 2;
	int ABOVE = 3;
	int ABOVE_LEFT = 4;
	int RIGHT_BOTTOM = 5;
	int CENTER = 6;

	/* Specification of l0CandIdx and l1CandIdx */
	uint(size=2) combIdxToLXCandIdx[16][2] =
		[[0,1], [1,0], [0,2], [2,0], [1,2], [2,1],
	 [0,3], [3,0], [1,3], [3,1], [2,3], [3,2]];

	uint(size=4)  cuPartMode;
	int           mergeIdx;
	int           mvpIdx[2];
	int           colPoc;
	int           colRefIdx;
	int(size=16)  colRefPoc[2][16];
	uint(size=1)  colocFromL0;
	uint(size=3)  numPart;
	uint(size=3)  numPartDecoded;
	uint(size=2)  listIdx;
	uint(size=3)  listSize;
	uint(size=3)  sizeIdx;
	int (size=16) maxPoc;
	int           picSizeInPart[2];
	bool          useLN;
	bool          isBSlice;
	int           partAddr[2];
	int           cuAddr[2];
	uint(size=2)  cuMode;
	int           mvPred[5][2][2];
	int           refIdxPred[5][2];
	int(size=16)  pocRef[7];
	int(size=16)  pocRefList[7][2][16];
	int(size=4)   refIdxRef[7][2048/4][2048/4][2];
	int(size=4)   modeRef[7][2048/4][2048/4];
	int(size=16)  mvRef[7][2048/4][2048/4][2][2];
	int           neighbLocation[2];
	int           nPSH;
	int           nPSW;
	bool          isRef[7];
	bool          isStillRef[7];
	int(size=4)   currIdx;
	bool          predFlag;
	int numCandidate;
	uint sizeOfList;
	uint nbList;
	int(size=16) pocRefListX[2][16];
	uint(size=2) isBiPredOrLx;
	uint(size=7) predCuSize;
	uint(size=7) cuSize[2];

	function isInter(int xN, int yN) --> bool
	:
		if(xN>=0 && yN>=0 && xN<picSizeInPart[0] && yN<picSizeInPart[1])then
			modeRef[currIdx][xN][yN] = INTER // and what about Skip ?
		else
			false
		end
	end

	/* Indicates if the Cu Orig and Neighb located in the current picture have the same reference indexes and movement vectors. */
	function hasNotSameMvComp(int orig[2], int neighb[2]) --> bool
	var
		int xNOrig = orig[0],
		int yNOrig = orig[1],
		int xNNeighb = neighb[0],
		int yNNeighb = neighb[1],
		int xNOrigMasked = orig[0] & (MASK_WIDTH>>2),
		int yNOrigMasked = orig[1] & (MASK_HEIGHT>>2),
		int xNNeighbMasked = neighb[0] & (MASK_WIDTH>>2),
		int yNNeighbMasked = neighb[1] & (MASK_HEIGHT>>2),
		int refIdxCurrCu[2] = [refIdxRef[currIdx][xNOrigMasked]
			[yNOrigMasked][i]:for int i in 0 .. 1],
		int refIdxNeighb[2] = [refIdxRef[currIdx][xNNeighbMasked]
			[yNNeighbMasked][i]: for int i in 0 .. 1],
		int mvCurrCu[2][2] = [[mvRef[currIdx][xNOrigMasked]
			[yNOrigMasked][i][j]:for int j in 0 .. 1]:for int i in 0 .. 1],
		int mvNeighb[2][2] = [[mvRef[currIdx][xNNeighbMasked][yNNeighbMasked]
			[i][j]: for int j in 0 .. 1]:for int i in 0 .. 1]
	:
		if(xNNeighb >= 0 && yNNeighb >= 0 && xNNeighb < picSizeInPart[0] &&
			yNNeighb < picSizeInPart[1]) then

			if(not (xNOrig >= 0 && yNOrig >= 0 && xNOrig < picSizeInPart[0] &&
				yNOrig < picSizeInPart[0])) then

				false
			else
				if(refIdxCurrCu[0] = refIdxNeighb[0] && refIdxCurrCu[1] =
					refIdxNeighb[1]) then
					not ((refIdxCurrCu[0] = -1 ||(mvCurrCu[0][0] =
						mvNeighb[0][0] && mvCurrCu[0][1] = mvNeighb[0][1])) &&
						(refIdxCurrCu[1] = -1 || (mvCurrCu[1][0] =
							mvNeighb[1][0] && mvCurrCu[1][1] = mvNeighb[1][1])))
				else
					true
				end
			end
		else
			true
		end
	end

	/** Saving information for the next predictions **/
	procedure saveRefIdx(int refIdxToSave[2])
	begin
		foreach int x in partAddr[0] .. partAddr[0] + nPSW - 1
		do
			foreach int y in partAddr[1] .. partAddr[1] + nPSH - 1
			do
				refIdxRef[currIdx][x][y] := [refIdxToSave[i]:
					for int i in 0 .. 1];
				modeRef[currIdx][x][y] := INTER;
			end
		end
	end

	procedure saveMvComponent(int mvToSave[2][2])
	begin
		foreach int x in partAddr[0] .. partAddr[0] + nPSW - 1
		do
			foreach int y in partAddr[1] .. partAddr[1] + nPSH - 1
			do
				mvRef[currIdx][x][y] :=
					[[mvToSave[i][j]:for int j in 0 .. 1]:for int i in 0 .. 1];
			end
		end
	end

	/* Computes the location of the neighbour. The result will be in the vector
	 * neighbLocation
	 */
	procedure getNeighbAddr(int location, bool isMerged)
	var
		bool neighbIsAbove
	begin
		neighbIsAbove := false;
		if(location = LEFT) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] + nPSH - 1;
		else if(location = ABOVE) then
			neighbLocation[0] := partAddr[0] + nPSW - 1;
			neighbLocation[1] := partAddr[1] - 1;
			neighbIsAbove := true;
		else if(location = ABOVE_RIGHT) then
			neighbLocation[0] := partAddr[0] + nPSW;
			neighbLocation[1] := partAddr[1] - 1;
			neighbIsAbove := true;
		else if(location = LEFT_BOTTOM) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] + nPSH;
		else if(location = ABOVE_LEFT) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] - 1;
			neighbIsAbove := true;
		else if(location = RIGHT_BOTTOM) then
			neighbLocation[0] := partAddr[0] + nPSW;
			neighbLocation[1] := partAddr[1] + nPSH;
			neighbLocation[0] := neighbLocation[0] & ~3;
			neighbLocation[1] := neighbLocation[1] & ~3;
		else
			neighbLocation[0] := partAddr[0] + nPSW/2;
			neighbLocation[1] := partAddr[1] + nPSH/2;
			neighbLocation[0] := neighbLocation[0] & ~3;
			neighbLocation[1] := neighbLocation[1] & ~3;
		end end end end end end
		if(location != CENTER && location != RIGHT_BOTTOM) then
			if(neighbIsAbove && isMerged && (neighbLocation[1]&15)=15) then
				neighbLocation[0] := (neighbLocation[0] & ~1) +
					((neighbLocation[0]>>1)&1);
			end
		else
			if(isMerged && (neighbLocation[1] & 15) = 15 ||
				(neighbLocation[1]>>4 != partAddr[1]>>4)) then
				neighbLocation[1] := -1;
			end
		end
	end

	/* method used for getting the neighbour. This method is used when mergeIdx
	 * value is absent (in this decoder it corresponds to mergeidx = -1)
	 */
	procedure getNonMergedNeighbourMv(uint listX, bool isAboveNeighb)
	var
		int xN := neighbLocation[0],
		int yN := neighbLocation[1],
		int xPartAddr = partAddr[0],
		int yPartAddr = partAddr[1],
		bool sameComponent := false,
		int refIdx1,
		int refIdx2,
		int currMv[2],
		int i := 0
	begin
		predFlag := false;
		if(isAboveNeighb && (yN & 15) = 15) then
			//XXXX0X => XXXX00
			//XXXX1X => XXXX11
			xN := (xN & ~1) + ((xN>>1) & 1);
			neighbLocation[0] := xN;
		end
		if(xN >= 0 && yN >= 0 && xN < picSizeInPart[0] &&
			yN < picSizeInPart[1]) then
			if(refIdxRef[currIdx][xN][yN][listX] =
				refIdxRef[currIdx][xPartAddr][yPartAddr][listX]) then
				getNeighbourMv(true, listX, false);
			else
				refIdx1 := refIdxRef[currIdx][xN][yN][listX^1];
				refIdx2 := refIdxRef[currIdx][xPartAddr][yPartAddr][listX];
				if(refIdx1!=-1 && pocRefListX[listX^1][refIdx1] =
					pocRefListX[listX][refIdx2]) then
					predFlag := true;
					mvPred[numCandidate][listX] := [mvRef[currIdx][xN][yN]
						[listX^1][j]:for int j in 0 .. 1];
					numCandidate := numCandidate + 1;
				end
			end
			if(predFlag) then
				currMv := [mvPred[numCandidate-1][listX][j]:
					for int j in 0 .. 1];
				while(i<numCandidate-1 && not sameComponent)
				do
					if(mvPred[i][listX][0] = currMv[0] &&
						mvPred[i][listX][1] = currMv[1]) then
						numCandidate := numCandidate - 1;
						sameComponent := true;
					end
					i:=i+1;
				end
			end
		end
	end

	procedure getNeighbourMv(bool isNonMerged, uint listX, bool scaled)
	var
		int xN = neighbLocation[0],
		int yN = neighbLocation[1],
		bool sameComponent := false,
		uint listAvail
	begin
		predFlag := false;
		if(xN>=0 && yN>=0 && xN<picSizeInPart[0] && yN<picSizeInPart[1]) then
			predFlag := refIdxRef[currIdx][xN][yN][0] != -1 ||
				refIdxRef[currIdx][xN][yN][1] != -1 ;
			if(predFlag) then
				if(isNonMerged && not scaled) then
					foreach int i in 0 .. numCandidate-1
					do
						if(mvPred[i][0][0] = mvRef[currIdx][xN][yN][0][0] &&
						   mvPred[i][0][1] = mvRef[currIdx][xN][yN][0][1] &&
						   mvPred[i][1][0] = mvRef[currIdx][xN][yN][1][0] &&
						   mvPred[i][1][1] = mvRef[currIdx][xN][yN][1][1]) then
							sameComponent := true;
						end
					end
				end
				if(not sameComponent) then
					if(isNonMerged) then
						listAvail :=
							if(refIdxRef[currIdx][xN][yN][listX] != -1) then
								listX
							else
								listX^1
							end;
						mvPred[numCandidate][listX] := [mvRef[currIdx][xN][yN]
							[listAvail][i]:for int i in 0 .. 1];
						refIdxPred[numCandidate][listX] := refIdxRef[currIdx]
							[xN][yN][listAvail];
					else
						mvPred[numCandidate] :=
							[[mvRef[currIdx][xN][yN][list][i]:
								for int i in 0 .. 1]:for int list in 0 .. 1];
						refIdxPred[numCandidate] := [refIdxRef[currIdx][xN][yN]
							[list]:for int list in 0 .. 1];
					end
					numCandidate := numCandidate + 1;
				end
			end
		end
	end

	procedure getNonMergedScaledMv(uint listX, bool isAboveNeighb)
	var
		int xN := neighbLocation[0],
		int yN := neighbLocation[1],
		int xPartAddr = partAddr[0],
		int yPartAddr = partAddr[1],
		int listAvail,
		int currMv[2],
		int refIdxRefCurrPic,
		int i := 0,
		bool sameComponent:= false,
		int mvParam[2]
	begin
		predFlag := false;
		if(isAboveNeighb && (yN & 15) = 15) then
			//XXXX0X => XXXX00
			//XXXX1X => XXXX11
			xN := (xN & ~1) + ((xN>>1) & 1);
			neighbLocation[0] := xN;
		end
		if(xN>=0 && yN>=0 && xN<picSizeInPart[0] && yN<picSizeInPart[1]) then
			if(refIdxRef[currIdx][xN][yN][0] != -1 ||
				refIdxRef[currIdx][xN][yN][1] != -1) then
				listAvail :=
					if(refIdxRef[currIdx][xN][yN][listX] != -1) then
						listX
					else
						listX^1
					end;
				getNeighbourMv(true, listX, true);
				refIdxRefCurrPic := refIdxRef[currIdx][xPartAddr][yPartAddr]
					[listX];
				mvParam := [mvPred[numCandidate-1][listX][j]:for int j in 0 .. 1];
				mvScaling(mvParam, refIdxRefCurrPic, listAvail, listX, currIdx,
					pocRefListX);
				mvPred[numCandidate-1][listX] :=
					[mvParam[j]:for int j in 0 .. 1];
				
				currMv :=
					[mvPred[numCandidate-1][listX][j]: for int j in 0 .. 1];
				while(i<numCandidate-1 && not sameComponent)
				do
					if(mvPred[i][listX][0] = currMv[0] &&
						mvPred[i][listX][1] = currMv[1]) then
						numCandidate := numCandidate - 1;
						sameComponent := true;
					end
					i:=i+1;
				end
			end
		end
	end

	/* Scaling the movement vector acording to the Cu from the neighbour part
	 * and the current Cu
	 */
	procedure mvScaling(int mv[2], int refIdxRefCurrPic, uint listAvail,
		uint listX, uint pictIdx, int(size=16) refList[2][16])
	var
		int xN = neighbLocation[0],
		int yN = neighbLocation[1],
		int idxColRef = refIdxRef[pictIdx][xN][yN][listAvail],
		int pocRefCol = refList[listAvail][idxColRef],
		int pocRefCurrPic = pocRefList[currIdx][listX][refIdxRefCurrPic],
		int deltaColPic,
		int deltaCurrPic,
		int td,
		int tb,
		int tx,
		int distScaleFactor,
		int newMv
	begin
		deltaColPic := pocRef[pictIdx] - pocRefCol;
		deltaCurrPic := pocRef[currIdx] - pocRefCurrPic;
		if(deltaColPic != deltaCurrPic) then
			td := clip_i32(deltaColPic, -127, 128);
			tb := clip_i32(deltaCurrPic, -127, 128);
			tx := (16384 + abs(td/2))/td;
			distScaleFactor := clip_i32((tb*tx+32)>>6, -4096, 4095);
			foreach int i in 0 .. 1
			do
				newMv := distScaleFactor*mv[i];
				if(newMv>= 0) then
					newMv := (newMv + 127)>>8;
				else
					newMv := -((-newMv + 127)>>8);
				end
				mv[i] := newMv;
			end
		end
	end

	/* Derivation process for temporal motion vector prediction part1 */
	procedure getColCandidate(bool isMerged, uint listX)
	begin
		if(isMerged) then
			listX := 0;
		end
		getNeighbAddr(RIGHT_BOTTOM, false);
		getColNeighbourMv(isMerged, listX);
		if(not predFlag) then
			getNeighbAddr(CENTER, false);
			getColNeighbourMv(isMerged, listX);
		end
	end

	/* Derivation process for temporal motion vector prediction part2 */
	procedure getColNeighbourMv(bool isMerged, uint listX)
	var
		int xN := neighbLocation[0],
		int yN := neighbLocation[1],
		int mv[2][2],
		int refIdxRefCurrPic,
		int refIdxRefCurrPicL1,
		int listAvail[2],
		int partIdx = numPartDecoded - 1,
		int mvScal[2]
	begin
		predFlag := false;
		if(xN>=0 && yN>=0 && xN<picSizeInPart[0] && yN<picSizeInPart[1]) then
			predFlag := refIdxRef[colRefIdx][xN][yN][0] != -1 ||
				refIdxRef[colRefIdx][xN][yN][1] != -1;
			if(predFlag) then
				mv := [[mvRef[colRefIdx][xN][yN][i][j]:for int j in 0 .. 1]:
					for int i in 0 .. 1];
				if(isMerged) then
					if(not FIX_TMVP_REFIDX0) then
						refIdxRefCurrPic :=
							if(isInter(partAddr[0]-1, partAddr[1]+nPSH-1)) then
								refIdxRef[currIdx][partAddr[0] - 1]
									[partAddr[1] + nPSH - 1][0]
							else
								0
							end;
						if(refIdxRefCurrPic = -1 || partIdx = 1) then
							refIdxRefCurrPic := 0;
						end
						refIdxRefCurrPicL1 :=
							if(isInter(partAddr[0] - 1, partAddr[1] + nPSH - 1))
							then
								refIdxRef[currIdx][partAddr[0] - 1]
									[partAddr[1] + nPSH - 1][1]
							else
								0
							end;
						if(refIdxRefCurrPicL1 = -1 || partIdx = 1) then
							refIdxRefCurrPicL1 := 0;
						end
					else
						refIdxRefCurrPic := 0;
						refIdxRefCurrPicL1 := 0;
					end
					if(refIdxRef[colRefIdx][xN][yN][1] = -1) then
						mv[1][0] := mv[0][0];
						mv[1][1] := mv[0][1];
						listAvail := [0, 0];
					else if(refIdxRef[colRefIdx][xN][yN][0] = -1) then
						mv[0][0] := mv[1][0];
						mv[0][1] := mv[1][1];
						listAvail := [1, 1];
					else
						if(useLN) then
							if(colocFromL0 = 0)then
								mv[1][0] := mv[0][0];
								mv[1][1] := mv[0][1];
								listAvail := [0, 0];
							else
								mv[0][0] := mv[1][0];
								mv[0][1] := mv[1][1];
								listAvail := [1, 1];
							end
						else
							listAvail := [0, 1];
						end
					end end
					mvScal := [mv[0][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPic,   listAvail[0], 0, 
						colRefIdx, colRefPoc);
					mv[0] := [mvScal[i]:for int i in 0 .. 1];
					mvScal := [mv[1][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPicL1, listAvail[1], 1,
						colRefIdx, colRefPoc);
					mv[1] := [mvScal[i]:for int i in 0 .. 1];
					refIdxPred[numCandidate][0] := refIdxRefCurrPic;
					refIdxPred[numCandidate][1] := refIdxRefCurrPicL1;
					mvPred[numCandidate] := [[mv[i][j]:for int j in 0 .. 1]:
						for int i in 0 .. 1];
				else
					listAvail[0] :=
						if(refIdxRef[colRefIdx][xN][yN][listX] != -1) then
							listX
						else
							listX^1
						end;
					if(refIdxRef[colRefIdx][xN][yN][0] != -1 &&
						refIdxRef[colRefIdx][xN][yN][1] != -1 && useLN) then
						listAvail[0] := colocFromL0;
					end
					refIdxRefCurrPic :=
						if(isInter(partAddr[0],partAddr[1])) then
							refIdxRef[currIdx][partAddr[0]][partAddr[1]][listX]
						else
							0
						end;
					if(refIdxRefCurrPic = -1) then
						refIdxRefCurrPic := 0;
					end
					mvScal := [mv[listAvail[0]][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPic, listAvail[0], listX,
						colRefIdx, colRefPoc);
					mv[listAvail[0]] := [mvScal[i]:for int i in 0 .. 1];
					mvPred[numCandidate][listX] := [mv[listAvail[0]][i]:
						for int i in 0 .. 1];
					refIdxPred[numCandidate][listX] := refIdxRefCurrPic;
				end
				numCandidate := numCandidate + 1;
			end
		end
	end

	/* Derivation process for combined bi-predictive merging candidates */
	procedure biPredMergeCand(uint maxNumCandidate)
	var
		int combIdxMax = numCandidate * (numCandidate-1),
		int combIdx := 0,
		uint l0CandIdx,
		uint l1CandIdx,
		uint refIdxL0Cand,
		uint refIdxL1Cand,
		uint mvL0Cand[2],
		uint mvL1Cand[2]
	begin
		while(combIdx != combIdxMax && numCandidate != maxNumCandidate)
		do
			l0CandIdx := combIdxToLXCandIdx[combIdx][0];	
			l1CandIdx := combIdxToLXCandIdx[combIdx][1];
			refIdxL0Cand := refIdxPred[l0CandIdx][0];
			refIdxL1Cand := refIdxPred[l1CandIdx][1];
			mvL0Cand := [mvPred[l0CandIdx][0][i]:for int i in 0 .. 1];
			mvL1Cand := [mvPred[l1CandIdx][1][i]:for int i in 0 .. 1];
			if(refIdxL0Cand!=-1 && refIdxL1Cand!= -1) then
				if(pocRefListX[0][refIdxL0Cand] !=
					pocRefListX[1][refIdxL1Cand] ||
					mvL0Cand[0] != mvL1Cand[0] || mvL0Cand[1] != mvL1Cand[1])
					then
					mvPred[numCandidate][0] := [mvL0Cand[i]:
						for int i in 0 .. 1];
					mvPred[numCandidate][1] := [mvL1Cand[i]:
						for int i in 0 .. 1];
					refIdxPred[numCandidate][0] := refIdxL0Cand;
					refIdxPred[numCandidate][1] := refIdxL1Cand;
					numCandidate := numCandidate + 1;
				end
			end
			combIdx := combIdx + 1;
		end
	end

	uint(size=32) sliceNum := 0;
	/* Getting information from new Slice, finding some place for the refence
	 * tables, and initializing the reference tables
	 */
	isNewSlice: action PartMode:[partMode], ColocInfo:[colFromLX,
		colRefIdxVal], PicSize:[picSize] repeat 2, Poc:[poc],
		SliceType:[sliceType] ==> IsReadOrNewSlice:[0]
	guard
		partMode = PART_MODE_SLICE || partMode = PART_MODE_PICT
	do
		sliceNum := sliceNum + 1;
		println("Slice num "+sliceNum);

		if(colFromLX!=0)then
			colFromLX := 1;
		end
		isBSlice := sliceType = B_SLICE;
		colRefIdx := colRefIdxVal & 15;
		colocFromL0 := colFromLX^1;
		listIdx := 0;
		maxPoc := MIN_INT16;
		foreach int i in 0 .. 6
		do
			isStillRef[i] := false;
		end
		picSizeInPart[0] := picSize[0]/4;
		picSizeInPart[1] := picSize[1]/4;

		if(partMode = PART_MODE_PICT) then
			currIdx := -1;
			foreach int i in 0 .. 6
			do
				if((currIdx = -1 and not isRef[i]) ||
					(isRef[i] and pocRef[i]=poc)) then
					currIdx  := i;
				end
			end
		end
		
		refIdxRef[currIdx]:= [[[-1:for int i in 0 .. 1]:
			for int j in 0 .. PICT_SIDE/4-1]:for int k in 0 .. PICT_SIDE/4-1];
		modeRef[currIdx]:= [[OTHER:for int j in 0 .. PICT_SIDE/4-1]:
			for int k in 0 .. PICT_SIDE/4-1];
		isRef[currIdx] := true;
		pocRef[currIdx] := poc;
		nbList := 0;
	end

	getPartMode: action PartMode:[partMode] ==>
	guard
		partMode != PART_MODE_SLICE && partMode != PART_MODE_PICT
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
		cuPartMode := partMode;
	end

	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		predCuSize := max(cuInfo[3], cuInfo[4]);
		cuSize := [cuInfo[3], cuInfo[4]];
		partAddr[0] := cuInfo[1]/4;
		partAddr[1] := cuInfo[2]/4;
		cuAddr := [cuInfo[1], cuInfo[2]];
		nPSW := cuInfo[3]/4;
		nPSH := cuInfo[4]/4;
		numPartDecoded := numPartDecoded + 1;
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	getCuMode.isNotInter: action ==>
	guard
		not(cuMode = INTER || cuMode = SKIP)
	do
		foreach int x in partAddr[0] .. partAddr[0] + nPSW - 1
		do
			foreach int y in partAddr[1] .. partAddr[1] + nPSH - 1
			do
				modeRef[currIdx][x][y] := INTRA;
				refIdxRef[currIdx][x][y][0] := -1;
				refIdxRef[currIdx][x][y][1] := -1;
			end
		end
	end

	getCuMode.isInter: action SyntaxElem:[mergeIndex] ==>
	guard
		cuMode = INTER || cuMode = SKIP
	do
		mergeIdx := mergeIndex;
	end

	/* Derivation process for motion vectors for merge mode */
	checkMergeIdx.isNotEqToMin1: action ==>
	guard
		mergeIdx != -1
	var
		int numNeighbSelect := 0,
		bool tryGetNeighbour,
		int locationUp[2],
		int locationLeft[2],
		int refIdxVal := 0,
		int partIdx = numPartDecoded-1
	do
		numCandidate := 0;
		getNeighbAddr(ABOVE, true);
		locationUp := neighbLocation;
		getNeighbAddr(LEFT, true);
		locationLeft := neighbLocation;

		//A1
		if(not (cuPartMode = PART_Nx2N || cuPartMode = PART_nLx2N ||
			cuPartMode = PART_nRx2N) || partIdx!=1) then
			getNeighbourMv(false, 0, false);
			numNeighbSelect := if(predFlag) then 1 else 0 end;
		end

		//B1
		if( not(cuPartMode = PART_2NxN || cuPartMode = PART_2NxnU ||
			cuPartMode = PART_2NxnD) || partIdx != 1) then

			tryGetNeighbour := hasNotSameMvComp(locationUp, locationLeft);
			if(tryGetNeighbour) then
				neighbLocation := locationUp;
				getNeighbourMv(false, 0, false);
				numNeighbSelect := numNeighbSelect +
					if(predFlag) then 1 else 0 end;
			end
		end

		//B0
		getNeighbAddr(ABOVE_RIGHT, true);
		tryGetNeighbour := hasNotSameMvComp(neighbLocation, locationUp);
		if(tryGetNeighbour) then
			getNeighbourMv(false, 0, false);
			numNeighbSelect := numNeighbSelect +
				if(predFlag) then 1 else 0 end;
		end

		//A0
		getNeighbAddr(LEFT_BOTTOM, true);
		tryGetNeighbour := hasNotSameMvComp(neighbLocation, locationLeft);
		if(tryGetNeighbour) then
			getNeighbourMv(false, 0, false);
			numNeighbSelect := numNeighbSelect +
				if(predFlag) then 1 else 0 end;
		end

		if(numNeighbSelect<4) then
			getNeighbAddr(ABOVE_LEFT, true);
			tryGetNeighbour := hasNotSameMvComp(neighbLocation, locationUp);
			tryGetNeighbour := tryGetNeighbour &&
				hasNotSameMvComp(neighbLocation, locationLeft);
			if(tryGetNeighbour) then
				getNeighbourMv(false, 0, false);
			end
		end
		getColCandidate(true, 0);
 		if(isBSlice) then
			biPredMergeCand(5);
		end
		foreach int i in numCandidate .. 4
		do
			mvPred[i] := [[0,0],[0,0]];
			refIdxPred[i] := [refIdxVal, refIdxVal];
			refIdxVal := refIdxVal + 1;
		end
	end

	checkMergeIdx.isEqToMin1: action SyntaxElem:[se] repeat 4 ==>
	guard
		mergeIdx = -1
	var
		int refIdx[2] = [se[2],se[3]],
		int numNeighbSelect
	do
		saveRefIdx(refIdx);
		mvpIdx := [se[0], se[1]];
		foreach int list in 0 .. 1
		do
			numCandidate := 0;

			//Left neighbours
			getNeighbAddr(LEFT_BOTTOM, false); // A0
			getNonMergedNeighbourMv(list, false);
			if(not predFlag) then
				getNeighbAddr(LEFT, false); // A1
				getNonMergedNeighbourMv(list, false);
			end
			if(not predFlag) then
				getNeighbAddr(LEFT_BOTTOM, false); // A0'
				getNonMergedScaledMv(list, false);
			end
			if(not predFlag) then
				getNeighbAddr(LEFT, false); // A1'
				getNonMergedScaledMv(list, false);
			end
			numNeighbSelect := if(predFlag) then 1 else 0 end;

			//Above neighbours
			getNeighbAddr(ABOVE_RIGHT, false); // B0
			getNonMergedNeighbourMv(list, true);
			if(not predFlag) then
				getNeighbAddr(ABOVE, false); // B1
				getNonMergedNeighbourMv(list, true);
			end
			if(not predFlag) then
				getNeighbAddr(ABOVE_LEFT, false); // B2
				getNonMergedNeighbourMv(list, true);
			end
			numNeighbSelect := numNeighbSelect +
				if(predFlag) then 1 else 0 end;
			if(numNeighbSelect != 2) then
				predFlag := isInter(partAddr[0] - 1, partAddr[1] + nPSH) ||
					isInter(partAddr[0] - 1, partAddr[1] + nPSH - 1);
			else
				predFlag := true;
			end
			if(not predFlag) then
				getNeighbAddr(ABOVE_RIGHT, false); // B0'
				getNonMergedScaledMv(list, true);
			end
			if(not predFlag) then
				getNeighbAddr(ABOVE, false); // B1'
				getNonMergedScaledMv(list, true);
			end
			if(not predFlag) then
				getNeighbAddr(ABOVE_LEFT, false); // B2'
				getNonMergedScaledMv(list, true);
			end
			getColCandidate(false, list);
			foreach int i in numCandidate .. 4
			do
				mvPred[i][list][0] := 0;
				mvPred[i][list][1] := 0;
			end
		end
	end

	getMvd: action SyntaxElem:[mvd] repeat 4 ==> IsBiPredOrLx:[isBiPredOrLx],
		IsReadOrNewSlice:[1], Mv:[mvToSend] repeat 2, RefIdx:[refIdxToSend],
		PocRef:[pocToSend], PredCuSize:[predCuSize]
	var
		int idxMvInfo,
		int mv[2][2],
		int refIdx[2],
		int mvToSend[2],
		int refIdxToSend,
		int(size=16) pocToSend
	do
		foreach int i in 0 .. 1
		do
			idxMvInfo :=
				if(mergeIdx >= 0) then
					mergeIdx
				else
					mvpIdx[i]
				end;
			mv[i][0] := mvPred[idxMvInfo][i][0] + mvd[2*i];
			mv[i][1] := mvPred[idxMvInfo][i][1] + mvd[2*i + 1];
			refIdx[i] := refIdxPred[idxMvInfo][i];
		end
		if(mergeIdx = -1) then
			refIdx := [refIdxRef[currIdx][partAddr[0]][partAddr[1]][i]:
				for int i in 0 .. 1];
		end
		if(not isBSlice || refIdx[0]!=-1 && refIdx[1] !=-1 &&
			predCuSize = 8 && (cuSize[0] < 8 || cuSize[1]<8)) then
			refIdx[1] := -1;
			mv[1][0] := 0;
			mv[1][1] := 0;
		end
		saveRefIdx(refIdx);
		saveMvComponent(mv);
		if(refIdx[0]!= -1 and refIdx[1]!= -1) then
			isBiPredOrLx := BI_PRED;
		else if(refIdx[0] != -1) then
			isBiPredOrLx := PRED_L0;
		else
			isBiPredOrLx := PRED_L1;
		end end
		if(refIdx[0]!=-1) then
			refIdxToSend := refIdx[0];
			pocToSend := pocRefListX[0][refIdx[0]];
			mvToSend := [mv[0][i] + (cuAddr[i]<<2): for int i in 0 ..1];
		else
			refIdxToSend := refIdx[1];
			pocToSend    := pocRefListX[1][refIdx[1]];
			mvToSend     := [mv[1][i] + (cuAddr[i]<<2): for int i in 0 ..1];
		end
	end

	getRps.launch: action RpsPoc:[numPic]==>
	guard
		nbList < 5
	do
		sizeOfList := numPic;
	end

	getRps.done: action ==>
	guard
		nbList = 5
	do
		foreach int i in 0 .. 6
		do
			isRef[i] := isRef[i] and isStillRef[i];
		end
		isRef[currIdx] := true;
	end

	getRpsPoc.launch: action RpsPoc:[pocVal] ==>
	guard
		sizeOfList > 0
	do
		sizeOfList := sizeOfList - 1;
		foreach int i in 0 .. 6
		do
			if(pocRef[i] = pocVal)then
				isStillRef[i] := true;
			end
		end
	end

	getRpsPoc.done: action ==>
	guard
		sizeOfList = 0
	do
		nbList := nbList + 1;
	end

	getSizeRefList.launch: action RefList:[sizeList] ==>
	guard
		listIdx < 2
	do
		listSize := sizeList;
		sizeIdx := 0;
	end

	getSizeRefList.done: action ==>
	guard
		listIdx = 2
	do
		useLN := (maxPoc>pocRef[currIdx]) || not isBSlice;
		
		colPoc := pocRefListX[colocFromL0^1][colRefIdx];
		colRefIdx := 0;
		foreach int i in 0 .. 6
		do
			if(isRef[i] && pocRef[i] = colPoc) then
				foreach int list in 0 .. 1
				do
					foreach int j in 0 .. 15
					do
						colRefPoc[list][j] := pocRefList[i][list][j];
					end
				end
				colRefIdx := i;
			end
		end
	end

	getRefList.launch: action RefList:[refPoc] ==>
	guard
		sizeIdx < listSize
	do
		maxPoc := max(maxPoc, refPoc);
		pocRefListX[listIdx][sizeIdx] := refPoc;
		pocRefList[currIdx][listIdx][sizeIdx] := refPoc;
		sizeIdx := sizeIdx + 1;
	end

	getRefList.done: action ==>
	guard
		sizeIdx = listSize
	do
		listIdx := listIdx + 1;
	end

	send2ndMv.launch: action ==> PocRef:[pocToSend], RefIdx:[refIdxToSend],
		Mv:[mvToSend] repeat 2, PredCuSize:[predCuSize]
	guard
		isBiPredOrLx = BI_PRED
	var
		int refIdxToSend,
		int mvToSend[2],
		int(size=16) pocToSend
	do
		refIdxToSend := refIdxRef[currIdx][partAddr[0]][partAddr[1]][1];
		mvToSend := [mvRef[currIdx][partAddr[0]][partAddr[1]][1][i] +
			(cuAddr[i]<<2): for int i in 0 .. 1];
		pocToSend := pocRefListX[1][refIdxToSend];
	end

	send2ndMv.skip: action ==>
	guard
		isBiPredOrLx != BI_PRED
	end

	schedule fsm GetPartMode:
		GetPartMode (isNewSlice       )--> GetRps;
		GetPartMode (getPartMode      )--> GetCuInfo;

		GetRps (getRps.launch )--> GetRpsPoc;
		GetRps (getRps.done   )--> GetSizeRefList;

		GetRpsPoc (getRpsPoc.launch )--> GetRpsPoc;
		GetRpsPoc (getRpsPoc.done   )--> GetRps;

		GetSizeRefList (getSizeRefList.launch )--> GetRefList;
		GetSizeRefList (getSizeRefList.done   )--> GetPartMode;

		GetRefList (getRefList.launch )--> GetRefList;
		GetRefList (getRefList.done   )--> GetSizeRefList;

		GetCuInfo   (getCuInfo.launch )--> GetCuMode;
		GetCuInfo   (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotInter )--> GetCuInfo;
		GetCuMode (getCuMode.isInter    )--> CheckMergeIdx;

		CheckMergeIdx (checkMergeIdx )--> GetMvd;
		GetMvd        (getMvd        )--> Send2ndMv;
		Send2ndMv     (send2ndMv     )--> GetCuInfo;
	end
end