/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package inLoopFilter;

import std.util.Math.*;
import common.CommonConstantHEVC.*;
import interPrediction.NaluType.*;

actor DeblockingFilter(bool FILT_VERT_EDGES, bool FILT_HOR_EDGES, bool DEBUG)
	uint(size=2)  Bs,
	uint(size=2)  IsPicSlcLcu,
	uint(size=16) PicSize,
	int (size=8)  Qp,
	uint(size=8)  SampleIn
		==>
	uint(size=8)  FiltSample
		:

	uint(size=4)  BIT_DEPTH = 8;

	uint(size=8) betaTable[52] =
		[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
		  0,  0,  0,  0,  0,  0,  6,  7,  8,  9,
		 10, 11, 12, 13, 14, 15, 16, 17, 18, 20,
		 22, 24, 26, 28, 30 ,32, 34, 36, 38, 40,
		 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		 62, 64];

	uint(size=8) tcTable[54] =
		[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
		  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,
		  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,
		  2,  3,  3,  3,  3,  4,  4,  4,  5,  5,
		  6,  6,  7,  8,  9, 10, 11, 13, 14, 16,
		  18, 20, 22, 24];

	uint(size=8) qPcTable[52] =
		 [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
		   10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		   20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		   29, 30, 31, 32, 33, 33, 34, 34, 35, 35,
		   36, 36, 37, 37, 38, 39, 40, 41, 42, 43,
		   44, 45];

	uint(size=6)  picSizeInCu[2];
	uint(size=16) picSize[2];
	uint(size=6)  xIdx;
	uint(size=6)  yIdx;
	uint(size=6)  lastXIdx;
	uint(size=6)  lastYIdx;
	uint(size=6)  xIdxSamp;
	uint(size=6)  yIdxSamp;
	uint(size=16) xAddrVert;
	uint(size=16) yAddrVert;
	int (size=16) xAddrHor;
	int (size=16) yAddrHor;	
	uint(size=16) pixAddr[2];
	uint(size=9)  blkIdx := 0;

	uint(size=8)  pictureBuffer[3][PICT_WIDTH][PICT_HEIGHT];
	int (size=8)  qpTab[PICT_WIDTH/4][2*64/4];
	uint(size=2)  bSTableVert[256];
	uint(size=2)  bSTableHoriz[2][256];
	uint(size=1)  currHorIdx;

	int           betaOffset;
	uint(size=2)  dE;
	bool          dEp;
	bool          dEq;
	int           qPi;
	int           tcOffset;
	uint(size=8)  tc;

	function decisionProcessLumaSamp(uint(size=8) p0, uint(size=8) p3,
		uint(size=8) q0, uint(size=8) q3, int dpq, int beta) --> bool
	:
		(dpq < (beta>>2)) &&
		(abs(p3-p0) + abs(q0-q3))<(beta>>3) &&
		abs(p0-q0)<((5*tc+1)>>1)
	end

	procedure decisionProcessLumaBlkEdge(uint(size=16) addr[2], bool isVertical, uint(size=8) bS)
	var
		uint(size=16) q0X = (addr[0]/4) & (PICT_WIDTH/4-1),
		uint(size=16) q0Y = (addr[1]/4) & 31,
		uint(size=16) p0X, uint(size=16) p0Y,
		int Q,
		uint(size=16) beta,
		int dp0, int dp3, int dq0, int dq3,
		int dpq0, int dpq3,
		int dp, int dq,
		int d,
		int p0[4], int q0[4],
		int p3[4], int q3[4],
		bool dSam0, bool dSam3
	begin
		if(isVertical) then
			p0X := q0X-1;
			p0Y := q0Y;
		else
			p0X := q0X;
			p0Y := (q0Y-1)&31;
		end
		qPi := ((qpTab[q0X][q0Y] + qpTab[p0X][p0Y] + 1)>>1);
		Q := clip_i32(qPi+betaOffset, 0, 51);
		beta := betaTable[Q]<<(BIT_DEPTH - 8);
		Q := clip_i32(qPi + 2*(bS-1) + tcOffset, 0, 53);
		tc := tcTable[Q]<<(BIT_DEPTH - 8);
		if(isVertical) then
			q0 := [pictureBuffer[0][addr[0]+i][addr[1]]:for int i in 0 .. 3];
			p0 := [pictureBuffer[0][addr[0]-i][addr[1]]:for int i in 1 .. 4];
			q3 := [pictureBuffer[0][addr[0]+i][addr[1]+3]:for int i in 0 .. 3];
			p3 := [pictureBuffer[0][addr[0]-i][addr[1]+3]:for int i in 1 .. 4];
		else
			q0 := [pictureBuffer[0][addr[0]][addr[1]+i]:for int i in 0 .. 3];
			p0 := [pictureBuffer[0][addr[0]][addr[1]-i]:for int i in 1 .. 4];
			q3 := [pictureBuffer[0][addr[0]+3][addr[1]+i]:for int i in 0 .. 3];
			p3 := [pictureBuffer[0][addr[0]+3][addr[1]-i]:for int i in 1 .. 4];
		end
		dp0 :=abs(p0[2]-2*p0[1]+p0[0]);
		dq0 :=abs(q0[2]-2*q0[1]+q0[0]);
		dp3 :=abs(p3[2]-2*p3[1]+p3[0]);
		dq3 :=abs(q3[2]-2*q3[1]+q3[0]);
		dpq0 := dp0+dq0;
		dpq3 := dp3+dq3;
		dp := dp0+dp3;
		dq := dq0+dq3;
		d  := dpq0 + dpq3;
		if(d<beta) then
			dSam0 := decisionProcessLumaSamp(p0[0], p0[3], q0[0], q0[3],
				2*dpq0, beta);
			dSam3 := decisionProcessLumaSamp(p3[0], p3[3], q3[0], q3[3], 2*dpq3, beta);
	
			dE := 1;
			dEp := false;
			dEq := false;
			if(dSam0 && dSam3) then
				dE := 2;
			end
			if(dp < (beta+(beta>>1))>>3) then
				dEp := true;
			end
			if(dq < (beta+(beta>>1))>>3) then
				dEq := true;
			end
		else
			dE  := 0;
			dEp := false;
			dEq := false;
		end
	end

	procedure filterProcessLumaBlkEdge(uint(size=16) addr[2], bool isVerticalEdge)
	var
		uint(size=8) p[4],
		uint(size=8) q[4]
	begin
		if(isVerticalEdge) then
			if(dE!=0) then
				foreach int y in 0 .. 3
				do
					p := [pictureBuffer[0][addr[0]-i][addr[1]+y]: for int i in 1 ..4];
					q := [pictureBuffer[0][addr[0]+i][addr[1]+y]: for int i in 0 .. 3];
					filterProcessLumaSamp(p, q);
					foreach int i in 0 .. 2
					do
						pictureBuffer[0][addr[0]-1-i][addr[1]+y] := p[i];
						pictureBuffer[0][addr[0]  +i][addr[1]+y] := q[i];
					end
				end
			end
		else
			if(dE!=0) then
				foreach int x in 0 .. 3
				do
					p := [pictureBuffer[0][addr[0]+x][addr[1]-i]: for int i in 1 ..4];
					q := [pictureBuffer[0][addr[0]+x][addr[1]+i]: for int i in 0 .. 3];
					filterProcessLumaSamp(p, q);
					foreach int i in 0 .. 2
					do
						pictureBuffer[0][addr[0]+x][addr[1]-1-i] := p[i];
						pictureBuffer[0][addr[0]+x][addr[1]  +i] := q[i];
					end
				end
			end
		end
	end

	procedure filterProcessLumaSamp(uint(size=8) p[4], uint(size=8) q[4])
	var
		uint(size=8) p0=p[0], uint(size=8) p1=p[1], uint(size=8) p2=p[2],
		uint(size=8) q0=q[0], uint(size=8) q1=q[1], uint(size=8) q2=q[2],
		uint(size=8) p3=p[3], uint(size=8) q3=q[3],
		int delta, int deltaP, int deltaQ
	begin
		if(dE=2) then
			p[0] := clip_i32((p2+2*p1+2*p0+2*q0+q1+4)>>3, p0-2*tc, p0+2*tc);
			p[1] := clip_i32((p2+p1+p0+q0+2)>>2, p1-2*tc, p1+2*tc);
			p[2] := clip_i32((2*p3+3*p2+p1+p0+q0+4)>>3, p2-2*tc, p2+2*tc);
			q[0] := clip_i32((p1+2*p0+2*q0+2*q1+q2+4)>>3, q0-2*tc, q0+2*tc);
			q[1] := clip_i32((p0+q0+q1+q2+2)>>2, q1-2*tc, q1+2*tc);
			q[2] := clip_i32((p0+q0+q1+3*q2+2*q3+4)>>3, q2-2*tc, q2+2*tc);
		else
			delta := (9*(q0-p0)-3*(q1-p1)+8)>>4;
			if(abs(delta)<10*tc) then
				delta := clip_i32(delta, -tc, tc);
				p[0] := clip_i32(p0+delta, 0, 255);
				q[0] := clip_i32(q0-delta, 0, 255);
				if(dEp) then
					deltaP := clip_i32( ((((p2+p0+1)>>1)-p1+delta)>>1), -(tc>>1), tc>>1);
					p[1] := clip_i32(p1+deltaP, 0, 255);
				end
				if(dEq) then
					deltaQ := clip_i32(((((q2+q0+1)>>1)-q1-delta)>>1), -(tc>>1), tc>>1);
					q[1] := clip_i32(q1+deltaQ, 0, 255);
				end
			end
		end
		//There should be the code for reverting filtering if pcm and
		//pcmLoopFilterDisableFlag is active.
	end

	procedure filtProcessChrBlkEdge(uint(size=16) addr[2], bool isVerticalEdge,
		uint(size=2) cIdx)
	var
		uint(size=2) bS = 2,
		int qPC, int Q,
		uint(size=16) addrX = addr[0]>>1,
		uint(size=16) addrY = addr[1]>>1,
		uint(size=8) p[2], uint(size=8) q[2]
	begin
		qPC := qPcTable[min(qPi,51)];
		Q  := clip_i32(qPC + 2*(bS-1) + tcOffset, 0, 53);
		tc := tcTable[Q]<<(BIT_DEPTH - 8);
		if(isVerticalEdge) then
			foreach int y in 0 .. 1
			do
				p := [pictureBuffer[cIdx][addrX-i][addrY+y]: for int i in 1 .. 2];
				q := [pictureBuffer[cIdx][addrX+i][addrY+y]: for int i in 0 .. 1];
				filterProcessChrSamp(p, q);
				pictureBuffer[cIdx][addrX-1][addrY+y] := p[0];
				pictureBuffer[cIdx][addrX][addrY+y] := q[0];
			end
		else
			foreach int x in 0 .. 1
			do
				p := [pictureBuffer[cIdx][addrX+x][addrY-i]: for int i in 1 .. 2];
				q := [pictureBuffer[cIdx][addrX+x][addrY+i]: for int i in 0 .. 1];
				filterProcessChrSamp(p, q);
				pictureBuffer[cIdx][addrX+x][addrY-1] := p[0];
				pictureBuffer[cIdx][addrX+x][addrY] := q[0];
			end
		end
	end

	procedure filterProcessChrSamp(uint(size=8) p[2], uint(size=8) q[2])
	var
		int delta,
		uint(size=8) p0=p[0], uint(size=8) p1=p[1],
		uint(size=8) q0=q[0], uint(size=8) q1=q[1]
	begin
		delta := clip_i32(((((q0-p0)<<2)+p1-q1+4)>>3), -tc, tc);
		p[0] := clip_i32(p0+delta, 0, 255);
		q[0] := clip_i32(q0-delta, 0, 255);
		//There should be the code for reverting filtering if pcm and
		//pcmLoopFilterDisableFlag is active.
	end

	procedure saveRasterScanCu(uint(size=8) sample[64*64 + 2*32*32])
	var
		uint(size=16) pixAddr[2],
		uint tokenOffset
	begin
		foreach uint blkIdx in 0 .. 255
		do
			rasterScanToAbsCoord(blkIdx, pixAddr);
			pixAddr[0] := pixAddr[0] + xAddrVert;
			pixAddr[1] := pixAddr[1] + yAddrVert;
			tokenOffset := blkIdx*(16+2*4);
			foreach uint y in 0 .. 3
			do
				foreach uint x in 0 .. 3
				do
					pictureBuffer[0][pixAddr[0]+x][pixAddr[1]+y] :=
						sample[tokenOffset + 4*y+x];
				end
			end
			tokenOffset := tokenOffset + 16;
			pixAddr[0]  := pixAddr[0]>>1;
			pixAddr[1]  := pixAddr[1]>>1;
			foreach uint comp in 1 .. 2
			do
				foreach uint y in 0 .. 1
				do
					foreach uint x in 0 .. 1
					do
						pictureBuffer[comp][pixAddr[0]+x][pixAddr[1]+y] :=
							sample[tokenOffset + 2*y+x];
					end
				end
				tokenOffset := tokenOffset + 4;
			end
		end
	end

	procedure saveZScanCu(uint(size=8) sample[64*64 + 2*32*32])
	var
		uint(size=16) blkAddrX, uint(size=16) blkAddrY,
		uint tokenOffset
	begin
		blkAddrX := xIdx*64;
		blkAddrY := yIdx*64;
		foreach uint y in 0 .. 63
		do
			foreach uint x in 0 .. 63
			do
				pictureBuffer[0][blkAddrX+x][blkAddrY+y] := sample[x+y*64];
			end
		end

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		tokenOffset:= 64*64;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 31
			do
				foreach uint x in 0 .. 31
				do
					pictureBuffer[comp][blkAddrX+x][blkAddrY+y] := sample[x+y*32 + tokenOffset];
				end
			end
			tokenOffset:= tokenOffset + 32*32;
		end
	end

	isNewSlc: action IsPicSlcLcu:[isNewPicSlcLcu], PicSize:[picWidthInPix, picHeightInPix] ==>
	guard
		isNewPicSlcLcu = NEW_SLC
	end
uint numPict;
	isNewPict: action IsPicSlcLcu:[isNewPicSlcLcu], PicSize:[picWidthInPix, picHeightInPix] ==>
	guard
		isNewPicSlcLcu = NEW_PIC
	do
		println("num Pict : "+numPict);
		numPict := numPict + 1;
		picSize[0] := picWidthInPix;
		picSize[1] := picHeightInPix;
		picSizeInCu[0] := (picWidthInPix+63)/64;
		picSizeInCu[1] := (picHeightInPix+63)/64;
		lastXIdx := 0;
		lastYIdx := 0;
		xIdx := 0;
		yIdx := 0;
		xIdxSamp := 0;
		yIdxSamp := 0;
		xAddrHor := -1;
	end

	getCuPix.launch.pict: action Bs:[bs] repeat 512, IsPicSlcLcu:[isLcu], Qp:[qp] repeat 256, SampleIn:[samp] repeat 64*64 + 32*32*2==>
	guard
		yIdx < picSizeInCu[1]-1 && xIdx < picSizeInCu[0]-1 && isLcu = NEW_LCU
	var
		uint(size=16) xMin, uint(size=16) xMax,
		uint(size=16) yMin, uint(size=16) yMax, uint(size=16) yVal
	do
		xAddrVert := xIdx*64;
		yAddrVert := yIdx*64;
		if(FILT_VERT_EDGES) then
			saveRasterScanCu(samp);
		else
			saveZScanCu(samp);
		end

		xMin := (xAddrVert & PICT_WIDTH-1) >>2;
		xMax := (xMin+16)&(PICT_WIDTH/4-1);
		yMin := (yAddrVert/4)&31;
		yMax := ((yAddrVert+64)/4)&31;
		yVal := yMin;
		while(yVal!=yMax)
		do
			foreach uint x in xMin .. xMax
			do
				
				qpTab[x][yVal] := qp[absCoordToRasterScan([x<<2,yVal<<2])];
			end
			yVal := (yVal+1)&31;
		end
		bSTableVert := [bs[2*j]: for uint j in 0 .. 255];
		bSTableHoriz[currHorIdx&1] := [bs[1+2*j]: for uint j in 0 .. 255];

		currHorIdx := currHorIdx + 1;
		lastXIdx := xIdx;
		lastYIdx := yIdx;
		xIdx := xIdx + 1;
		if(xIdx = picSizeInCu[0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
		end
	end

	getCuPix.launch.lastColOrRow.vert: action IsPicSlcLcu:[isLcu] ==>
	guard
		(xIdx = picSizeInCu[0]-1 || yIdx = picSizeInCu[1]-1) && FILT_VERT_EDGES && isLcu = NEW_LCU
	do
		xAddrVert := xIdx*64;
		yAddrVert := yIdx*64;

		blkIdx := 0;
		rasterScanToAbsCoord(0, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getCuPix.launch.lastColOrRow.hor: action IsPicSlcLcu:[isLcu], SampleIn:[samp] repeat 64*64 + 32*32*2 ==>
	guard
		(xIdx = picSizeInCu[0]-1 || yIdx = picSizeInCu[1]-1) && not FILT_VERT_EDGES && isLcu = NEW_LCU
	do
		xAddrVert := xIdx*64;
		yAddrVert := yIdx*64;
		saveZScanCu(samp);
		blkIdx := 0;
	end

	getBlk.launch: action  Bs:[bs] repeat 2, Qp:[qp], SampleIn:[samp] repeat 4*4 + 2*2*2 ==>
	guard
		blkIdx < 256 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		foreach uint y in 0 .. 3
		do
			foreach uint x in 0 .. 3
			do
				pictureBuffer[0][pixAddr[0]+x][pixAddr[1]+y] :=
					samp[4*y+x];
			end
		end

		qpTab[(pixAddr[0] & PICT_WIDTH-1) >>2][(pixAddr[1]/4)&31] := qp;
		bSTableVert[blkIdx] := bs[0];
		bSTableHoriz[currHorIdx&1][blkIdx] := bs[1];

		pixAddr[0]  := pixAddr[0]>>1;
		pixAddr[1]  := pixAddr[1]>>1;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pictureBuffer[comp][pixAddr[0]+x][pixAddr[1]+y] :=
						samp[2*y+x + 16+4*(comp-1)];
				end
			end
		end

		blkIdx := blkIdx + 1;
		rasterScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBlk.skip.vertEdge: action ==>
	guard
		blkIdx < 256  && FILT_VERT_EDGES,
		pixAddr[0] >= picSize[0] || pixAddr[1] >= picSize[1]
	do
		bSTableVert[blkIdx] := 0;
		bSTableHoriz[currHorIdx&1][blkIdx] := 0;
		blkIdx := blkIdx + 1;
		rasterScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBlk.skip.horEdge: action SampleIn:[samp] repeat 4*4 + 2*2*2 ==>
	guard
		blkIdx < 256  && not FILT_VERT_EDGES,
		pixAddr[0] >= picSize[0] || pixAddr[1] >= picSize[1]
	do
		bSTableVert[blkIdx] := 0;
		bSTableHoriz[currHorIdx&1][blkIdx] := 0;
		blkIdx := blkIdx + 1;
		rasterScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBlk.done: action ==>
	guard
		blkIdx = 256
	do
		currHorIdx := currHorIdx + 1;
		lastXIdx := xIdx;
		lastYIdx := yIdx;
		xIdx := xIdx + 1;
		if(xIdx = picSizeInCu[0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
		end
	end


	getBs4Blk.launch: action  Bs:[bs] repeat 2, Qp:[qp] ==>
	guard
		blkIdx < 256 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do

		qpTab[(pixAddr[0] & PICT_WIDTH-1) >>2][(pixAddr[1]/4)&31] := qp;
		bSTableVert[blkIdx] := bs[0];
		bSTableHoriz[currHorIdx&1][blkIdx] := bs[1];

		blkIdx := blkIdx + 1;
		rasterScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBs4Blk.skip: action ==>
	guard
		blkIdx < 256,
		pixAddr[0] >= picSize[0] || pixAddr[1] >= picSize[1]
	do
		bSTableVert[blkIdx] := 0;
		bSTableHoriz[currHorIdx&1][blkIdx] := 0;
		blkIdx := blkIdx + 1;
		rasterScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBs4Blk.done: action ==>
	guard
		blkIdx = 256
	do
		currHorIdx := currHorIdx + 1;
		lastXIdx := xIdx;
		lastYIdx := yIdx;
		xIdx := xIdx + 1;
		if(xIdx = picSizeInCu[0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
		end
	end

	getCuPix.done: action ==>
	guard
		yIdx = picSizeInCu[1]
	var
		uint(size=16) blkAddr[2]
	do
		if(xAddrHor != -1 and FILT_HOR_EDGES) then
			foreach int idxBlk in 0 .. 255
			do
				if(bSTableHoriz[(currHorIdx&1)^1][idxBlk]!=0) then
					rasterScanToAbsCoord(idxBlk, blkAddr);
					blkAddr[0] := blkAddr[0] + xAddrHor;
					blkAddr[1] := blkAddr[1] + yAddrHor;
					decisionProcessLumaBlkEdge(blkAddr, false, bSTableHoriz[(currHorIdx&1)^1][idxBlk]);
					filterProcessLumaBlkEdge(blkAddr, false);
					if(bSTableHoriz[(currHorIdx&1)^1][idxBlk]=2 && ((blkAddr[1]>>2)&3) = 0 ) then
						foreach int cIdx in 1 .. 2
						do
							filtProcessChrBlkEdge(blkAddr, false, cIdx);
						end
					end
				end
			end
		end
		lastXIdx := 0;
		lastYIdx := 0;
		xIdx := 0;
		yIdx := 0;
	end

	filterEdges: action ==>
	var
		uint(size=16) blkAddr[2]
	do
		if(FILT_VERT_EDGES) then
			foreach int idxBlk in 0 .. 255
			do
				if(bSTableVert[idxBlk]!=0) then
					rasterScanToAbsCoord(idxBlk, blkAddr);
					blkAddr[0] := blkAddr[0] + xAddrVert;
					blkAddr[1] := blkAddr[1] + yAddrVert;
					decisionProcessLumaBlkEdge(blkAddr, true, bSTableVert[idxBlk]);
					filterProcessLumaBlkEdge(blkAddr, true);
					if(bSTableVert[idxBlk]=2 && ((blkAddr[0]>>2)&3) = 0 ) then
						foreach int cIdx in 1 .. 2
						do
							filtProcessChrBlkEdge(blkAddr, true, cIdx);
						end
					end
				end
			end
		end
		if(FILT_HOR_EDGES) then
			if(xAddrHor != -1) then
				foreach int idxBlk in 0 .. 255
				do
					if(bSTableHoriz[currHorIdx&1][idxBlk]!=0) then
						rasterScanToAbsCoord(idxBlk, blkAddr);
						blkAddr[0] := blkAddr[0] + xAddrHor;
						blkAddr[1] := blkAddr[1] + yAddrHor;
						decisionProcessLumaBlkEdge(blkAddr, false, bSTableHoriz[currHorIdx&1][idxBlk]);
						filterProcessLumaBlkEdge(blkAddr, false);
						if(bSTableHoriz[currHorIdx&1][idxBlk]=2 && ((blkAddr[1]>>2)&3) = 0 ) then
							foreach int cIdx in 1 .. 2
							do
								filtProcessChrBlkEdge(blkAddr, false, cIdx);
							end
						end
					end
				end
			end
		end
		xAddrHor := xAddrVert;
		yAddrHor := yAddrVert;
	end

	filteringOnlyVertEdge.isTrue: action ==>
	guard
		FILT_VERT_EDGES and not FILT_HOR_EDGES
	end

	filteringOnlyVertEdge.isFalse: action ==>
	guard
		FILT_HOR_EDGES
	end

	sendSamples.launch: action ==> FiltSample:[filtSamp] repeat 64*64 + 2* 32*32
	guard
		yIdxSamp < picSizeInCu[1],
		FILT_HOR_EDGES || xIdxSamp != lastXIdx || yIdxSamp != lastYIdx
	var
		uint tokenOffset,
		uint(size=8) filtSamp[64*64+2*32*32],
		uint(size=16) blkAddrX, uint(size=16) blkAddrY
	do
		blkAddrX := xIdxSamp*64;
		blkAddrY := yIdxSamp*64;
		foreach uint y in 0 .. 63
		do
			foreach uint x in 0 .. 63
			do
				if(not DEBUG) then
					filtSamp[x+y*64] := pictureBuffer[0][blkAddrX+x][blkAddrY+y];
				else
					if(blkAddrX+x<picSize[0] && blkAddrY+y<picSize[1]) then
						filtSamp[x+y*64] := pictureBuffer[0][blkAddrX+x][blkAddrY+y];
					else
						filtSamp[x+y*64] := 0;
					end
				end
			end
		end

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		tokenOffset:= 64*64;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 31
			do
				foreach uint x in 0 .. 31
				do
					if(not DEBUG) then
						filtSamp[x+y*32 + tokenOffset] := pictureBuffer[comp][blkAddrX+x][blkAddrY+y];
					else
						if(blkAddrX+x<picSize[0]/2 && blkAddrY+y<picSize[1]/2) then
							filtSamp[x+y*32 + tokenOffset] := pictureBuffer[comp][blkAddrX+x][blkAddrY+y];
						else
							filtSamp[x+y*32 + tokenOffset] := 0;
						end
					end
				end
			end
			tokenOffset:= tokenOffset + 32*32;
		end

		xIdxSamp := xIdxSamp + 1;
		if(xIdxSamp = picSizeInCu[0]) then
			xIdxSamp := 0;
			yIdxSamp := yIdxSamp + 1;
		end
	end

	sendSamples.skip: action ==> 
	guard
		 xIdxSamp = lastXIdx
	end

	sendSamples.done: action ==>
	guard
		yIdxSamp = picSizeInCu[1]
	end

	schedule fsm IsNewPict:
		IsNewPict (isNewPict )--> GetCuPix;

		GetCuPix  (isNewSlc                          )--> GetCuPix;
		GetCuPix  (getCuPix.launch.pict              )--> FilterEdges;
		GetCuPix  (getCuPix.launch.lastColOrRow.vert )--> GetBlk;
		GetCuPix  (getCuPix.launch.lastColOrRow.hor  )--> GetBs4Blk;
		GetCuPix  (getCuPix.done                     )--> SendSamples;

		GetBlk (getBlk.launch )--> GetBlk;
		GetBlk (getBlk.skip   )--> GetBlk;
		GetBlk (getBlk.done   )--> FilterEdges;

		GetBs4Blk (getBs4Blk.launch )--> GetBs4Blk;
		GetBs4Blk (getBs4Blk.skip   )--> GetBs4Blk;
		GetBs4Blk (getBs4Blk.done   )--> FilterEdges;

		FilterEdges (filterEdges  )--> CheckEdgeFiltered;

		CheckEdgeFiltered (filteringOnlyVertEdge.isTrue  )--> SendSamplesVert;
		CheckEdgeFiltered (filteringOnlyVertEdge.isFalse )--> GetCuPix;

		SendSamplesVert (sendSamples.launch )--> GetCuPix;
		SendSamplesVert (sendSamples.skip   )--> GetCuPix;

		SendSamples (sendSamples.launch )--> SendSamples;
		SendSamples (sendSamples.done   )--> IsNewPict;
	end
end