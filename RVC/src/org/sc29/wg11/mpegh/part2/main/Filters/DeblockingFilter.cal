/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (EPFL), 
in the course of development of the ISO/IEC 23002-5 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-5.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-5 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards.

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-5 once the ISO/IEC 23002-5 has been adopted; and 
(2) to develop the ISO/IEC 23002-5: 

EPFL grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-5 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-5 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-5.  To the extent that EPFL
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-5 in a conforming product, EPFL
will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-5

EPFL retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2011-2014.
*****************************************************************************/
package org.sc29.wg11.mpegh.part2.main.Filters;

import std.util.Math.*;
import org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

//Pipelined version broken
actor DeblockingFilter(bool FILT_VERT_EDGES, bool FILT_HOR_EDGES, bool DEBUG)
	uint(size=2)  BsHor,
	uint(size=2)  BsVer,
	bool          DBFDisable,
	uint(size=2)  IsPicSlcLcu,
	uint(size=8)  BitDepth,
	uint(size=8)  LcuSize,
	uint(size=16) PicSize,
	int (size=8)  Qp,
	uint(size=16) SampleIn,
	int (size=8)  SyntaxElem,
	uint(size=16) TilesCoord,
	uint(size=16) LFBypassCUInfo
		==>
	uint(size=16) FiltSample
		:

	uint(size=8) betaTable[52] =
		[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
		  0,  0,  0,  0,  0,  0,  6,  7,  8,  9,
		 10, 11, 12, 13, 14, 15, 16, 17, 18, 20,
		 22, 24, 26, 28, 30 ,32, 34, 36, 38, 40,
		 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		 62, 64];

	uint(size=8) tcTable[54] =
		[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
		  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,
		  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,
		  2,  3,  3,  3,  3,  4,  4,  4,  5,  5,
		  6,  6,  7,  8,  9, 10, 11, 13, 14, 16,
		  18, 20, 22, 24];

	uint(size=8) qPcTable[52] =
		 [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
		   10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		   20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		   29, 30, 31, 32, 33, 33, 34, 34, 35, 35,
		   36, 36, 37, 37, 38, 39, 40, 41, 42, 43,
		   44, 45];

	int(size=16) iLoop;

	uint(size=16) numTiles;
	uint(size=16) tileIdx;
	uint(size=16) numPartition;
	uint(size=16) tilesBegSamp[MAX_NUM_TILES][2];
	uint(size=16) tilesEndSamp[MAX_NUM_TILES][2];
	int (size=5)  qpChrOff[2];

	uint(size=8)  bitDepthY  := 8;
	uint(size=8)  bitDepthC  := 8;
	uint(size=16) maxPixValY := 255;
	uint(size=16) maxPixValC := 255;

	uint(size=8)  lcuSizeMax;
	uint(size=8)  log2LcuSizeMax;
	uint(size=8)  log2puSizeMin;
	uint(size=8)  minPUSize[2];
	uint(size=16) picSize[2];

	uint(size=16) xIdx;
	uint(size=16) yIdx;
/*	uint(size=6)  lastXIdx;
	uint(size=6)  lastYIdx;*/
	uint(size=2)  compIdx;
	uint(size=16) xAddrVert;
	uint(size=16) yAddrVert;
	int (size=16) xAddrHor;
	int (size=16) yAddrHor;
	uint(size=16) numTokenPerLcu[2];
	uint(size=16) tokenSent;
	uint(size=16) pixAddr[2];
	uint(size=9)  blkIdx := 0;
	bool          disDbf := false;

	uint(size=16) pictureBuffer[3][PICT_HEIGHT][PICT_WIDTH];
	int (size=8)  qpTab[PICT_WIDTH/4][PICT_HEIGHT/4];
	uint(size=2)  bSTableVert[256];
	uint(size=2)  bSTableHoriz[PICT_WIDTH/64][PICT_HEIGHT/64][256];

	int           betaOffset;
	uint(size=2)  dE;
	bool          dEp;
	bool          dEq;
	int           qPi;
	int           tcOffset;
	uint(size=8)  tc;
	uint(size=16) beta;

	function decisionProcessLumaSamp(uint(size=16) p0, uint(size=16) p3,
		uint(size=16) q0, uint(size=16) q3, int dpq, int beta) --> bool
	:
		(dpq < (beta>>2)) &&
		(abs(p3-p0) + abs(q0-q3))<(beta>>3) &&
		abs(p0-q0)<((5*tc+1)>>1)
	end

	procedure computeNextLcuAddr()
	begin
		xIdx := xIdx + lcuSizeMax;
		if(xIdx >= tilesEndSamp[tileIdx][0]) then
			xIdx := tilesBegSamp[tileIdx][0];
			yIdx := yIdx + lcuSizeMax;
			if(yIdx >= tilesEndSamp[tileIdx][1]) then
				tileIdx := tileIdx + 1;
				xIdx := tilesBegSamp[tileIdx][0];
				yIdx := tilesBegSamp[tileIdx][1];
			end
		end
	end

    procedure decisionProcessLumaBlkEdgeBetaTc(uint(size=16) addr[2], bool isVertical, uint(size=8) bS)
	var
		uint(size=16) q0X = (addr[0]/4) & (PICT_WIDTH/4-1),
		uint(size=16) q0Y = addr[1]/4,
		uint(size=16) p0X, uint(size=16) p0Y,
		int Q
	begin
	    if(isVertical) then
			p0X := q0X-1;
			p0Y := q0Y;
		else
			p0X := q0X;
			p0Y := q0Y-1;
		end
		qPi := ((qpTab[q0X][q0Y] + qpTab[p0X][p0Y] + 1)>>1);
		Q := clip_i32(qPi+betaOffset, 0, 51);
		beta := betaTable[Q]<<(bitDepthY - 8);
		Q := clip_i32(qPi + 2*(bS-1) + tcOffset, 0, 53);
		tc := tcTable[Q]<<(bitDepthY - 8);
	end
	
	procedure decisionProcessLumaBlkEdgeBeta(uint(size=16) addr[2], bool isVertical)
	var
		uint(size=16) q0X = (addr[0]/4) & (PICT_WIDTH/4-1),
		uint(size=16) q0Y = addr[1]/4,
		uint(size=16) p0X, uint(size=16) p0Y,
		int Q
	begin
	    if(isVertical) then
			p0X := q0X-1;
			p0Y := q0Y;
		else
			p0X := q0X;
			p0Y := q0Y-1;
		end
		qPi := ((qpTab[q0X][q0Y] + qpTab[p0X][p0Y] + 1)>>1);
		Q := clip_i32(qPi+betaOffset, 0, 51);
		beta := betaTable[Q]<<(bitDepthY - 8);
	end
	
	procedure decisionProcessLumaBlkEdge(uint(size=16) addr[2], bool isVertical, uint(size=16) betaLocal)
	var
		int dp0, int dp3, int dq0, int dq3,
		int dpq0, int dpq3,
		int dp, int dq,
		int d,
		uint(size=16) p0[4], uint(size=16) q0[4],
		uint(size=16) p3[4], uint(size=16) q3[4],
		bool dSam0, bool dSam3
	begin
		if(isVertical) then
			q0 := [pictureBuffer[0][addr[1]][addr[0]+i]:for int i in 0 .. 3];
			p0 := [pictureBuffer[0][addr[1]][addr[0]-i]:for int i in 1 .. 4];
			q3 := [pictureBuffer[0][addr[1]+3][addr[0]+i]:for int i in 0 .. 3];
			p3 := [pictureBuffer[0][addr[1]+3][addr[0]-i]:for int i in 1 .. 4];
		else
			q0 := [pictureBuffer[0][addr[1]+i][addr[0]]:for int i in 0 .. 3];
			p0 := [pictureBuffer[0][addr[1]-i][addr[0]]:for int i in 1 .. 4];
			q3 := [pictureBuffer[0][addr[1]+i][addr[0]+3]:for int i in 0 .. 3];
			p3 := [pictureBuffer[0][addr[1]-i][addr[0]+3]:for int i in 1 .. 4];
		end
		dp0 :=abs(p0[2]-2*p0[1]+p0[0]);
		dq0 :=abs(q0[2]-2*q0[1]+q0[0]);
		dp3 :=abs(p3[2]-2*p3[1]+p3[0]);
		dq3 :=abs(q3[2]-2*q3[1]+q3[0]);
		dpq0 := dp0+dq0;
		dpq3 := dp3+dq3;
		dp := dp0+dp3;
		dq := dq0+dq3;
		d  := dpq0 + dpq3;
		if(d<betaLocal) then
			dSam0 := decisionProcessLumaSamp(p0[0], p0[3], q0[0], q0[3], 2*dpq0, betaLocal);
			dSam3 := decisionProcessLumaSamp(p3[0], p3[3], q3[0], q3[3], 2*dpq3, betaLocal);
	
			dE := 1;
			dEp := false;
			dEq := false;
			if(dSam0 && dSam3) then
				dE := 2;
			end
			if(dp < (betaLocal+(betaLocal>>1))>>3) then
				dEp := true;
			end
			if(dq < (betaLocal+(betaLocal>>1))>>3) then
				dEq := true;
			end
		else
			dE  := 0;
			dEp := false;
			dEq := false;
		end
	end

	procedure filterProcessLumaBlkVerticalEdge(uint(size=16) addr[2], uint(size=8) tcLocal, uint(size=8) no_p, uint(size=8) no_q)
	var
		uint(size=16) p[4],
		uint(size=16) q[4]
	begin
		if (dE!=0) then
		  foreach int y in 0 .. 3
		  do
			p := [pictureBuffer[0][addr[1]+y][addr[0]-i]: for int i in 1 .. 4];
			q := [pictureBuffer[0][addr[1]+y][addr[0]+i]: for int i in 0 .. 3];
			filterProcessLumaSamp(p, q, tcLocal, no_p, no_q);
			foreach int i in 0 .. 2
			do
				pictureBuffer[0][addr[1]+y][addr[0]-1-i] := p[i];
				pictureBuffer[0][addr[1]+y][addr[0]  +i] := q[i];
			end
		  end
		end
	end

	procedure filterProcessLumaBlkHorizontalEdge(uint(size=16) addr[2], uint(size=8) tcLocal, uint(size=8) no_p, uint(size=8) no_q)
	var
		uint(size=16) p[4],
		uint(size=16) q[4]
	begin
		if (dE!=0) then
		  foreach int x in 0 .. 3
		  do
			p := [pictureBuffer[0][addr[1]-i][addr[0]+x]: for int i in 1 .. 4];
			q := [pictureBuffer[0][addr[1]+i][addr[0]+x]: for int i in 0 .. 3];
			filterProcessLumaSamp(p, q, tcLocal, no_p, no_q);
			foreach int i in 0 .. 2
			do
				pictureBuffer[0][addr[1]-1-i][addr[0]+x] := p[i];
				pictureBuffer[0][addr[1]  +i][addr[0]+x] := q[i];
			end
		  end
		end
	end

    procedure filterProcessLumaBlkVertical(int idxBlk)
	var
		uint(size=16) blkAddr[2],
		uint(size=16) blkAddr0[2],
		int betaTab[2], 
		int tcTab[2],
		int offset,
		uint(size=8) no_p[2] := [0 : for int i in 0 .. 1],
		uint(size=8) no_q[2] := [0 : for int i in 0 .. 1],
		uint(size=2) bS0 = bSTableVert[idxBlk],
		uint(size=2) bS1 = bSTableVert[idxBlk + 2]
	begin
	    if (bS0 != 0 or bS1 != 0) then
			zScanToAbsCoord(idxBlk, blkAddr);
			blkAddr0[0] := blkAddr[0] + xAddrVert;
			blkAddr0[1] := blkAddr[1] + yAddrVert;
			/* Tc and Beta calculation */
	   
			/* First edge */
			if (bS0 != 0) then
			    blkAddr[0] := blkAddr0[0];
			    blkAddr[1] := blkAddr0[1];
			    decisionProcessLumaBlkEdgeBetaTc(blkAddr, true, bS0);
			    betaTab[0] := beta;
			    tcTab[0] := tc;
			else
			    tcTab[0] := 0;
			end

			/* Second edge */
			if (bS1 != 0) then
			    blkAddr[0] := blkAddr0[0];
			    blkAddr[1] := blkAddr0[1] + 4;
			    decisionProcessLumaBlkEdgeBetaTc(blkAddr, true, bS1);
			    betaTab[1] := beta;
			    tcTab[1] := tc;
			else
			    tcTab[1] := 0;
			end
			
			/* Filtering 2 edges */
			if (tcTab[0] != 0 || tcTab[1] != 0) then
			
			    /* Compute only beta */
			    if (bS0 = 0) then
			      blkAddr[0] := blkAddr0[0];
			      blkAddr[1] := blkAddr0[1];
			      decisionProcessLumaBlkEdgeBeta(blkAddr, true);
			      betaTab[0] := beta;
			    end
			  
			    if (bS1 = 0) then
			      blkAddr[0] := blkAddr0[0];
			      blkAddr[1] := blkAddr0[1] + 4;
			      decisionProcessLumaBlkEdgeBeta(blkAddr, true);
			      betaTab[1] := beta;
			    end
			  
			    offset := 0 * (PICT_WIDTH * PICT_HEIGHT) + blkAddr0[1] * PICT_WIDTH + blkAddr0[0];
			    no_p[0] := getLFByPass(blkAddr0[0] - 1, blkAddr0[1]);
			    no_p[1] := getLFByPass(blkAddr0[0] - 1, blkAddr0[1] + 4);
			    no_q[0] := getLFByPass(blkAddr0[0], blkAddr0[1]);
			    no_q[1] := getLFByPass(blkAddr0[0], blkAddr0[1] + 4);
			    filterProcessLumaEdgeVertical(pictureBuffer, offset, PICT_WIDTH, betaTab, tcTab, no_p, no_q, blkAddr0, idxBlk);
			end
	    end
	end
	
	@optimize_c(condition="defined(OPENHEVC_ENABLE)", name="hevc_v_loop_filter_luma_orcc")
    procedure filterProcessLumaEdgeVertical(uint(size=16) pix[3][PICT_HEIGHT][PICT_WIDTH], int offset, int stride, int betaTab[2], int tcTab[2], uint(size=8) no_p[2], uint(size=8) no_q[2], uint(size=16) blkAddr0[2], int idxBlk)
	var
	  uint(size=16) blkAddr[2]
	begin
	  /* Filtering first edge */
	  if (bSTableVert[idxBlk] != 0) then
		blkAddr[0] := blkAddr0[0];
		blkAddr[1] := blkAddr0[1];
		decisionProcessLumaBlkEdge(blkAddr, true, betaTab[0]);
		filterProcessLumaBlkVerticalEdge(blkAddr, tcTab[0], no_p[0], no_q[0]);
	  end
	  /* Filtering second edge */
	  if (bSTableVert[idxBlk + 2] != 0) then
	    blkAddr[0] := blkAddr0[0];
		blkAddr[1] := blkAddr0[1] + 4;
		decisionProcessLumaBlkEdge(blkAddr, true, betaTab[1]);
		filterProcessLumaBlkVerticalEdge(blkAddr, tcTab[1], no_p[1], no_q[1]);
	  end
	end
	
	procedure filterProcessLumaBlkHorizontal(int idxBlk)
	var
		uint(size=16) blkAddr[2],
		uint(size=16) blkAddr0[2],
		int betaTab[2], 
		int tcTab[2],
		int offset,
		uint(size=8) no_p[2] := [0 : for int i in 0 .. 1],
		uint(size=8) no_q[2] := [0 : for int i in 0 .. 1],
		uint(size=2) bS0 = bSTableHoriz[xAddrHor >> log2LcuSizeMax][yAddrHor >> log2LcuSizeMax][idxBlk],
		uint(size=2) bS1 = bSTableHoriz[xAddrHor >> log2LcuSizeMax][yAddrHor >> log2LcuSizeMax][idxBlk + 1]
	begin
	
	    if (bS0 != 0 or bS1 != 0) then
	    
			zScanToAbsCoord(idxBlk, blkAddr);
			blkAddr0[0] := blkAddr[0] + xAddrHor;
			blkAddr0[1] := blkAddr[1] + yAddrHor;
			
			/* Tc and Beta calculation */
			   
			/* First edge */
			if (bS0 != 0) then
			    blkAddr[0] := blkAddr0[0];
			    blkAddr[1] := blkAddr0[1];
			    decisionProcessLumaBlkEdgeBetaTc(blkAddr, false, bS0);
			    betaTab[0] := beta;
			    tcTab[0] := tc;
			else
			    tcTab[0] := 0;
			end
			
			/* Second edge */
			if (bS1 != 0) then
			    blkAddr[0] := blkAddr0[0] + 4;
			    blkAddr[1] := blkAddr0[1];
			    decisionProcessLumaBlkEdgeBetaTc(blkAddr, false, bS1);
			    betaTab[1] := beta;
			    tcTab[1] := tc;
			else
			    tcTab[1] := 0;
			end
			
			/* Filtering 2 edges */
			if (tcTab[0] != 0 || tcTab[1] != 0) then
				
				/* Compute only beta */
				
				if (bS0 = 0) then
			      blkAddr[0] := blkAddr0[0];
			      blkAddr[1] := blkAddr0[1];
			      decisionProcessLumaBlkEdgeBeta(blkAddr, false);
			      betaTab[0] := beta;
			    end
			  
			    if (bS1 = 0) then
			      blkAddr[0] := blkAddr0[0] + 4;
			      blkAddr[1] := blkAddr0[1];
			      decisionProcessLumaBlkEdgeBeta(blkAddr, false);
			      betaTab[1] := beta;
			    end
			  
			    offset := 0 * (PICT_WIDTH * PICT_HEIGHT) + blkAddr0[1] * PICT_WIDTH + blkAddr0[0];
			    no_p[0] := getLFByPass(blkAddr0[0], blkAddr0[1] - 1);
			    no_p[1] := getLFByPass(blkAddr0[0] + 4, blkAddr0[1] - 1);
			    no_q[0] := getLFByPass(blkAddr0[0], blkAddr0[1]);
			    no_q[1] := getLFByPass(blkAddr0[0] + 4, blkAddr0[1]);
			    filterProcessLumaEdgeHorizontal(pictureBuffer, offset, PICT_WIDTH, betaTab, tcTab, no_p, no_q, blkAddr0, idxBlk);
			end
	    end
	end
	
	@optimize_c(condition="defined(OPENHEVC_ENABLE)", name="hevc_h_loop_filter_luma_orcc")
   procedure filterProcessLumaEdgeHorizontal(uint(size=16) pix[3][PICT_HEIGHT][PICT_WIDTH], int offset, int stride, int betaTab[2], int tcTab[2], uint(size=8) no_p[2], uint(size=8) no_q[2], uint(size=16) blkAddr0[2], int idxBlk)
	var
	  uint(size=16) blkAddr[2]
	begin
	  /* Filtering first edge */
	  if (bSTableHoriz[xAddrHor >> log2LcuSizeMax][yAddrHor >> log2LcuSizeMax][idxBlk] != 0) then
		blkAddr[0] := blkAddr0[0];
		blkAddr[1] := blkAddr0[1];
		decisionProcessLumaBlkEdge(blkAddr, false, betaTab[0]);
		filterProcessLumaBlkHorizontalEdge(blkAddr, tcTab[0], no_p[0], no_q[0]);
	  end

	  /* Filtering second edge */
	  if (bSTableHoriz[xAddrHor >> log2LcuSizeMax][yAddrHor >> log2LcuSizeMax][idxBlk + 1] != 0) then
	    blkAddr[0] := blkAddr0[0] + 4;
		blkAddr[1] := blkAddr0[1];
		decisionProcessLumaBlkEdge(blkAddr, false, betaTab[1]);
		filterProcessLumaBlkHorizontalEdge(blkAddr, tcTab[1], no_p[1], no_q[1]);
	  end
	end

	procedure filterProcessLumaSamp(uint(size=16) p[4], uint(size=16) q[4], uint(size=8) tcLocal, uint(size=8) no_p, uint(size=8) no_q)
	var
		uint(size=16) p0=p[0], uint(size=16) p1=p[1], uint(size=16) p2=p[2],
		uint(size=16) q0=q[0], uint(size=16) q1=q[1], uint(size=16) q2=q[2],
		uint(size=16) p3=p[3], uint(size=16) q3=q[3],
		int delta, int deltaP, int deltaQ
	begin
		if(dE=2) then
			if(no_p = 0) then
				p[0] := clip_i32((p2+2*p1+2*p0+2*q0+q1+4)>>3, p0-2*tcLocal, p0+2*tcLocal);
				p[1] := clip_i32((p2+p1+p0+q0+2)>>2, p1-2*tcLocal, p1+2*tcLocal);
				p[2] := clip_i32((2*p3+3*p2+p1+p0+q0+4)>>3, p2-2*tcLocal, p2+2*tcLocal);
			end
			if(no_q = 0) then
				q[0] := clip_i32((p1+2*p0+2*q0+2*q1+q2+4)>>3, q0-2*tcLocal, q0+2*tcLocal);
				q[1] := clip_i32((p0+q0+q1+q2+2)>>2, q1-2*tcLocal, q1+2*tcLocal);
				q[2] := clip_i32((p0+q0+q1+3*q2+2*q3+4)>>3, q2-2*tcLocal, q2+2*tcLocal);
			end	
		else
			delta := (9*(q0-p0)-3*(q1-p1)+8)>>4;
			if(abs(delta)<10*tcLocal) then
				delta := clip_i32(delta, -tcLocal, tcLocal);
				if(no_p = 0) then
					p[0] := clip_i32(p0+delta, 0, maxPixValY);
				end
				if(no_q = 0) then	
					q[0] := clip_i32(q0-delta, 0, maxPixValY);
				end	
				if(no_p = 0 && dEp) then
					deltaP := clip_i32( ((((p2+p0+1)>>1)-p1+delta)>>1), -(tcLocal>>1), tcLocal>>1);
					p[1] := clip_i32(p1+deltaP, 0, maxPixValY);
				end
				if(no_q = 0 && dEq) then
					deltaQ := clip_i32(((((q2+q0+1)>>1)-q1-delta)>>1), -(tcLocal>>1), tcLocal>>1);
					q[1] := clip_i32(q1+deltaQ, 0, maxPixValY);
				end
			end
		end
	end

    procedure decisionProcessChromaBlkEdgeTc(uint(size=16) addr[2], bool isVertical, int cIdx)
	var
		uint(size=16) q0X = (addr[0]/4) & (PICT_WIDTH/4-1),
		uint(size=16) q0Y = addr[1]/4,
		uint(size=16) p0X, uint(size=16) p0Y,
		uint(size=2) bS = 2,
		int qPC, int Q,
		uint(size=16) idx
	begin
	      if(isVertical) then
			  p0X := q0X-1;
			  p0Y := q0Y;
			  idx := addr[0];
	   	  else
			  p0X := q0X;
			  p0Y := q0Y-1;
			  idx := addr[1];
		  end
		  qPi := ((qpTab[q0X][q0Y] + qpTab[p0X][p0Y] + 1)>>1);
		  qPC := qPcTable[min(qPi + qpChrOff[cIdx-1],51)];
		  Q  := clip_i32(qPC + 2*(bS-1) + tcOffset, 0, 53);
		  if (((idx >> 2) & 3) != 0) then 
		    tc := 0;
		  else
		    tc := tcTable[Q]<<(bitDepthC - 8);
		  end
	end
	
	procedure filtProcessChrBlkHorizontalEdge(uint(size=16) addr[2], int cIdx, uint(size=8) tcLocal, uint(size=8) no_p, uint(size=8) no_q)
	var
		uint(size=16) addrX = addr[0]>>1,
		uint(size=16) addrY = addr[1]>>1,
		uint(size=16) p[2], uint(size=16) q[2]
	begin
		foreach int x in 0 .. 3
		do
			p := [pictureBuffer[cIdx][addrY-i][addrX+x]: for int i in 1 .. 2];
			q := [pictureBuffer[cIdx][addrY+i][addrX+x]: for int i in 0 .. 1];
			filterProcessChrSamp(p, q, tcLocal, no_p, no_q);
			pictureBuffer[cIdx][addrY-1][addrX+x] := p[0];
			pictureBuffer[cIdx][addrY][addrX+x] := q[0];
		end
	end
	
	procedure filtProcessChrBlkVerticalEdge(uint(size=16) addr[2], int cIdx, uint(size=8) tcLocal, uint(size=8) no_p, uint(size=8) no_q)
	var
		uint(size=16) addrX = addr[0]>>1,
		uint(size=16) addrY = addr[1]>>1,
		uint(size=16) p[2], uint(size=16) q[2]
	begin
		foreach int y in 0 .. 3
		do
		    p := [pictureBuffer[cIdx][addrY+y][addrX-i]: for int i in 1 .. 2];
			q := [pictureBuffer[cIdx][addrY+y][addrX+i]: for int i in 0 .. 1];
			filterProcessChrSamp(p, q, tcLocal, no_p, no_q);
			pictureBuffer[cIdx][addrY+y][addrX-1] := p[0];
			pictureBuffer[cIdx][addrY+y][addrX] := q[0];
	    end
	end

	procedure filterProcessChrSamp(uint(size=16) p[2], uint(size=16) q[2], uint(size=8) tc, uint(size=8) no_p, uint(size=8) no_q)
	var
		int delta,
		uint(size=16) p0=p[0], uint(size=16) p1=p[1],
		uint(size=16) q0=q[0], uint(size=16) q1=q[1]
	begin
		delta := clip_i32(((((q0-p0)<<2)+p1-q1+4)>>3), -tc, tc);
		if(no_p = 0) then
			p[0] := clip_i32(p0+delta, 0, maxPixValC);
		end	
		if(no_q = 0) then
			q[0] := clip_i32(q0-delta, 0, maxPixValC);
		end	
	end

    procedure filterProcessChromaBlkVertical(int idxBlk)
	var
		uint(size=16) blkAddr[2],
		uint(size=16) blkAddr0[2], 
		int tcTab[2],
		int offset,
		uint(size=8) no_p[2] := [0 : for int i in 0 .. 1],
		uint(size=8) no_q[2] := [0 : for int i in 0 .. 1],
		uint(size=2) bS0 = bSTableVert[idxBlk],
		uint(size=2) bS1 = bSTableVert[idxBlk + 8]
	begin
	    foreach int cIdx in 1 .. 2
	    do
			if (bS0 = 2 or bS1 = 2) then
		        zScanToAbsCoord(idxBlk, blkAddr);
			    blkAddr[0] := blkAddr[0] + xAddrVert;
			    blkAddr[1] := blkAddr[1] + yAddrVert;
			    blkAddr0[0] := blkAddr[0];
			    blkAddr0[1] := blkAddr[1];
		      
		        /* Tc calculation */
		    
		        /* First edge */
		        if (bS0 = 2) then
			       decisionProcessChromaBlkEdgeTc(blkAddr, true, cIdx);
			       tcTab[0] := tc;
			    else
			       tcTab[0] := 0;
		        end
	  
		        /* Second edge */
		        if (bS1 = 2) then
			       blkAddr[0] := blkAddr0[0];
			       blkAddr[1] := blkAddr0[1] + 8;
			       decisionProcessChromaBlkEdgeTc(blkAddr, true, cIdx);
			       tcTab[1] := tc;
			    else
			       tcTab[1] := 0;
		        end
		
		        /* Filtering 2 edges */
		        if (tcTab[0] != 0 || tcTab[1] != 0) then
		        	offset := cIdx * (PICT_WIDTH * PICT_HEIGHT) + (blkAddr0[1] >> 1) * PICT_WIDTH + (blkAddr0[0] >> 1);
					no_p[0] := getLFByPass(blkAddr0[0] - 1, blkAddr0[1]);
					no_p[1] := getLFByPass(blkAddr0[0] - 1, blkAddr0[1] + 8);
					no_q[0] := getLFByPass(blkAddr0[0], blkAddr0[1]);
					no_q[1] := getLFByPass(blkAddr0[0], blkAddr0[1] + 8);
					filterProcessChromaEdgeVertical(pictureBuffer, offset, PICT_WIDTH, tcTab, no_p, no_q, blkAddr0, cIdx);
		        end
	    	end
	    end
	end
	
	@optimize_c(condition="defined(OPENHEVC_ENABLE)", name="hevc_v_loop_filter_chroma_orcc")
    procedure filterProcessChromaEdgeVertical(uint(size=16) pix[3][PICT_HEIGHT][PICT_WIDTH], int offset, int stride, int tcTab[2], uint(size=8) no_p[2], uint(size=8) no_q[2], uint(size=16) blkAddr0[2], int cIdx)
	var
	  uint(size=16) blkAddr[2]
	begin
	  /* Filtering first edge */
	  if(tcTab[0] != 0) then
		blkAddr[0] := blkAddr0[0];
		blkAddr[1] := blkAddr0[1];
		filtProcessChrBlkVerticalEdge(blkAddr, cIdx, tcTab[0], no_p[0], no_q[0]);
	  end

	  /* Filtering second edge */
	  if(tcTab[1] != 0) then
	    blkAddr[0] := blkAddr0[0];
		blkAddr[1] := blkAddr0[1] + 8;
		filtProcessChrBlkVerticalEdge(blkAddr, cIdx, tcTab[1], no_p[1], no_q[1]);
	  end
	end
	
	procedure filterProcessChromaBlkHorizontal(int idxBlk)
	var
		uint(size=16) blkAddr[2],
		uint(size=16) blkAddr0[2],
		int tcTab[2],
		int offset,
		uint(size=8) no_p[2] := [0 : for int i in 0 .. 1],
		uint(size=8) no_q[2] := [0 : for int i in 0 .. 1],
		uint(size=2) bS0 := bSTableHoriz[xAddrHor >> log2LcuSizeMax][yAddrHor >> log2LcuSizeMax][idxBlk],
		uint(size=2) bS1 := bSTableHoriz[xAddrHor >> log2LcuSizeMax][yAddrHor >> log2LcuSizeMax][idxBlk + 4]
	begin
	
	    foreach int cIdx in 1 .. 2
	    do
	    	if (bS0 = 2 or bS1 = 2) then
			  
			    zScanToAbsCoord(idxBlk, blkAddr);
			    blkAddr[0] := blkAddr[0] + xAddrHor;
	            blkAddr[1] := blkAddr[1] + yAddrHor;
	            blkAddr0[0] := blkAddr[0];
			    blkAddr0[1] := blkAddr[1];
		
				/* Tc calculation */
   
				/* First edge */
				if (bS0 = 2) then
					decisionProcessChromaBlkEdgeTc(blkAddr, false, cIdx);
				    tcTab[0] := tc;
				else
				    tcTab[0] := 0;
				end

				/* Second edge */
				if (bS1 = 2) then	
				    blkAddr[0] := blkAddr0[0] + 8;
				    blkAddr[1] := blkAddr0[1];
				    decisionProcessChromaBlkEdgeTc(blkAddr, false, cIdx);
				    tcTab[1] := tc;
				else
				    tcTab[1] := 0;
				end
		
				/* Filtering 2 edges */
				if (tcTab[0] != 0 || tcTab[1] != 0) then
				    offset := cIdx * (PICT_WIDTH * PICT_HEIGHT) + (blkAddr0[1] >> 1) * PICT_WIDTH + (blkAddr0[0] >> 1);
					no_p[0] := getLFByPass(blkAddr0[0], blkAddr0[1] - 1);
					no_p[1] := getLFByPass(blkAddr0[0] + 8, blkAddr0[1] - 1);
					no_q[0] := getLFByPass(blkAddr0[0], blkAddr0[1]);
					no_q[1] := getLFByPass(blkAddr0[0] + 8, blkAddr0[1]);
		    		filterProcessChromaEdgeHorizontal(pictureBuffer, offset, PICT_WIDTH, tcTab, no_p, no_q, blkAddr0, cIdx);
				end
	    	end
	    end
	end
	
	@optimize_c(condition="defined(OPENHEVC_ENABLE)", name="hevc_h_loop_filter_chroma_orcc")
    procedure filterProcessChromaEdgeHorizontal(uint(size=16) pix[3][PICT_HEIGHT][PICT_WIDTH], int offset, int stride, int tcTab[2], uint(size=8) no_p[2], uint(size=8) no_q[2], uint(size=16) blkAddr0[2], int cIdx)
	var
	  uint(size=16) blkAddr[2]
	begin
	  /* Filtering first edge */
	  if (tcTab[0] != 0) then
		blkAddr[0] := blkAddr0[0];
		blkAddr[1] := blkAddr0[1];
		filtProcessChrBlkHorizontalEdge(blkAddr, cIdx, tcTab[0], no_p[0], no_q[0]);
	  end

	  /* Filtering second edge */
	  if (tcTab[1] != 0) then
	    blkAddr[0] := blkAddr0[0] + 8;
		blkAddr[1] := blkAddr0[1];
		filtProcessChrBlkHorizontalEdge(blkAddr, cIdx, tcTab[1], no_p[1], no_q[1]);
	  end
	end

	procedure filterVerEdges()
    var
		int lumaPartMax = (numPartition >> 2) - 1,
		int chromaPartMax = (numPartition >> 4) - 1		
	begin
		foreach int idxBlk in 0 .. lumaPartMax
		do
		    filterProcessLumaBlkVertical(idxBlk << 2);
        end

        foreach int idxBlk in 0 .. chromaPartMax
	    do
		  filterProcessChromaBlkVertical(idxBlk << 4);
	    end	
	end
	
	procedure filterHorEdges()
    var
    	int lumaPartMax = (numPartition >> 2) - 1,
	  	int chromaPartMax = (numPartition >> 4) - 1
	begin
		foreach int idxBlk in 0 .. lumaPartMax
		do
			filterProcessLumaBlkHorizontal(idxBlk << 2);
	    end
		
        foreach int idxBlk in 0 .. chromaPartMax
		do
			filterProcessChromaBlkHorizontal(idxBlk << 4);
		end
	end

	procedure saveRasterScanCu(uint(size=16) sample[4*4 + 2*2*2])
	var
		uint(size=16) pixAddr[2],
		uint tokenOffset
	begin
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
		foreach int y in 0 .. 3
		do
			foreach int x in 0 .. 3
			do
				pictureBuffer[0][pixAddr[1]+y][pixAddr[0]+x] := sample[4*y+x];
			end
		end
		tokenOffset := 16;
		pixAddr[0]  := pixAddr[0]>>1;
		pixAddr[1]  := pixAddr[1]>>1;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pictureBuffer[comp][pixAddr[1]+y][pixAddr[0]+x] := sample[tokenOffset + 2*y+x];
				end
			end
			tokenOffset := tokenOffset + 4;
		end
	end
	
	uint(size=8) isLFBypass[PICT_WIDTH/4*PICT_HEIGHT/4];
	procedure resetLFByPass()
	begin
		foreach int j in 0 .. (minPUSize[1]-1) do
			foreach int i in 0 .. (minPUSize[0]-1) do			
				isLFBypass[j*minPUSize[0]+i] := 0;
			end
		end
	end

	procedure setLFByPass(uint(size=16) val, uint(size=16) x, uint(size=16) y, uint(size=16) cb_size)
	var
		uint x_end = min(x+cb_size, picSize[0]),
		uint y_end = min(y+cb_size, picSize[1])
	begin
		foreach int j in (y>>log2puSizeMin) .. ((y_end>>log2puSizeMin)-1) do
			foreach int i in (x>>log2puSizeMin) .. ((x_end>>log2puSizeMin)-1) do
				isLFBypass[j*minPUSize[0]+i] := val;
			end
		end
	end

	function getLFByPass(uint(size=16) x, uint(size=16) y) --> uint(size=8)
	:
		isLFBypass[(y>>log2puSizeMin)*minPUSize[0] + (x>>log2puSizeMin)]
	end


	isNewSlc: action IsPicSlcLcu:[isNewPicSlcLcu], LcuSize:[log2LcuSzMax, log2lcuSzMin], 
					 DBFDisable:[disableFlag], SyntaxElem:[betaOff, tcOff, qpUOff, qpVOff], BitDepth:[bitDepthLuma, bitDepthChr] ==>
	guard
		isNewPicSlcLcu = NEW_SLC
	do
		bitDepthY := bitDepthLuma;
		bitDepthC := bitDepthChr;
		maxPixValY := (1 << bitDepthY) - 1;
		maxPixValC := (1 << bitDepthC) - 1;

		disDbf := disableFlag;
		betaOffset := betaOff;
		tcOffset := tcOff;
		qpChrOff := [qpUOff, qpVOff];		
	end
	
	getLFBypassCUInfo: action LFBypassCUInfo:[val, x, y, cb_size_w, cb_size_h] ==>
	do
		setLFByPass(val, x, y, max(cb_size_w, cb_size_h));
	end

	isNewPict: action IsPicSlcLcu:[isNewPicSlcLcu], PicSize:[picWidthInPix, picHeightInPix], LcuSize:[log2LcuSzMax, log2lcuSzMin], 
					  DBFDisable:[disableFlag], SyntaxElem:[betaOff, tcOff, qpUOff, qpVOff], BitDepth:[bitDepthLuma, bitDepthChr] ==>
	guard
		isNewPicSlcLcu = NEW_PIC
	do		
		bitDepthY := bitDepthLuma;
		bitDepthC := bitDepthChr;
		maxPixValY := (1 << bitDepthY) - 1;
		maxPixValC := (1 << bitDepthC) - 1;
		
		log2LcuSizeMax := log2LcuSzMax;
		lcuSizeMax := 1 << log2LcuSizeMax;
		log2puSizeMin := log2lcuSzMin - 1;
		minPUSize[0] := picWidthInPix >> log2puSizeMin;
		minPUSize[1] := picHeightInPix >> log2puSizeMin;
		resetLFByPass();
		
		numPartition := (lcuSizeMax * lcuSizeMax) / 16;
		numTokenPerLcu[0] := lcuSizeMax * lcuSizeMax;
		numTokenPerLcu[1] := numTokenPerLcu[0] >> 2;
		
		disDbf := disableFlag;
		picSize[0] := picWidthInPix;
		picSize[1] := picHeightInPix;
		/*lastXIdx := 0;
		lastYIdx := 0;*/
		xIdx := 0;
		yIdx := 0;
		xAddrHor := -1;
		tileIdx := 0;
		betaOffset := betaOff;
		tcOffset := tcOff;
		qpChrOff := [qpUOff, qpVOff];
	end

	getNumTiles: action TilesCoord:[valNumTiles] ==>
	do
		numTiles := valNumTiles;
		iLoop := 0;
	end

	getTilesCoord.launch: action TilesCoord:[tilesCoord] repeat 4 ==>
	guard
		iLoop < numTiles
	do
		tilesBegSamp[iLoop] := [tilesCoord[0], tilesCoord[1]];
		tilesEndSamp[iLoop] := [tilesCoord[2], tilesCoord[3]];
		iLoop := iLoop + 1;
	end

	getTilesCoord.done: action ==>
	guard
		iLoop = numTiles
	end

	getCuPix.launch.pict: action  IsPicSlcLcu:[isLcu] ==>
	guard
		tileIdx < numTiles && yIdx < picSize[1]-lcuSizeMax && xIdx < picSize[0]-lcuSizeMax && isLcu = NEW_LCU
	do
		xAddrVert := xIdx;
		yAddrVert := yIdx;
		blkIdx := 0;
	end

	getCuPix.launch.getPart.isHorVer: action BsVer:[bsVer], BsHor:[bsHor], Qp:[qp], SampleIn:[samp] repeat 4*4 + 2* 2*2 ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 0
	var
		uint(size=16) coord[2] 	
	do
		if(FILT_VERT_EDGES) then
			saveRasterScanCu(samp);
		else
//			saveZScanCu(samp);
		end

		zScanToAbsCoord(blkIdx, coord);
		coord[0] := xIdx + coord[0];
		coord[1] := yIdx + coord[1];
		
		qpTab[coord[0]>>2][coord[1]>>2] := qp;
		bSTableVert[blkIdx] := bsVer;
		bSTableHoriz[xIdx>> log2LcuSizeMax][yIdx>> log2LcuSizeMax][blkIdx] := bsHor;

		blkIdx := blkIdx + 1;
	end

    getCuPix.launch.getPart.isHor: action BsHor:[bsHor], Qp:[qp], SampleIn:[samp] repeat 4*4 + 2* 2*2 ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 1
	var
		uint(size=16) coord[2] 	
	do
		if(FILT_VERT_EDGES) then
			saveRasterScanCu(samp);
		else
//			saveZScanCu(samp);
		end

		zScanToAbsCoord(blkIdx, coord);
		coord[0] := xIdx + coord[0];
		coord[1] := yIdx + coord[1];
		qpTab[coord[0]>>2][coord[1]>>2] := qp;

		bSTableHoriz[xIdx>> log2LcuSizeMax][yIdx>> log2LcuSizeMax][blkIdx] := bsHor;

		blkIdx := blkIdx + 1;
	end
	
	getCuPix.launch.getPart.isVer: action BsVer:[bsVer], Qp:[qp], SampleIn:[samp] repeat 4*4 + 2* 2*2 ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 2
	var
		uint(size=16) coord[2] 	
	do
		if(FILT_VERT_EDGES) then
			saveRasterScanCu(samp);
		else
//			saveZScanCu(samp);
		end

		zScanToAbsCoord(blkIdx, coord);
		coord[0] := xIdx + coord[0];
		coord[1] := yIdx + coord[1];
		qpTab[coord[0]>>2][coord[1]>>2] := qp;

		bSTableVert[blkIdx] := bsVer;

		blkIdx := blkIdx + 1;
	end
	
	getCuPix.launch.getPart.qp: action Qp:[qp], SampleIn:[samp] repeat 4*4 + 2* 2*2 ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 3
	var
		uint(size=16) coord[2] 	
	do
		if(FILT_VERT_EDGES) then
			saveRasterScanCu(samp);
		else
//			saveZScanCu(samp);
		end

		zScanToAbsCoord(blkIdx, coord);
		coord[0] := xIdx + coord[0];
		coord[1] := yIdx + coord[1];
		qpTab[coord[0]>>2][coord[1]>>2] := qp;

		blkIdx := blkIdx + 1;
	end

	getCuPix.launch.getPartDone: action ==>
	guard
		blkIdx = numPartition
	do
		/*lastXIdx := xIdx;
		lastYIdx := yIdx;*/
		computeNextLcuAddr();
	end

	getCuPix.launch.lastColOrRow.vert: action IsPicSlcLcu:[isLcu] ==>
	guard
		(xIdx >= picSize[0]-lcuSizeMax || yIdx >= picSize[1]-lcuSizeMax) && FILT_VERT_EDGES && isLcu = NEW_LCU
	do
		xAddrVert := xIdx;
		yAddrVert := yIdx;

		blkIdx := 0;
		zScanToAbsCoord(0, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	/*getCuPix.launch.lastColOrRow.hor: action IsPicSlcLcu:[isLcu], SampleIn:[samp] repeat 64*64 + 32*32*2 ==>
	guard
		(xIdx >= picSize[0]-1 || yIdx >= picSize[1]-1) && not FILT_VERT_EDGES && isLcu = NEW_LCU
	do
		xAddrVert := xIdx;
		yAddrVert := yIdx;
		saveZScanCu(samp);
		blkIdx := 0;
	end*/

	getBlk.launch.isHorVer: action  BsHor:[bsHor], BsVer:[bsVer], Qp:[qp], SampleIn:[samp] repeat 4*4 + 2*2*2 ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 0 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		foreach int y in 0 .. 3
		do
			foreach int x in 0 .. 3
			do
				pictureBuffer[0][pixAddr[1]+y][pixAddr[0]+x] := samp[4*y+x];
			end
		end
		
		qpTab[(pixAddr[0] & PICT_WIDTH-1) >>2][pixAddr[1]/4] := qp;
		bSTableVert[blkIdx] := bsVer;
		bSTableHoriz[xAddrVert>> log2LcuSizeMax][yAddrVert>> log2LcuSizeMax][blkIdx] := bsHor;
		
		pixAddr[0]  := pixAddr[0]>>1;
		pixAddr[1]  := pixAddr[1]>>1;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pictureBuffer[comp][pixAddr[1]+y][pixAddr[0]+x] := samp[2*y+x + 16+4*(comp-1)];
				end
			end
		end

		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

    getBlk.launch.isHor: action  BsHor:[bsHor], Qp:[qp], SampleIn:[samp] repeat 4*4 + 2*2*2 ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 1 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		foreach int y in 0 .. 3
		do
			foreach int x in 0 .. 3
			do
				pictureBuffer[0][pixAddr[1]+y][pixAddr[0]+x] := samp[4*y+x];
			end
		end
		
		qpTab[pixAddr[0]/4][(pixAddr[1] & PICT_WIDTH-1) >>2] := qp;
		bSTableHoriz[xAddrVert>> log2LcuSizeMax][yAddrVert>> log2LcuSizeMax][blkIdx] := bsHor;
				
		pixAddr[0]  := pixAddr[0]>>1;
		pixAddr[1]  := pixAddr[1]>>1;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pictureBuffer[comp][pixAddr[1]+y][pixAddr[0]+x] := samp[2*y+x + 16+4*(comp-1)];
				end
			end
		end

		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end
	
	getBlk.launch.isVer: action  BsVer:[bsVer], Qp:[qp], SampleIn:[samp] repeat 4*4 + 2*2*2 ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 2 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
	    foreach int y in 0 .. 3
		do
		  foreach int x in 0 .. 3
		  do
			 pictureBuffer[0][pixAddr[1]+y][pixAddr[0]+x] := samp[4*y+x];
		  end
        end
		
		qpTab[pixAddr[0]/4][(pixAddr[1] & PICT_WIDTH-1) >>2] := qp;
		bSTableVert[blkIdx] := bsVer;
		
		pixAddr[0]  := pixAddr[0]>>1;
		pixAddr[1]  := pixAddr[1]>>1;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pictureBuffer[comp][pixAddr[1]+y][pixAddr[0]+x] := samp[2*y+x + 16+4*(comp-1)];
				end
			end
		end

		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end
	
	getBlk.launch.qp: action  Qp:[qp], SampleIn:[samp] repeat 4*4 + 2*2*2 ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 3 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		foreach int y in 0 .. 3
		do
			foreach int x in 0 .. 3
			do
				pictureBuffer[0][pixAddr[1]+y][pixAddr[0]+x] := samp[4*y+x];
			end
		end
		
		qpTab[pixAddr[0]/4][(pixAddr[1] & PICT_WIDTH-1) >>2] := qp;
		
		pixAddr[0]  := pixAddr[0]>>1;
		pixAddr[1]  := pixAddr[1]>>1;
		foreach uint comp in 1 .. 2
		do
			foreach uint y in 0 .. 1
			do
				foreach uint x in 0 .. 1
				do
					pictureBuffer[comp][pixAddr[1]+y][pixAddr[0]+x] := samp[2*y+x + 16+4*(comp-1)];
				end
			end
		end

		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
    end

	getBlk.skip.vertEdge: action ==>
	guard
		blkIdx < numPartition  && FILT_VERT_EDGES,
		pixAddr[0] >= picSize[0] || pixAddr[1] >= picSize[1]
	do
		bSTableVert[blkIdx] := 0;
		bSTableHoriz[xAddrVert>> log2LcuSizeMax][yAddrVert>> log2LcuSizeMax][blkIdx] := 0;
		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBlk.skip.horEdge: action SampleIn:[samp] repeat 4*4 + 2*2*2 ==>
	guard
		blkIdx < numPartition  && not FILT_VERT_EDGES,
		pixAddr[0] >= picSize[0] || pixAddr[1] >= picSize[1]
	do
		bSTableVert[blkIdx] := 0;
		bSTableHoriz[xAddrVert>> log2LcuSizeMax][yAddrVert>> log2LcuSizeMax][blkIdx] := 0;
		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBlk.done: action ==>
	guard
		blkIdx = numPartition
	do
		/*lastXIdx := xIdx;
		lastYIdx := yIdx;*/
		computeNextLcuAddr();
	end
/*
	getBs4Blk.launch.isHorVer: action  BsHor:[bsHor], BsVer:[bsVer], Qp:[qp] ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 0 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		qpTab[(pixAddr[0] & PICT_WIDTH-1) >>2][pixAddr[1]/4] := qp;
		bSTableVert[blkIdx] := bsVer;
		bSTableHoriz[xAddrVert>> log2LcuSizeMax][yAddrVert>> log2LcuSizeMax][blkIdx] := bsHor;

		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end
	
	getBs4Blk.launch.isHor: action  BsHor:[bsHor], Qp:[qp] ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) < 2 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		qpTab[(pixAddr[0] & PICT_WIDTH-1) >>2][pixAddr[1]/4] := qp;
		bSTableHoriz[xAddrVert>> log2LcuSizeMax][yAddrVert>> log2LcuSizeMax][blkIdx] := bsHor;

		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end
	
	getBs4Blk.launch.isVer: action  BsVer:[bsVer], Qp:[qp] ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x01) = 0 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		qpTab[(pixAddr[0] & PICT_WIDTH-1) >>2][pixAddr[1]/4] := qp;
		bSTableVert[blkIdx] := bsVer;

		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end
	
	getBs4Blk.launch.qp: action  Qp:[qp] ==>
	guard
		blkIdx < numPartition && (blkIdx & 0x03) = 3 && pixAddr[0] < picSize[0] && pixAddr[1] < picSize[1]
	do
		qpTab[(pixAddr[0] & PICT_WIDTH-1) >>2][pixAddr[1]/4] := qp;

		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBs4Blk.skip: action ==>
	guard
		blkIdx < numPartition,
		pixAddr[0] >= picSize[0] || pixAddr[1] >= picSize[1]
	do
		bSTableVert[blkIdx] := 0;
		bSTableHoriz[xAddrVert>> log2LcuSizeMax][yAddrVert>> log2LcuSizeMax][blkIdx] := 0;
		blkIdx := blkIdx + 1;
		zScanToAbsCoord(blkIdx, pixAddr);
		pixAddr[0] := pixAddr[0] + xAddrVert;
		pixAddr[1] := pixAddr[1] + yAddrVert;
	end

	getBs4Blk.done: action ==>
	guard
		blkIdx = numPartition
	do
		//lastXIdx := xIdx;
		//lastYIdx := yIdx;
		computeNextLcuAddr();
	end
*/
	getCuPix.done: action ==>
	guard
		tileIdx = numTiles
	do
		/*lastXIdx := 0;
		lastYIdx := 0;*/
		tokenSent := 0;
		xIdx := 0;
		yIdx := 0;
		tileIdx := 0;
	end

	filterEdges: action ==>
	do
		if(not disDbf) then
			if(FILT_VERT_EDGES) then
				filterVerEdges();
			end
			if(FILT_HOR_EDGES) then
				if(xAddrVert > 0) then
					xAddrHor := xAddrVert - lcuSizeMax;
					yAddrHor := yAddrVert;
					filterHorEdges();
				end
				if(xAddrVert + lcuSizeMax >= picSize[0]) then
					xAddrHor := xAddrVert;
					filterHorEdges();
				end
			end
		end
		xAddrHor := xAddrVert;
		yAddrHor := yAddrVert;
	end

	/*filteringOnlyVertEdge.isTrue: action ==>
	guard
		FILT_VERT_EDGES and not FILT_HOR_EDGES
	end*/

	filteringOnlyVertEdge.isFalse: action ==>
	guard
		FILT_HOR_EDGES
	end

	sendSamples.launch.luma: action ==> FiltSample:[filtSamp] repeat 16
	guard
		tileIdx < numTiles && tokenSent < numTokenPerLcu[0]//,
//		FILT_HOR_EDGES || xIdx != lastXIdx || yIdx != lastYIdx
	var
		uint(size=16) filtSamp[16],
		uint(size=16) xOff, uint(size=16) yOff
	do
		xOff := tokenSent & (lcuSizeMax - 1);
		yOff := tokenSent >> log2LcuSizeMax;
		foreach uint x in 0 .. 15
		do
			if(not DEBUG) then
				filtSamp[x] := pictureBuffer[0][yIdx + yOff][xIdx + xOff + x];
			else
				if(xIdx + xOff + x<picSize[0] && yIdx + yOff < picSize[1]) then
					filtSamp[x] := pictureBuffer[0][yIdx + yOff][xIdx + xOff + x];
				else
					filtSamp[x] := 0;
				end
			end
		end

		tokenSent := tokenSent + 16;
	end

	sendSamples.launch.lumaDone: action ==>
	guard
		tokenSent = numTokenPerLcu[0]
	do
		tokenSent := 0;
		compIdx := 1;
	end

	sendSamples.launch.chroma: action ==> FiltSample:[filtSamp] repeat 8
	guard
		compIdx < 3
	var
		uint(size=16) filtSamp[8],
		uint(size=16) xOff, uint(size=16) yOff
	do
		xOff := tokenSent & ((lcuSizeMax - 1) >> 1);
		yOff := tokenSent >> (log2LcuSizeMax - 1 );
		foreach uint x in 0 .. 7
		do
			if(not DEBUG) then
				filtSamp[x] := pictureBuffer[compIdx][yIdx/2 + yOff][xIdx/2 + xOff + x];
			else
				if(xIdx/2 + xOff + x < picSize[0]/2 && yIdx/2 + yOff < picSize[1]/2) then
					filtSamp[x] := pictureBuffer[compIdx][yIdx/2 + yOff][xIdx/2 + xOff + x];
				else
					filtSamp[x] := 0;
				end
			end
		end

		tokenSent := tokenSent + 8;
		if(tokenSent = numTokenPerLcu[1]) then
			tokenSent := 0;
			compIdx := compIdx + 1;
		end
	end

	sendSamples.launch.chromaDone: action ==>
	guard
		compIdx = 3
	do
		tokenSent := 0;
		computeNextLcuAddr();
	end

	/*sendSamples.skip: action ==> 
	guard
		 xIdx = lastXIdx
	end*/

	sendSamples.done: action ==>
	guard
		tileIdx = numTiles
	end

	schedule fsm IsNewPict:
		IsNewPict (isNewPict )--> GetNumTiles;

		GetCuPix  (isNewSlc                          )--> GetNumTiles;
		GetCuPix  (getLFBypassCUInfo				 )--> GetCuPix;
		GetCuPix  (getCuPix.launch.pict              )--> GetPartition;
		GetCuPix  (getCuPix.launch.lastColOrRow.vert )--> GetBlk;
//		GetCuPix  (getCuPix.launch.lastColOrRow.hor  )--> GetBs4Blk;
		GetCuPix  (getCuPix.done                     )--> SendSamples;

		GetPartition (getCuPix.launch.getPart     )--> GetPartition;
		GetPartition (getCuPix.launch.getPartDone )--> FilterEdges;

		GetNumTiles   (getNumTiles          )--> GetTilesCoord;
		GetTilesCoord (getTilesCoord.launch )--> GetTilesCoord;
		GetTilesCoord (getTilesCoord.done   )--> GetCuPix;

		GetBlk (getBlk.launch )--> GetBlk;
		GetBlk (getBlk.skip   )--> GetBlk;
		GetBlk (getBlk.done   )--> FilterEdges;
/*
		GetBs4Blk (getBs4Blk.launch )--> GetBs4Blk;
		GetBs4Blk (getBs4Blk.skip   )--> GetBs4Blk;
		GetBs4Blk (getBs4Blk.done   )--> FilterEdges;
*/
		FilterEdges (filterEdges  )--> CheckEdgeFiltered;

		//CheckEdgeFiltered (filteringOnlyVertEdge.isTrue  )--> SendSamplesVert;
		CheckEdgeFiltered (filteringOnlyVertEdge.isFalse )--> GetCuPix;

		/*SendSamplesVert (sendSamples.launch )--> GetCuPix;
		SendSamplesVert (sendSamples.skip   )--> GetCuPix;*/

		SendSamples (sendSamples.launch.luma )--> SendSamplesLuma;
		SendSamples (sendSamples.done        )--> IsNewPict;

		SendSamplesLuma (sendSamples.launch.luma     )--> SendSamplesLuma;
		SendSamplesLuma (sendSamples.launch.lumaDone )--> SendSamplesChr;

		SendSamplesChr (sendSamples.launch.chroma     )--> SendSamplesChr;
		SendSamplesChr (sendSamples.launch.chromaDone )--> SendSamples;
	end
end