/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (EPFL), 
in the course of development of the ISO/IEC 23002-5 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-5.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-5 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards.

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-5 once the ISO/IEC 23002-5 has been adopted; and 
(2) to develop the ISO/IEC 23002-5: 

EPFL grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-5 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-5 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-5.  To the extent that EPFL
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-5 in a conforming product, EPFL
will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-5

EPFL retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2011-2014.
*****************************************************************************/
package org.sc29.wg11.mpegh.part2.main.Filters;

import std.util.Math.*;
import org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

//There should be much less division.
//There should be a function for the code which test if two pixels are in the same slice thanks to the variable filtAcrSlc.
actor SaoFilter(bool DEBUG)
	uint(size=2)  IsPicSlcLcu,
	uint(size=8)  LcuSizeMax,
	uint(size=2)  LFAcrossSlcTile,
	uint(size=16) PicSize,
	uint(size=8)  SampleIn,
	int (size=9)  SaoSe,
	uint(size=16) TilesCoord,

	uint(size=8) LcuSizeMin,
	uint(size=16) LFBypassCUInfo
		==>
	uint(size=8)  FiltSample
		:
		
	bool DEBUG_Trace = false;
		
	uint(size=4)  BIT_DEPTH = 8;

	int(size=3) constHPos0[4][2] = [[-1,1],  [ 0,0], [-1,1],  [ 1,-1]];
	int(size=3) constVPos0[4][2] = [[ 0,0],  [-1,1], [-1,1],  [-1, 1]];
	int(size=3) edgeIdxConv[5] = [1, 2, 0, 3, 4];
	
	int(size=2) signResult[3][128][128];
 
	bool         slcSaoCompEn[3];

	uint(size=8) PictBuffer[3][PICT_HEIGHT][PICT_WIDTH];
    uint(size=8) origPict[3][PICT_HEIGHT][PICT_WIDTH];
	
	uint(size=2)  cIdx;
	uint(size=2)  saoTypeIdx[PICT_WIDTH/64][PICT_HEIGHT/64][3];
	int (size=9)  saoOffset[PICT_WIDTH/64][PICT_HEIGHT/64][3][5];
	uint(size=2)  saoEoClass[PICT_WIDTH/64][PICT_HEIGHT/64][3];
	uint(size=5)  saoLeftClass[PICT_WIDTH/64][PICT_HEIGHT/64][3];
	uint(size=8)  lcuSizeMax;
	uint(size=8)  log2LcuSizeMax;
	uint(size=8)  log2puSizeMin;
	uint(size=8)  minPUSize[2];
	uint(size=8)  picSizeInCu[2];
	uint(size=8)  picSizeInMb[2];
	uint(size=16) picSize[3][2];
	uint(size=8)  xCu := 0;
	uint(size=8)  yCu := 0;
	uint(size=16)  xMbSent := 0;
	uint(size=16)  yMbSent := 0;
	uint(size=6)  xCuFilt := 0;
	uint(size=6)  yCuFilt := 0;
	uint(size=16) numTokenPerLcu[2];
	uint(size=16) tokenGot;

	int(size=16) iLoop;

	uint(size=16) numTiles;
	uint(size=16) lcuTileIdx;
	uint(size=16) tilesBeg[MAX_NUM_TILES][2];
	uint(size=16) tilesEnd[MAX_NUM_TILES][2];
	bool         filtAcrSlc[PICT_WIDTH/64][PICT_HEIGHT/64];
	bool         filtAcrTile[PICT_WIDTH/64][PICT_HEIGHT/64];
    bool         filtAcrAllSlc;
	bool         filtAcrAllTiles;
	bool         filtAcrCurrSlc;
	bool         filtAcrCurrTile;
	uint(size=8) numSlc[PICT_WIDTH/64][PICT_HEIGHT/64];
	uint(size=8) numTile[PICT_WIDTH/64][PICT_HEIGHT/64];
    bool         mbFiltered[3][(PICT_WIDTH + 15)/16 + 1][(PICT_HEIGHT + 15)/16];
	uint(size=8) numCurrSlc;
	
	procedure saveLcuBorder(uint(size=3) cIdx)
	var
		uint(size=16) addrBeg[2] := [xCu << log2LcuSizeMax, yCu << log2LcuSizeMax],
		uint(size=16) addrEnd[2] := [(xCu << log2LcuSizeMax) + lcuSizeMax - 1,
		                             (yCu << log2LcuSizeMax) + lcuSizeMax - 1]
	begin
		if(cIdx = 0) then
			origPict[0][addrBeg[1]][addrBeg[0]] := PictBuffer[0]
				[addrBeg[1]][addrBeg[0]];

			if(yCu > 0) then
				if(tilesBeg[lcuTileIdx][1] = yCu) then
					foreach uint x in addrBeg[0] .. addrEnd[0] - 1
					do
						origPict[0][addrBeg[1]][x] := PictBuffer[0]
							[addrBeg[1]][x];
					end
				else if(saoTypeIdx[xCu][yCu - 1][0] = 2 &&
					saoEoClass[xCu][yCu - 1][0] != 0) then
					foreach uint x in addrBeg[0] + 1 .. addrEnd[0] - 1
					do
						origPict[0][addrBeg[1]][x] := PictBuffer[0]
							[addrBeg[1]][x];
					end
				end end
			end

			foreach uint x in addrBeg[0] .. addrEnd[0]
			do
				origPict[0][addrEnd[1]][x] := PictBuffer[0]
					[addrEnd[1]][x];
			end
			if(xCu > 0) then
				if(tilesBeg[lcuTileIdx][0] = xCu) then
					foreach uint y in addrBeg[1] .. addrEnd[1] - 1
					do
						origPict[0][y][addrBeg[0]] := PictBuffer[0]
							[y][addrBeg[0]];
					end
				else if(saoTypeIdx[xCu - 1][yCu][0] = 2 &&
					saoEoClass[xCu - 1][yCu][0] != 1) then
					foreach uint y in addrBeg[1] + 1 .. addrEnd[1] - 1
					do
						origPict[0][y][addrBeg[0]] := PictBuffer[0]
							[y][addrBeg[0]];
					end
				end end
			end
			foreach uint y in addrBeg[1] .. addrEnd[1] - 1
			do
				origPict[0][y][addrEnd[0]] := PictBuffer[0]
					[y][addrEnd[0]];
			end
		end

		addrBeg := [addrBeg[0] >> 1,addrBeg[1] >> 1];
		addrEnd := [addrEnd[0] >> 1,addrEnd[1] >> 1];

		if(cIdx = 1) then
			origPict[1][addrBeg[1]][addrBeg[0]] := PictBuffer[1]
				[addrBeg[1]][addrBeg[0]];

			if(yCu > 0) then
				if(tilesBeg[lcuTileIdx][1] = yCu) then
					foreach uint x in addrBeg[0] .. addrEnd[0] - 1
					do
						origPict[1][addrBeg[1]][x] := PictBuffer[1]
							[addrBeg[1]][x];
					end
				else if(saoTypeIdx[xCu][yCu - 1][1] = 2 &&
					saoEoClass[xCu][yCu - 1][1] != 0) then
					foreach uint x in addrBeg[0] + 1 .. addrEnd[0] - 1
					do
						origPict[1][addrBeg[1]][x] := PictBuffer[1]
							[addrBeg[1]][x];
					end
				end end
			end

			foreach uint x in addrBeg[0] .. addrEnd[0]
			do
				origPict[1][addrEnd[1]][x] := PictBuffer[1]
					[addrEnd[1]][x];
			end

			if(xCu > 0) then
				if(tilesBeg[lcuTileIdx][0] = xCu) then
					foreach uint y in addrBeg[1] .. addrEnd[1] - 1
					do
						origPict[1][y][addrBeg[0]] := PictBuffer[1]
							[y][addrBeg[0]];
					end
				else if(saoTypeIdx[xCu - 1][yCu][1] = 2 &&
					saoEoClass[xCu - 1][yCu][1] != 1) then
					foreach uint y in addrBeg[1] + 1 .. addrEnd[1] - 1
					do
						origPict[1][y][addrBeg[0]] := PictBuffer[1]
							[y][addrBeg[0]];
					end
				end end
			end
			foreach uint y in addrBeg[1] .. addrEnd[1] - 1
			do
				origPict[1][y][addrEnd[0]] := PictBuffer[1]
					[y][addrEnd[0]];
			end
		end

		if(cIdx = 2) then
			origPict[2][addrBeg[1]][addrBeg[0]] := PictBuffer[2]
				[addrBeg[1]][addrBeg[0]];

			if(yCu > 0) then
				if(tilesBeg[lcuTileIdx][1] = yCu) then
					foreach uint x in addrBeg[0] .. addrEnd[0] - 1
					do
						origPict[2][addrBeg[1]][x] := PictBuffer[2]
							[addrBeg[1]][x];
					end
				else if(saoTypeIdx[xCu][yCu - 1][1] = 2 &&
					saoEoClass[xCu][yCu - 1][1] != 0) then
					foreach uint x in addrBeg[0] + 1 .. addrEnd[0] - 1
					do
						origPict[2][addrBeg[1]][x] := PictBuffer[2]
							[addrBeg[1]][x];
					end
				end end
			end

			foreach uint x in addrBeg[0] .. addrEnd[0]
			do
				origPict[2][addrEnd[1]][x] := PictBuffer[2]
					[addrEnd[1]][x];
			end

			if(xCu > 0) then
				if(tilesBeg[lcuTileIdx][0] = xCu) then
					foreach uint y in addrBeg[1] .. addrEnd[1] - 1
					do
						origPict[2][y][addrBeg[0]] := PictBuffer[2]
							[y][addrBeg[0]];
					end
				else if(saoTypeIdx[xCu - 1][yCu][1] = 2 &&
					saoEoClass[xCu - 1][yCu][1] != 1) then
					foreach uint y in addrBeg[1] + 1 .. addrEnd[1] - 1
					do
						origPict[2][y][addrBeg[0]] := PictBuffer[2]
							[y][addrBeg[0]];
					end
				end end
			end
			foreach uint y in addrBeg[1] .. addrEnd[1] - 1
			do
				origPict[2][y][addrEnd[0]] := PictBuffer[2]
					[y][addrEnd[0]];
			end
		end
	end

	procedure sendFilteredLcu(uint xIdx, uint yIdx, uint cIdx)
	var
		uint nbBlkPerLcu =
			if(lcuSizeMax = 64) then
				4
			else if(lcuSizeMax = 32) then
				2
			else
				1
			end end
	begin
		foreach int x in 0 .. nbBlkPerLcu - 1
		do
			foreach int y in 0 .. nbBlkPerLcu - 1
			do
				mbFiltered[cIdx][(xIdx>>4) + x][(yIdx>>4) + y] := true;
			end
		end
	end

	procedure nextLcuAddress()
	begin
		xCu := xCu + 1;
		if(xCu = tilesEnd[lcuTileIdx][0]) then
			xCu := tilesBeg[lcuTileIdx][0];
			yCu := yCu + 1;
			if(yCu = tilesEnd[lcuTileIdx][1]) then
				lcuTileIdx := lcuTileIdx + 1;
				xCu := tilesBeg[lcuTileIdx][0];
				yCu := tilesBeg[lcuTileIdx][1];
			end
		end
	end

	procedure nextMbAddr()
	begin
		xMbSent := xMbSent + 1;
		if(xMbSent = picSizeInMb[0]) then
			xMbSent := 0;
			yMbSent := yMbSent + 1;
		end
	end

	function lcuFiltIsPictureBorder() --> bool
	:
		xCuFilt = 0 || yCuFilt = 0||
		xCuFilt+1 >= picSizeInCu[0] ||
		yCuFilt+1 >= picSizeInCu[1]
	end
	
	procedure revertFiltering(uint(size=2) saoTypeIdxBorder[8], uint(size=8)  lcuSizeMax, uint(size=16) idxOrig[2],
		uint (size=16) idxMax[2], uint(size=2) cIdx, uint(size=8)  newPix[66][66])
	begin
		//UP-LEFT
		if(saoTypeIdxBorder[0] != 0 && idxOrig[0] != 0 && idxOrig[1] != 0) then
			newPix[0][0] := PictBuffer[cIdx][idxOrig[1] - 1][idxOrig[0] - 1];
			PictBuffer[cIdx][idxOrig[1] - 1][idxOrig[0] - 1] :=
				origPict[cIdx][idxOrig[1] - 1][idxOrig[0] - 1];
		end

		//UP-RIGHT
		if(saoTypeIdxBorder[2] != 0 && idxMax[0] = lcuSizeMax - 1 && idxOrig[1] != 0) then
			newPix[0][lcuSizeMax + 1] := PictBuffer[cIdx][idxOrig[1] - 1][idxOrig[0] + lcuSizeMax];
			PictBuffer[cIdx][idxOrig[1] - 1][idxOrig[0] + lcuSizeMax] :=
				origPict[cIdx][idxOrig[1] - 1][idxOrig[0] + lcuSizeMax];
		end

		//DOWN-LEFT
		if(saoTypeIdxBorder[6] != 0 && idxOrig[0] != 0 && idxMax[1] = lcuSizeMax - 1) then
			newPix[lcuSizeMax + 1][0] :=
				PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][idxOrig[0] - 1];
			PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][idxOrig[0] - 1] :=
				origPict[cIdx][idxOrig[1] + lcuSizeMax][idxOrig[0] - 1];
		end

		//DOWN-RIGHT
		if(saoTypeIdxBorder[4] != 0 && idxMax[0] = lcuSizeMax - 1 && idxMax[1] = lcuSizeMax - 1) then
			newPix[lcuSizeMax + 1][lcuSizeMax + 1] :=
				PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][idxOrig[0] + lcuSizeMax];
			PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][idxOrig[0] + lcuSizeMax] :=
				origPict[cIdx][idxOrig[1] + lcuSizeMax][idxOrig[0] + lcuSizeMax];
		end

		//LEFT
		if(saoTypeIdxBorder[7] != 0 && idxOrig[0] != 0) then
			foreach int y in idxOrig[1] .. idxOrig[1] + lcuSizeMax - 1
			do
				newPix[y - idxOrig[1] + 1][0] :=
					PictBuffer[cIdx][y][idxOrig[0] - 1];
				PictBuffer[cIdx][y][idxOrig[0] - 1] :=
					origPict[cIdx][y][idxOrig[0] - 1];
			end
		end

		//RIGHT
		if(saoTypeIdxBorder[3] != 0 && idxMax[0] = lcuSizeMax - 1) then
			foreach int y in idxOrig[1] .. idxOrig[1] + lcuSizeMax - 1
			do
				newPix[y - idxOrig[1] + 1][lcuSizeMax + 1] :=
					PictBuffer[cIdx][y][idxOrig[0] + lcuSizeMax];
				PictBuffer[cIdx][y][idxOrig[0] + lcuSizeMax] :=
					origPict[cIdx][y][idxOrig[0] + lcuSizeMax];
			end
		end

		//UP
		if(saoTypeIdxBorder[1] != 0 && idxOrig[1] != 0) then
			foreach int x in idxOrig[0] .. idxOrig[0] + lcuSizeMax - 1
			do
				newPix[0][x - idxOrig[0] + 1] :=
					PictBuffer[cIdx][idxOrig[1] - 1][x];
				PictBuffer[cIdx][idxOrig[1] - 1][x] :=
					origPict[cIdx][idxOrig[1] - 1][x];
			end
		end

		//DOWN
		if(saoTypeIdxBorder[5] != 0 && idxMax[1] = lcuSizeMax - 1) then
			foreach int x in idxOrig[0] .. idxOrig[0] + lcuSizeMax - 1
			do
				newPix[lcuSizeMax + 1][x - (idxOrig[0] - 1)] :=
					PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][x];
				PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][x] :=
					origPict[cIdx][idxOrig[1] + lcuSizeMax][x];
			end
		end
	end

	procedure putBackFilteredPix(uint(size=2) saoTypeIdxBorder[8], uint(size=8) lcuSizeMax, uint(size=16) idxOrig[2],
		uint (size=16) idxMax[2], uint(size=2) cIdx, uint(size=8)  newPix[66][66])
	begin
		//UP-LEFT
		if(saoTypeIdxBorder[0] != 0 && idxOrig[0] != 0 && idxOrig[1] != 0) then
			PictBuffer[cIdx][idxOrig[1] - 1][idxOrig[0] - 1] :=
				newPix[0][0];
		end

		//UP-RIGHT
		if(saoTypeIdxBorder[2] != 0 && idxMax[0] = lcuSizeMax - 1 && idxOrig[1] != 0) then
			PictBuffer[cIdx][idxOrig[1] - 1][idxOrig[0] + lcuSizeMax] :=
				newPix[0][lcuSizeMax + 1];
		end

		//DOWN-LEFT
		if(saoTypeIdxBorder[6] != 0 && idxOrig[0] != 0 && idxMax[1] = lcuSizeMax - 1) then
			PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][idxOrig[0] - 1] :=
				newPix[lcuSizeMax + 1][0];
		end

		//DOWN-RIGHT
		if(saoTypeIdxBorder[4] != 0 && idxMax[0] = lcuSizeMax - 1 && idxMax[1] = lcuSizeMax - 1) then
			PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][idxOrig[0] + lcuSizeMax] :=
				newPix[lcuSizeMax + 1][lcuSizeMax + 1];
		end

		//LEFT
		if(saoTypeIdxBorder[7] != 0 && idxOrig[0] != 0) then
			foreach int y in idxOrig[1] .. idxOrig[1] + lcuSizeMax - 1
			do
				PictBuffer[cIdx][y][idxOrig[0] - 1] :=
					newPix[y - idxOrig[1] + 1][0];
			end
		end

		//RIGHT
		if(saoTypeIdxBorder[3] != 0 && idxMax[0] = lcuSizeMax - 1) then
			foreach int y in idxOrig[1] .. idxOrig[1] + lcuSizeMax - 1
			do
				PictBuffer[cIdx][y][idxOrig[0] + lcuSizeMax] :=
					newPix[y - idxOrig[1] + 1][lcuSizeMax + 1];
			end
		end

		//UP
		if(saoTypeIdxBorder[1] != 0 && idxOrig[1] != 0) then
			foreach int x in idxOrig[0] .. idxOrig[0] + lcuSizeMax - 1
			do
				PictBuffer[cIdx][idxOrig[1] - 1][x] :=
					newPix[0][x - idxOrig[0] + 1];
			end
		end

		//DOWN
		if(saoTypeIdxBorder[5] != 0 && idxMax[1] = lcuSizeMax - 1) then
			foreach int x in idxOrig[0] .. idxOrig[0] + lcuSizeMax - 1
			do
				PictBuffer[cIdx][idxOrig[1] + lcuSizeMax][x] :=
					newPix[lcuSizeMax + 1][x - (idxOrig[0] - 1)];
			end
		end
	end
	
	procedure resetTilesOrSliceEdgeLuma(uint(size=16) rx, uint(size=16) ry, uint(size=16) idxMin[2], uint(size=16) idxMax[2],
		int(size=2)  xOff[2], int(size=2)  yOff[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool          pixIsInPict
	begin
		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			foreach int(size=16) x in idxMin[0] .. idxMax[0]
			do
				xIdx := rx + x;
				foreach uint k in 0 .. 1
				do
					pixIdx[k][0] := xIdx + xOff[k];
					pixIdx[k][1] := yIdx + yOff[k];
				end
				pixIsInPict :=
					not(not filtAcrSlc[xIdx >> log2LcuSizeMax][yIdx >> log2LcuSizeMax] &&
						numSlc[pixIdx[0][0] >> log2LcuSizeMax][pixIdx[0][1] >> log2LcuSizeMax] !=
						numSlc[pixIdx[1][0] >> log2LcuSizeMax][pixIdx[1][1] >> log2LcuSizeMax])
					and not(not filtAcrTile[xIdx >> log2LcuSizeMax][yIdx >> log2LcuSizeMax] &&
						numTile[pixIdx[0][0] >> log2LcuSizeMax][pixIdx[0][1] >> log2LcuSizeMax] !=
						numTile[pixIdx[1][0] >> log2LcuSizeMax][pixIdx[1][1] >> log2LcuSizeMax]);

				if(not pixIsInPict) then
					PictBuffer[0][yIdx][xIdx] :=
						origPict[0][yIdx][xIdx];
				end
			end
		end
	end
	
	procedure resetTilesOrSliceEdgeChroma(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) idxMin[2], uint(size=16) idxMax[2],
		int(size=2)  xOff[2], int(size=2)  yOff[2])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool          pixIsInPict
	begin
		foreach uint(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			foreach int(size=16) x in idxMin[0] .. idxMax[0]
			do
				xIdx := rx + x;
				pixIsInPict := true;
				foreach uint k in 0 .. 1
				do
					pixIdx[k][0] := xIdx + xOff[k];
					pixIdx[k][1] := yIdx + yOff[k];
					pixIsInPict := pixIsInPict and
						not(not filtAcrSlc[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
							numSlc[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] !=
							numSlc[pixIdx[k][0] >> (log2LcuSizeMax - 1)][pixIdx[k][1] >> (log2LcuSizeMax - 1)])
						and not(not filtAcrTile[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
							numTile[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] !=
							numTile[pixIdx[k][0] >> (log2LcuSizeMax - 1)][pixIdx[k][1] >> (log2LcuSizeMax - 1)]);
				end
				if(not pixIsInPict) then
					PictBuffer[cIdx][yIdx][xIdx] :=
						origPict[cIdx][yIdx][xIdx];
				end
			end
		end
	end

    @optimize_c(condition="OPENHEVC_ENABLE && HAVE_SSE4", name="saoFilterEdge_orcc")
	procedure saoFilterEdge(uint(size=2) saoEoClasss, uint(size=2) cIdx, uint(size=2) cIdxOffset,
		uint(size=16) idxMin[2], uint(size=8) lcuSizeMax, uint(size=16) picSize[2],
		bool lcuIsPictBorder, 
		int(size=32) saoOff[5], bool filtAcrossSlcAndTiles,
		uint(size=8) origPict[3][PICT_HEIGHT][PICT_WIDTH],
		uint(size=8) PictBuffer[3][PICT_HEIGHT][PICT_WIDTH],
		uint(size=2) saoTypeIdxBorder[8])
	begin
		if(cIdx = 0) then
			if(saoEoClasss = 0) then
				saoFilterEdgeLuma_Horiz(idxMin, lcuSizeMax, picSize, lcuIsPictBorder,
					saoOff, filtAcrossSlcAndTiles, saoTypeIdxBorder);
			else if(saoEoClasss = 1) then
				saoFilterEdgeLuma_Vert(idxMin, lcuSizeMax, picSize, lcuIsPictBorder,
					saoOff, filtAcrossSlcAndTiles, saoTypeIdxBorder);
			else
				@inline
				saoFilterEdgeLuma_Diag(idxMin, lcuSizeMax, picSize, lcuIsPictBorder,
					saoOff, filtAcrossSlcAndTiles, saoTypeIdxBorder);
			end end
		else
			if(saoEoClass[xCuFilt][yCuFilt][cIdx] = 0) then
				saoFilterEdgeChroma_Horiz(idxMin[0], idxMin[1], cIdx, picSize, lcuIsPictBorder,	saoTypeIdxBorder);
			else if(saoEoClass[xCuFilt][yCuFilt][cIdx] = 1) then
				saoFilterEdgeChroma_Vert(idxMin[0], idxMin[1], cIdx, picSize, lcuIsPictBorder,	saoTypeIdxBorder);
			else
				saoFilterEdgeChroma_Diag(idxMin[0], idxMin[1], cIdx, picSize, lcuIsPictBorder,	saoTypeIdxBorder);
			end end
		end
	end

	procedure saoFilterEdgeLuma_Horiz(uint(size=16) idxMin[2], uint(size=8) lcuSizeMax,
		uint(size=16) picSize[2], bool lcuIsPictBorder, int(size=32) saoOffset[5], bool filtAcrossSlcAndTiles,
		uint(size=2) saoTypeIdxBorder[8])
	var
		int (size=16) xMax,
		uint(size=16) yMax,
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) xPix2,
		uint(size=3) edgeIdx,
		int (size=16) xMin,
		uint(size=16) idxMinRst[2],
		uint(size=16) idxMaxRst[2],
		int(size=2)  xOff[2] = [-1, 1],
		int(size=2)  yOff[2] = [ 0, 0]
	begin
		xMax := min(lcuSizeMax - 1, picSize[0] - idxMin[0] - 1);
		yMax := min(lcuSizeMax - 1, picSize[1] - idxMin[1] - 1);

		foreach int(size=16) y in 0 .. yMax
		do
			yIdx := idxMin[1] + y;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := idxMin[0] + x;
				xPix2 := xIdx + 1;
				signResult[0][y][(x + 1) & 127] :=
					Sign3(PictBuffer[0][yIdx][xPix2] -
						PictBuffer[0][yIdx][xIdx]);
			end
		end

		//Using non filtered pixels for borders.
		if(idxMin[0] != 0) then
			xIdx := idxMin[0] - 1;
			xPix2 := xIdx + 1;
			foreach int(size=16) y in 0 .. yMax
			do
				yIdx := idxMin[1] + y;
				signResult[0][y][0] :=
					if(saoTypeIdxBorder[7] != 0) then
						Sign3(PictBuffer[0][yIdx][xPix2] -
							origPict[0][yIdx][xIdx])
					else
						Sign3(PictBuffer[0][yIdx][xPix2] -
							PictBuffer[0][yIdx][xIdx])
					end;
			end
		end
		if(xMax = lcuSizeMax - 1) then
			xIdx := idxMin[0] + lcuSizeMax - 1;
			xPix2 := xIdx + 1;
			foreach int(size=16) y in 0 .. yMax
			do
				yIdx := idxMin[1] + y;
				signResult[0][y][lcuSizeMax & 127] :=
					if(saoTypeIdxBorder[3] != 0) then
						Sign3(origPict[0][yIdx][xPix2 & MASK_WIDTH_POW_2] -
							PictBuffer[0][yIdx][xIdx])
					else
						Sign3(PictBuffer[0][yIdx][xPix2] -
							PictBuffer[0][yIdx][xIdx])
					end;
			end
		end

		xMin := 0;
		if(lcuIsPictBorder) then
			if(idxMin[0] = 0) then
				xMin := 1;
			end
			if(idxMin[0] + xMax = picSize[0] - 1) then
				xMax := xMax - 1;
			end
		end

		foreach uint(size=3) y in 0 .. yMax
		do
			yIdx := idxMin[1] + y;
			foreach int(size=16) x in xMin .. xMax
			do
				xIdx := idxMin[0] + x;
				xPix2 := xIdx + 1;

				edgeIdx := 2 + signResult[0][y][x]
					- signResult[0][y][x+1];
				edgeIdx := edgeIdxConv[edgeIdx];
				PictBuffer[0][yIdx][xIdx] :=
					clip_i32(PictBuffer[0][yIdx][xIdx] +
						saoOffset[edgeIdx], 0, 255);
			end
		end

		if(not filtAcrossSlcAndTiles) then
			idxMinRst := [xMin, 0];
			idxMaxRst := [xMax, yMax];
			resetTilesOrSliceEdgeLuma(idxMin[0], idxMin[1], idxMinRst, idxMaxRst, xOff, yOff);
		end
	end

	procedure saoFilterEdgeLuma_Vert(uint(size=16) idxMin[2], uint(size=8) lcuSizeMax,
		uint(size=16) picSize[2], bool lcuIsPictBorder, int(size=32) saoOffset[5], bool filtAcrossSlcAndTiles,
		uint(size=2) saoTypeIdxBorder[8])
	var
		int (size=16) yMin,
		int (size=16) xMax,
		uint(size=16) yMax,
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) yPix2,
		uint(size=3) edgeIdx,
		uint(size=16) idxMinRst[2],
		uint(size=16) idxMaxRst[2],
		int(size=2)  xOff[2] = [ 0, 0],
		int(size=2)  yOff[2] = [-1, 1]
	begin
		xMax := min(lcuSizeMax - 1, picSize[0] - idxMin[0] - 1);
		yMax := min(lcuSizeMax - 1, picSize[1] - idxMin[1] - 1);

		foreach int(size=16) y in 0 .. yMax
		do
			yIdx := idxMin[1] + y;
			yPix2 := yIdx + 1;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := idxMin[0] + x;

				signResult[0][(y+1)&127][x] :=
					Sign3(PictBuffer[0][yPix2][xIdx] -
						PictBuffer[0][yIdx][xIdx]);
			end
		end

		//Using non filtered pixels for borders.
		if(idxMin[1] != 0) then
			yIdx := idxMin[1] - 1;
			yPix2 := yIdx + 1;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := idxMin[0] + x;

				signResult[0][0][x] :=
					if(saoTypeIdxBorder[1] != 0) then
						Sign3(PictBuffer[0][yPix2][xIdx] -
							origPict[0][yIdx][xIdx])
					else
						Sign3(PictBuffer[0][yPix2][xIdx] -
							PictBuffer[0][yIdx][xIdx])
					end;
			end
		end
		if(yMax = lcuSizeMax - 1) then
			yIdx := idxMin[1] + lcuSizeMax - 1;
			yPix2 := yIdx + 1;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := idxMin[0] + x;

				signResult[0][lcuSizeMax & 127][x] :=
					if(saoTypeIdxBorder[5] != 0) then
						Sign3(origPict[0][yPix2 & MASK_HEIGHT_POW_2][xIdx] -
							PictBuffer[0][yIdx][xIdx])
					else
						Sign3(PictBuffer[0][yPix2][xIdx] -
							PictBuffer[0][yIdx][xIdx])
					end;
			end
		end

		yMin := 0;
		if(lcuIsPictBorder) then
			if(idxMin[1] = 0) then
				yMin := 1;
			end
			if(idxMin[1] + yMax = picSize[1] - 1) then
				yMax := yMax - 1;
			end
		end

		foreach int(size=16) x in 0 .. xMax
		do
			xIdx := idxMin[0] + x;
			foreach uint(size=3) y in yMin .. yMax
			do
				yIdx := idxMin[1] + y;
				yPix2 := yIdx + 1;

				edgeIdx := 2 + signResult[0][y][x]
					- signResult[0][y+1][x];
				edgeIdx := edgeIdxConv[edgeIdx];
				PictBuffer[0][yIdx][xIdx] :=
					clip_i32(PictBuffer[0][yIdx][xIdx] +
						saoOffset[edgeIdx], 0, 255);
			end
		end

		if(not filtAcrossSlcAndTiles) then
			idxMinRst := [0, yMin];
			idxMaxRst := [xMax, yMax];
			resetTilesOrSliceEdgeLuma(idxMin[0], idxMin[1], idxMinRst, idxMaxRst, xOff, yOff);
		end
	end

	procedure saoFilterEdgeLuma_Diag(uint(size=16) idxOrig[2], uint(size=8) lcuSizeMax,
		uint(size=16) picSize[2], bool lcuIsPictBorder, int(size=32) saoOffset[5], bool filtAcrossSlcAndTiles,
		uint(size=2) saoTypeIdxBorder[8])
	var
		uint (size=16) idxMin[2],
		uint (size=16) idxMax[2],
		int (size=16) xMax,
		uint (size=16) xIdx,
		uint (size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		uint(size=3)  edgeIdx,
		int (size=2)  xOff[2],
		int (size=2)  yOff[2],
		uint(size=8)  newPix[66][66]
	begin
		idxMax[0] := min(lcuSizeMax - 1, picSize[0] - idxOrig[0] - 1);
		idxMax[1] := min(lcuSizeMax - 1, picSize[1] - idxOrig[1] - 1);
		foreach uint k in 0 .. 1
		do
			xOff[k] := constHPos0[saoEoClass[xCuFilt][yCuFilt][0]][k];
			yOff[k] := constVPos0[saoEoClass[xCuFilt][yCuFilt][0]][k];
		end

		idxMin[0] := if(idxOrig[0] = 0 || xOff[0] != -1) then 0 else -1 end;
		xMax      := if(xOff[0]  = -1) then idxMax[0] else idxMax[0] + 1 end;
		idxMin[1] := if(idxOrig[1] = 0) then 0 else -1 end;


		revertFiltering(saoTypeIdxBorder, lcuSizeMax, idxOrig,
			idxMax, cIdx, newPix);

		pixIdx[1][1] := idxOrig[1] + yOff[1] + idxMin[1];
		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := idxOrig[1] + y;
			pixIdx[1][0] := idxOrig[0] + xOff[1] + idxMin[0];
			foreach int(size=16) x in idxMin[0] .. xMax
			do
				xIdx := idxOrig[0] + x;
				signResult[0][(y+yOff[1])&127][(x+xOff[1])&127] :=
					Sign3(PictBuffer[0][pixIdx[1][1]][pixIdx[1][0]] -
						PictBuffer[0][yIdx][xIdx]);
				pixIdx[1][0] := pixIdx[1][0] + 1;
			end
			pixIdx[1][1] := pixIdx[1][1] + 1;
		end

		putBackFilteredPix(saoTypeIdxBorder, lcuSizeMax, idxOrig,
			idxMax, cIdx, newPix);

		idxMin[0] := 0;
		idxMin[1] := 0;
		if(lcuIsPictBorder) then
			if(idxOrig[0] = 0) then
				idxMin[0] := 1;
			end
			if(idxOrig[0] + idxMax[0] = picSize[0] - 1) then
				idxMax[0] := idxMax[0] - 1;
			end
			if(idxOrig[1] = 0) then
				idxMin[1] := 1;
			end
			if(idxOrig[1] + idxMax[1] = picSize[1] - 1) then
				idxMax[1] := idxMax[1] - 1;
			end
		end
		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := idxOrig[1] + y;
			foreach int(size=16) x in idxMin[0] .. idxMax[0]
			do
				xIdx := idxOrig[0] + x;
				edgeIdx := 2 + signResult[0][y][x]
					- signResult[0][(y+yOff[1])&127][(x+xOff[1])&127];
				edgeIdx := edgeIdxConv[edgeIdx];

				PictBuffer[0][yIdx][xIdx] :=
					clip_i32(PictBuffer[0][yIdx][xIdx] +
					saoOffset[edgeIdx], 0, 255);
			end
		end
		if(not filtAcrossSlcAndTiles) then
			resetTilesOrSliceEdgeLuma(idxOrig[0], idxOrig[1], idxMin, idxMax, xOff, yOff);
		end
	end

	@optimize_c(condition="OPENHEVC_ENABLE", name="saoBandFilter_orcc")
	procedure saoBandFilter(uint(size=5) saoLeftClass, int(size=32) saoOffset[5],
		uint(size=2) cIdx, uint(size=8) cIdxOffset, uint (size=16) idxMin[2], uint (size=16) idxMax[2],
		uint(size=8) PictBuffer[3][2048][4096])
	var
		uint(size=3)  bandShift = BIT_DEPTH-5,
		uint(size=3)  bandIdx,
		uint(size=3)  bandTable[32] := [0: for int i in 0 .. 31]
	begin
		foreach uint k in 0 .. 3
		do
			bandTable[(k+saoLeftClass) & 31] := k+1;
		end
		foreach uint(size=16) y in idxMin[1] .. idxMax[1]
		do
			foreach int(size=16) x in idxMin[0] .. idxMax[0]
			do
				bandIdx := bandTable[PictBuffer[cIdx][y][x]>>bandShift];
				PictBuffer[cIdx][y][x] :=
					clip_i32(PictBuffer[cIdx][y][x] +
					saoOffset[bandIdx], 0, 255);
			end
		end
	end

	procedure codingTreeBlockModif(uint(size=16) rx, uint(size=16) ry, uint(size=2) cIdx,
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		uint (size=16) idxMax[2],
		uint (size=16) idxOrig[2] = [rx, ry],
		int (size=32) saoOff[5],
		int (size=8)  compShift[3] = [0, 1, 1],
		uint(size=2)  saoTypeIdxBorder[8]
	begin
		saoOff := [saoOffset[xCuFilt][yCuFilt][cIdx][i]: for int i in 0 .. 4];
		if(saoTypeIdx[xCuFilt][yCuFilt][cIdx] = 2) then

			saoTypeIdxBorder[0] := saoTypeIdx[xCuFilt - 1][yCuFilt - 1][cIdx];
			saoTypeIdxBorder[1] := saoTypeIdx[xCuFilt    ][yCuFilt - 1][cIdx];
			saoTypeIdxBorder[2] := saoTypeIdx[xCuFilt + 1][yCuFilt - 1][cIdx];
			saoTypeIdxBorder[3] := saoTypeIdx[xCuFilt + 1][yCuFilt    ][cIdx];
			saoTypeIdxBorder[4] := saoTypeIdx[xCuFilt + 1][yCuFilt + 1][cIdx];
			saoTypeIdxBorder[5] := saoTypeIdx[xCuFilt    ][yCuFilt + 1][cIdx];
			saoTypeIdxBorder[6] := saoTypeIdx[xCuFilt - 1][yCuFilt + 1][cIdx];
			saoTypeIdxBorder[7] := saoTypeIdx[xCuFilt - 1][yCuFilt    ][cIdx];
            saoFilterEdge(saoEoClass[xCuFilt][yCuFilt][cIdx], cIdx, cIdx, idxOrig, lcuSizeMax >> compShift[cIdx], picSize, lcuIsPictBorder,
				saoOff, filtAcrAllSlc
				&& filtAcrAllTiles, origPict, PictBuffer, saoTypeIdxBorder);
		else
			idxMax[0] := min((lcuSizeMax - 1) >> compShift[cIdx], picSize[0] - rx - 1) + rx;
			idxMax[1] := min((lcuSizeMax - 1) >> compShift[cIdx], picSize[1] - ry - 1) + ry;
			saoBandFilter(saoLeftClass[xCuFilt][yCuFilt][cIdx], saoOff, cIdx, cIdx,
				idxOrig, idxMax, PictBuffer);
		end
	end

	procedure saoFilterEdgeChroma_Horiz(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) picSize[2], bool lcuIsPictBorder,
		uint(size=2) saoTypeIdxBorder[8])
	var
		int (size=16) xMax,
		uint(size=16) yMax,
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) xPix1,
		uint(size=16) xPix2,
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int (size=16) idxMin
	begin
		xMax := min((lcuSizeMax - 1) >> 1, picSize[0] - rx - 1);
		yMax := min((lcuSizeMax - 1) >> 1, picSize[1] - ry - 1);

		foreach int(size=16) y in 0 .. yMax
		do
			yIdx := ry + y;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := rx + x;
				xPix2 := xIdx + 1;
				signResult[cIdx][y][(x+1)&127] :=
					Sign3(PictBuffer[cIdx][yIdx][xPix2] -
						PictBuffer[cIdx][yIdx][xIdx]);
			end
		end

		//Using non filtered pixels for borders.
		if(rx != 0) then
			xIdx := rx - 1;
			xPix2 := xIdx + 1;
			foreach int(size=16) y in 0 .. yMax
			do
				yIdx := ry + y;
				signResult[cIdx][y][0] :=
					if(saoTypeIdxBorder[7] != 0) then
						Sign3(PictBuffer[cIdx][yIdx][xPix2] -
							origPict[cIdx][yIdx][xIdx])
					else
						Sign3(PictBuffer[cIdx][yIdx][xPix2] -
							PictBuffer[cIdx][yIdx][xIdx])
					end;
			end
		end
		if(xMax = (lcuSizeMax - 1) >> 1) then
			xIdx := rx + ((lcuSizeMax - 1) >> 1);
			xPix2 := xIdx + 1;
			foreach int(size=16) y in 0 .. yMax
			do
				yIdx := ry + y;
				signResult[cIdx][y][(lcuSizeMax >> 1) & 127] :=
					if(saoTypeIdxBorder[3] != 0) then
						Sign3(origPict[cIdx][yIdx][xPix2 & MASK_WIDTH_POW_2] -
							PictBuffer[cIdx][yIdx][xIdx])
					else
						Sign3(PictBuffer[cIdx][yIdx][xPix2] -
							PictBuffer[cIdx][yIdx][xIdx])
					end;
			end
		end

		idxMin := 0;
		if(lcuIsPictBorder) then
			if(rx = 0) then
				idxMin := 1;
			end
			if(rx + xMax = picSize[0] - 1) then
				xMax := xMax - 1;
			end
		end

		foreach uint(size=3) y in 0 .. yMax
		do
			yIdx := ry + y;
			foreach int(size=16) x in idxMin .. xMax
			do
				xIdx := rx + x;
				xPix1 := xIdx - 1;
				xPix2 := xIdx + 1;

				edgeIdx := 2 + signResult[cIdx][y][x]
					- signResult[cIdx][y][x+1];
				edgeIdx := edgeIdxConv[edgeIdx];
				PictBuffer[cIdx][yIdx][xIdx] :=
					clip_i32(PictBuffer[cIdx][yIdx][xIdx] +
						saoOffset[xCuFilt][yCuFilt][cIdx][edgeIdx], 0, 255);
			end
		end

		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			foreach uint(size=3) y in 0 .. yMax
			do
				yIdx := ry + y;
				foreach int(size=16) x in idxMin .. xMax
				do
					xIdx := rx + x;
					xPix1 := xIdx - 1;
					xPix2 := xIdx + 1;
	
					pixIsInPict := not(not filtAcrSlc[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
						numSlc[xPix1 >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] !=
						numSlc[xPix2 >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)])
						and not(not filtAcrTile[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
						numTile[xPix1 >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] !=
						numTile[xPix2 >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)]);

					if( not pixIsInPict) then
						PictBuffer[cIdx][yIdx][xIdx] :=
							origPict[cIdx][yIdx][xIdx];
					end
				end
			end
		end
	end

	procedure saoFilterEdgeChroma_Vert(uint(size=16) rx, uint(size=16) ry,
		uint(size=2) cIdx, uint(size=16) picSize[2], bool lcuIsPictBorder,
		uint(size=2) saoTypeIdxBorder[8])
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		int (size=16) xMax,
		uint(size=16) yMax,
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int (size=16) idxMin,
		uint(size=16) yPix1,
		uint(size=16) yPix2
	begin
		xMax := min((lcuSizeMax - 1) >> 1, picSize[0] - rx - 1);
		yMax := min((lcuSizeMax - 1) >> 1, picSize[1] - ry - 1);

		foreach int(size=16) y in 0 .. yMax
		do
			yIdx := ry + y;
			yPix2 := yIdx + 1;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := rx + x;
				signResult[cIdx][(y+1)&127][x] :=
					Sign3(PictBuffer[cIdx][yPix2][xIdx] -
						PictBuffer[cIdx][yIdx][xIdx]);
			end
		end

		//Using non filtered pixels for borders.
		if(ry != 0) then
			yIdx := ry - 1;
			yPix2 := yIdx + 1;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := rx + x;
				signResult[cIdx][0][x] :=
					if(saoTypeIdxBorder[1] != 0) then
						Sign3(PictBuffer[cIdx][yPix2][xIdx] -
							origPict[cIdx][yIdx][xIdx])
					else
						Sign3(PictBuffer[cIdx][yPix2][xIdx] -
							PictBuffer[cIdx][yIdx][xIdx])
					end;
			end
		end
		if(yMax = (lcuSizeMax - 1) >> 1) then
			yIdx := ry + ((lcuSizeMax - 1) >> 1);
			yPix2 := yIdx + 1;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := rx + x;
				signResult[cIdx][(lcuSizeMax >> 1) & 127][x] :=
					if(saoTypeIdxBorder[5] != 0) then
						Sign3(origPict[cIdx][yPix2 & MASK_HEIGHT_POW_2][xIdx] -
							PictBuffer[cIdx][yIdx][xIdx])
					else
						Sign3(PictBuffer[cIdx][yPix2][xIdx] -
							PictBuffer[cIdx][yIdx][xIdx])
					end;
			end
		end

		idxMin := 0;
		if(lcuIsPictBorder) then
			if(ry = 0) then
				idxMin := 1;
			end
			if(ry + yMax = picSize[1] - 1) then
				yMax := yMax - 1;
			end
		end

		foreach uint(size=3) y in idxMin .. yMax
		do
			yIdx := ry + y;
			yPix2 := yIdx + 1;
			foreach int(size=16) x in 0 .. xMax
			do
				xIdx := rx + x;

				edgeIdx := 2 + signResult[cIdx][y][x]
					- signResult[cIdx][y+1][x];
				edgeIdx := edgeIdxConv[edgeIdx];
				PictBuffer[cIdx][yIdx][xIdx] :=
					clip_i32(PictBuffer[cIdx][yIdx][xIdx] +
						saoOffset[xCuFilt][yCuFilt][cIdx][edgeIdx], 0, 255);
			end
		end

		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			foreach uint(size=3) y in idxMin .. yMax
			do
				yIdx := ry + y;

				yPix1 := yIdx - 1;
				yPix2 := yIdx + 1;
				foreach int(size=16) x in 0 .. xMax
				do
					xIdx := rx + x;

					pixIsInPict := not(not filtAcrSlc[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
						numSlc[xIdx >> (log2LcuSizeMax - 1)][yPix1 >> (log2LcuSizeMax - 1)] !=
						numSlc[xIdx >> (log2LcuSizeMax - 1)][yPix2 >> (log2LcuSizeMax - 1)])
						and not(not filtAcrTile[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
						numTile[xIdx >> (log2LcuSizeMax - 1)][yPix1 >> (log2LcuSizeMax - 1)] !=
						numTile[xIdx >> (log2LcuSizeMax - 1)][yPix2 >> (log2LcuSizeMax - 1)]);

					if(not pixIsInPict) then
						PictBuffer[cIdx][yIdx][xIdx] :=
							origPict[cIdx][yIdx][xIdx];
					end
				end
			end
		end
	end

	procedure saoFilterEdgeChroma_Diag(uint(size=16) rx, uint(size=16) ry, uint(size=2) cIdx,
		uint(size=16) picSize[2], bool lcuIsPictBorder,
		uint(size=2) saoTypeIdxBorder[8])
	var
		uint(size=16) idxOrig[2] = [rx, ry],
		uint (size=16) idxMin[2],
		uint (size=16) idxMax[2],
		int (size=16) xMax,
		uint (size=16) xIdx,
		uint (size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		uint(size=3)  edgeIdx,
		int(size=2)  xOff[2],
		int(size=2)  yOff[2],
		uint(size=8)  newPix[66][66]
	begin
		foreach uint k in 0 .. 1
		do
			xOff[k] := constHPos0[saoEoClass[xCuFilt][yCuFilt][cIdx]][k];
			yOff[k] := constVPos0[saoEoClass[xCuFilt][yCuFilt][cIdx]][k];
		end
		idxMax[0] := min((lcuSizeMax - 1) >> 1, picSize[0] - rx - 1);
		idxMax[1] := min((lcuSizeMax - 1) >> 1, picSize[1] - ry - 1);

		idxMin[0] := if(rx = 0 || xOff[0] != -1) then 0 else -1 end;
		xMax      := if(xOff[0]  = -1) then idxMax[0] else idxMax[0] + 1 end;
		idxMin[1] := if(ry = 0) then 0 else -1 end;

		revertFiltering(saoTypeIdxBorder, lcuSizeMax >> 1, idxOrig,
			idxMax, cIdx, newPix);

		pixIdx[1][1] := ry + yOff[1] + idxMin[1];
		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			pixIdx[1][0] := rx + xOff[1] + idxMin[0];
			foreach int(size=16) x in idxMin[0] .. xMax
			do
				xIdx := rx + x;
				signResult[cIdx][(y+yOff[1])&127][(x+xOff[1])&127] :=
					Sign3(PictBuffer[cIdx][pixIdx[1][1]][pixIdx[1][0]] -
						PictBuffer[cIdx][yIdx][xIdx]);
				pixIdx[1][0] := pixIdx[1][0] + 1;
			end
			pixIdx[1][1] := pixIdx[1][1] + 1;
		end

		putBackFilteredPix(saoTypeIdxBorder, lcuSizeMax >> 1, idxOrig,
			idxMax, cIdx, newPix);

		idxMin[0] := 0;
		idxMin[1] := 0;
		if(lcuIsPictBorder) then
			if(rx = 0) then
				idxMin[0] := 1;
			end
			if(rx + idxMax[0] = picSize[0] - 1) then
				idxMax[0] := idxMax[0] - 1;
			end
			if(ry = 0) then
				idxMin[1] := 1;
			end
			if(ry + idxMax[1] = picSize[1] - 1) then
				idxMax[1] := idxMax[1] - 1;
			end
		end

		foreach int(size=16) y in idxMin[1] .. idxMax[1]
		do
			yIdx := ry + y;
			foreach int(size=16) x in idxMin[0] .. idxMax[0]
			do
				xIdx := rx + x;
				foreach uint k in 0 .. 1
				do
					pixIdx[k][0] := xIdx + xOff[k];
					pixIdx[k][1] := yIdx + yOff[k];
				end
				edgeIdx := 2 + signResult[cIdx][y][x]
					- signResult[cIdx][(y+yOff[1])&127][(x+xOff[1])&127];
				edgeIdx := edgeIdxConv[edgeIdx];

				PictBuffer[cIdx][yIdx][xIdx] :=
					clip_i32(PictBuffer[cIdx][yIdx][xIdx] +
					saoOffset[xCuFilt][yCuFilt][cIdx][edgeIdx], 0, 255);
			end
		end
		if(not filtAcrAllSlc || not filtAcrAllTiles) then
			resetTilesOrSliceEdgeChroma(rx, ry, cIdx, idxMin, idxMax, xOff, yOff);
		end
	end

	procedure filtPrevLcu()
	begin
		foreach uint cIdx in 0 .. 2
		do
			// sao band filtering
			if (saoTypeIdx[xCu][yCu][cIdx] = 1) then
			    xCuFilt := xCu;
			    yCuFilt := yCu;
			    sampAdapOffFilt(cIdx);
			end
			// Sao edge hor
			if (saoTypeIdx[xCu - 1][yCu][cIdx] = 2 &&
			  saoEoClass[xCu - 1][yCu][cIdx] = 0) then
			    xCuFilt := xCu - 1;
			    yCuFilt := yCu;
				sampAdapOffFilt(cIdx);
			end
			// Sao edge vert or diag2
			if (saoTypeIdx[xCu][yCu - 1][cIdx] = 2 &&
			  saoEoClass[xCu][yCu - 1][cIdx] = 1) then
				xCuFilt := xCu;
			    yCuFilt := yCu - 1;
				sampAdapOffFilt(cIdx);
			end
			// Sao edge diag1
			if (saoTypeIdx[xCu - 1][yCu - 1][cIdx] = 2 &&
			  (saoEoClass[xCu - 1][yCu - 1][cIdx] = 2 ||
			  saoEoClass[xCu - 1][yCu - 1][cIdx] = 3)) then
				xCuFilt := xCu - 1;
				yCuFilt := yCu - 1;
				sampAdapOffFilt(cIdx);
			end
			// Filtering picture border which haven't already been filtered.
			if (xCu = picSizeInCu[0] -1 && yCu > 0 and not mbFiltered[cIdx][xCu << (log2LcuSizeMax - 4)][yCu-1 << (log2LcuSizeMax - 4)]) then
				xCuFilt := xCu;
				yCuFilt := yCu - 1;
				sampAdapOffFilt(cIdx);
			end
			if (xCu > 0 && yCu = picSizeInCu[1] -1 and not mbFiltered[cIdx][xCu-1 << (log2LcuSizeMax - 4)][yCu << (log2LcuSizeMax - 4)]) then
				xCuFilt := xCu - 1;
				yCuFilt := yCu;
				sampAdapOffFilt(cIdx);
			end
		end
	end

	procedure sampAdapOffFilt(uint cIdx)
	var
		uint(size=16) picSizeLoc[2],
		bool lcuIsPictBorder,
		int (size=8)  compShift[3] = [0, 1, 1]
	begin
		lcuIsPictBorder := lcuFiltIsPictureBorder();
		sendFilteredLcu(xCuFilt << log2LcuSizeMax, yCuFilt << log2LcuSizeMax, cIdx);
			picSizeLoc := [picSize[cIdx][0], picSize[cIdx][1]];
		if(saoTypeIdx[xCuFilt][yCuFilt][cIdx]!=0) then
			codingTreeBlockModif(xCuFilt << (log2LcuSizeMax - compShift[cIdx]),
				(yCuFilt << (log2LcuSizeMax - compShift[cIdx])), cIdx, picSizeLoc, lcuIsPictBorder);
		end
	end

	uint(size=8) isLFBypass[PICT_WIDTH/4*PICT_HEIGHT/4];
	procedure resetLFByPass()
	begin
		foreach int j in 0 .. (minPUSize[1]-1) do
			foreach int i in 0 .. (minPUSize[0]-1) do			
				isLFBypass[j*minPUSize[0]+i] := 0;
			end
		end
	end

	procedure setLFByPass(uint(size=16) val, uint(size=16) x, uint(size=16) y, uint(size=16) cb_size)
	var
		uint x_end = min(x+cb_size, picSize[0][0]),
		uint y_end = min(y+cb_size, picSize[0][1])
	begin
		foreach int j in (y>>log2puSizeMin) .. ((y_end>>log2puSizeMin)-1) do
			foreach int i in (x>>log2puSizeMin) .. ((x_end>>log2puSizeMin)-1) do			
				isLFBypass[j*minPUSize[0]+i] := val;
			end
		end
	end
		
	function getLFByPass(uint(size=8) cIdx, uint(size=16) x, uint(size=16) y) --> uint(size=8)
	:
		isLFBypass[(y>>log2puSizeMin)*minPUSize[0] + (x>>log2puSizeMin)]
	end
	
    isNewPict: action IsPicSlcLcu:[isNewPicSlcLcu],
		LcuSizeMax:[log2LcuSz], LFAcrossSlcTile:[lfAcrossSlcTile],
		PicSize:[picWidthInPix, picHeightInPix], SaoSe:[saoSe], LcuSizeMin:[log2lcuSizeMin] ==>
	guard
		isNewPicSlcLcu = NEW_PIC
	do
		lcuSizeMax := (1 << log2LcuSz);
		log2LcuSizeMax := log2LcuSz;
		log2puSizeMin := log2lcuSizeMin - 1;
		minPUSize[0] := picWidthInPix >> log2puSizeMin;
		minPUSize[1] := picHeightInPix >> log2puSizeMin;
		resetLFByPass();

		picSizeInCu := [(picWidthInPix+(lcuSizeMax - 1)) >> log2LcuSizeMax, (picHeightInPix+(lcuSizeMax - 1)) >> log2LcuSizeMax];
		picSizeInMb := [(picWidthInPix+15)/16, (picHeightInPix+15)/16];
		picSize[0]  := [picWidthInPix   , picHeightInPix];
		picSize[1]  := [picSize[0][0] >> 1, picSize[0][1] >> 1];
		picSize[2]  := [picSize[1][0], picSize[1][1]];
		slcSaoCompEn[0] := (saoSe & 1) !=0;
		slcSaoCompEn[1] := (saoSe & 2) !=0;
		slcSaoCompEn[2] := slcSaoCompEn[1];
		filtAcrCurrSlc  := (lfAcrossSlcTile & 1) != 0;
		filtAcrCurrTile := (lfAcrossSlcTile & 2) != 0;
		filtAcrAllSlc := filtAcrCurrSlc;
		filtAcrAllTiles := filtAcrCurrTile;
		numCurrSlc := 0;
		lcuTileIdx := 0;
		numTokenPerLcu[0] := 1 << (2 * log2LcuSz);
		numTokenPerLcu[1] := numTokenPerLcu[0] >> 2;
		xMbSent := 0;
		yMbSent := 0;
		xCuFilt := 0;
		yCuFilt := 0;
		xCu := 0;
		yCu := 0;
		foreach int cIdx in 0 .. 2
		do
			foreach int i in 0 .. picSizeInMb[0] - 1
			do
				foreach int j in 0 .. picSizeInMb[1] - 1
				do
					mbFiltered[cIdx][i][j] := false;
				end
			end
		end
	end

	//There should be slice SAO enable for each independent slice.
	isNewSlice: action IsPicSlcLcu:[isNewPicSlcLcu],
		LcuSizeMax:[log2LcuSz], LFAcrossSlcTile:[lfAcrossSlcTile],
		PicSize:[picWidthInPix, picHeightInPix], LcuSizeMin:[log2lcuSizeMin]/*, SaoSe:[saoSe]*/ ==>
	guard
		isNewPicSlcLcu = NEW_SLC
	do
		/*slcSaoCompEn[0] := (saoSe & 1) !=0;
		slcSaoCompEn[1] := (saoSe & 2) !=0;
		slcSaoCompEn[2] := slcSaoCompEn[1];*/
		filtAcrCurrSlc  := (lfAcrossSlcTile & 1) != 0;
		filtAcrCurrTile := (lfAcrossSlcTile & 2) != 0;
		filtAcrAllSlc := filtAcrAllSlc && filtAcrCurrSlc;
		filtAcrAllTiles := filtAcrAllTiles && filtAcrCurrTile;
		numCurrSlc := numCurrSlc + 1;
        lcuSizeMax := (1 << log2LcuSz);
		log2LcuSizeMax := log2LcuSz;
	end

	getNumTiles: action TilesCoord:[valNumTiles] ==>
	do
		numTiles := valNumTiles;
		iLoop := 0;
	end

	getTilesCoord.launch: action TilesCoord:[tilesCoord] repeat 4 ==>
	guard
		iLoop < numTiles
	do
		tilesBeg[iLoop] := [tilesCoord[0] >> log2LcuSizeMax, tilesCoord[1] >> log2LcuSizeMax];
		tilesEnd[iLoop] := [(tilesCoord[2]+(lcuSizeMax - 1)) >> log2LcuSizeMax, (tilesCoord[3]+(lcuSizeMax - 1)) >> log2LcuSizeMax];
		iLoop := iLoop + 1;
	end

	getTilesCoord.done: action ==>
	guard
		iLoop = numTiles
	end

    checkSliceEn.isFalse: action ==>
	guard
		not slcSaoCompEn[0] && not slcSaoCompEn[1]
	end

	checkSliceEn.isTrue: action ==>
	guard
		slcSaoCompEn[0] || slcSaoCompEn[1]
	end

	getCuPix.launch.init: action IsPicSlcLcu:[isNewLcu] ==>
	guard
		isNewLcu != NEW_SLC && lcuTileIdx < numTiles
	do
		numSlc[xCu][yCu]  := numCurrSlc;
		numTile[xCu][yCu] := lcuTileIdx;
		filtAcrSlc[xCu][yCu]  := filtAcrCurrSlc;
		filtAcrTile[xCu][yCu] := filtAcrCurrTile;
	end

	getLFBypassCUInfo: action LFBypassCUInfo:[val, x, y, cb_size_w, cb_size_h] ==>
	do
		setLFByPass(val, x, y, max(cb_size_w, cb_size_h));
	end

	getCuPix.launch.luma: action SampleIn:[samp] repeat 16 ==>
	guard
		tokenGot < numTokenPerLcu[0]
	var
		uint(size=16) xPic,
		uint(size=16) yPic
	do
		xPic := (xCu * lcuSizeMax) + (tokenGot & (lcuSizeMax - 1));
		yPic := (yCu * lcuSizeMax) + (tokenGot >> log2LcuSizeMax);
		foreach uint x in 0 .. 15
		do
			PictBuffer[0][yPic][x+xPic] := samp[x];
			origPict[0][yPic][x+xPic] := samp[x]; 
		end

		tokenGot := tokenGot + 16;
	end

	getCuPix.launch.lumaDone: action ==>
	guard
		tokenGot = numTokenPerLcu[0]
	do
		tokenGot := 0;
		cIdx := 1;
	end

	getCuPix.launch.chroma: action SampleIn:[samp] repeat 8 ==>
	guard
		cIdx < 3
	var
		uint(size=16) xPic,
		uint(size=16) yPic
	do
		xPic := (xCu * (lcuSizeMax >> 1)) + (tokenGot & ((lcuSizeMax - 1) >> 1));
		yPic := (yCu * (lcuSizeMax >> 1)) + (tokenGot >> (log2LcuSizeMax - 1));

		foreach uint x in 0 .. 7
		do
			PictBuffer[cIdx][yPic][x+xPic] := samp[x]; 
			origPict[cIdx][yPic][x+xPic] := samp[x]; 
		end

		tokenGot := tokenGot + 8;
		if(tokenGot = numTokenPerLcu[1]) then
			tokenGot := 0;
			cIdx := cIdx + 1;
		end
	end

	getCuPix.launch.chromaDone: action ==>
	guard
		cIdx = 3
	do
		cIdx := 0;
        numSlc[xCu][yCu]     := numCurrSlc;
		filtAcrSlc[xCu][yCu] := filtAcrCurrSlc;
	end

	getCuPix.done: action ==>
	guard
		lcuTileIdx = numTiles
	do
		xCuFilt := picSizeInCu[0] -1;
		yCuFilt := picSizeInCu[1] -1;
		foreach uint cIdx in 0 .. 2
		do
			if(not mbFiltered[cIdx][xCuFilt << (log2LcuSizeMax - 4)][yCuFilt << (log2LcuSizeMax - 4)]) then
				sampAdapOffFilt(cIdx);
			end
		end

		xCu := 0;
		yCu := 0;
	end

	getSaoMerge.noMerge: action SaoSe:[mergeInfo] ==>
	guard
		mergeInfo = SAO_NO_MERGE
	do
		if (DEBUG_Trace) then
			println("=== getSaoMerge.noMerge ===");
			println("SaoSe       = " + mergeInfo);
		end
	end

	getSaoMerge.merge: action SaoSe:[mergeInfo] ==>
	guard
		mergeInfo != SAO_NO_MERGE
	var
		uint(size=16) xMerge =
			if(mergeInfo = SAO_MERGE_LEFT) then xCu-1 else xCu end,
		uint(size=16) yMerge =
			if(mergeInfo = SAO_MERGE_UP)  then yCu-1 else yCu end
	do
		if (DEBUG_Trace) then
			println("=== getSaoMerge.Merge ===");
			println("SaoSe       = " + mergeInfo);
		end
		
		foreach uint cIdx in 0 .. 2
		do
			saoTypeIdx[xCu][yCu][cIdx] := saoTypeIdx[xMerge][yMerge][cIdx];
			if(saoTypeIdx[xCu][yCu][cIdx] = 0) then
                 sendFilteredLcu(xCu << log2LcuSizeMax, yCu << log2LcuSizeMax, cIdx);
			else
				foreach uint i in 1 .. 4
				do
					saoOffset[xCu][yCu][cIdx][i] := saoOffset[xMerge][yMerge][cIdx][i];
				end
				saoEoClass[xCu][yCu][cIdx] := saoEoClass[xMerge][yMerge][cIdx];
				saoLeftClass[xCu][yCu][cIdx] := saoLeftClass[xMerge][yMerge][cIdx];
                //saveLcuBorder(cIdx);
			end
		end
		filtPrevLcu();
		nextLcuAddress();
	end

	getSaoMerge.skip: action ==>
	do
		saoTypeIdx[xCu][yCu] := [0, 0, 0];
		sendFilteredLcu(xCu << log2LcuSizeMax, yCu << log2LcuSizeMax, 0);
		sendFilteredLcu(xCu << log2LcuSizeMax, yCu << log2LcuSizeMax, 1);
		sendFilteredLcu(xCu << log2LcuSizeMax, yCu << log2LcuSizeMax, 2);

		nextLcuAddress();
	end

	getSaoTypeIdx.is0: action SaoSe:[typeIdx] ==>
	guard
		/* Replace by (cIdx<3 && slcSaoCompEn[cIdx] && typeIdx = 0) when orcc's simulator
		 * support short-circuit evaluation.
		 */
		if cIdx <3 && typeIdx = 0 then slcSaoCompEn[cIdx] else false end
	do
		if (DEBUG_Trace) then
			println("=== getSaoTypeIdx.is0 ===");
			println("SaoSe       = " + typeIdx);
		end

		sendFilteredLcu(xCu << log2LcuSizeMax, yCu << log2LcuSizeMax, cIdx);

		saoTypeIdx[xCu][yCu][cIdx] := 0;
		cIdx := cIdx + 1;
	end

	getSaoTypeIdx.isNot0: action SaoSe:[saoSe] repeat 6 ==>
	guard
		/* Replace by (cIdx<3 && slcSaoCompEn[cIdx] && saoSe[0] != 0) when orcc's simulator
		 * support short-circuit evaluation.
		 */
		if cIdx <3 then slcSaoCompEn[cIdx] && saoSe[0] != 0 else false end
	do
		if (DEBUG_Trace) then
			println("=== getSaoTypeIdx.isNot0 ===");
			print("SaoSe       = [");
			foreach uint i in 0 .. 5 do
				print(saoSe[i] + ", ");
			end
			println("]");
		end
		
        //saveLcuBorder(cIdx);
		saoTypeIdx[xCu][yCu][cIdx] := saoSe[0];
		foreach uint i in 1 .. 4
		do
			saoOffset[xCu][yCu][cIdx][i] := saoSe[i];
		end
		if(saoTypeIdx[xCu][yCu][cIdx]=2) then
			saoEoClass[xCu][yCu][cIdx] := saoSe[5];
		else
			saoLeftClass[xCu][yCu][cIdx] := saoSe[5];
		end

		cIdx := cIdx + 1;
	end

	getSaoTypeIdx.skip: action ==>
	guard
		/* Replace by (cIdx<3 && not slcSaoCompEn[cIdx]) when orcc's simulator
		 * support short-circuit evaluation.
		 */
		if cIdx <3 then not slcSaoCompEn[cIdx] else false end
	do
        sendFilteredLcu(xCu << log2LcuSizeMax, yCu << log2LcuSizeMax, cIdx);

		saoTypeIdx[xCu][yCu][cIdx] := 0;
		cIdx := cIdx + 1;
	end

	getSaoTypeIdxDone: action ==>
	guard
		cIdx = 3
	do
		cIdx := 0;
		filtPrevLcu();
		nextLcuAddress();
	end

	sendSamples.launch: action ==> FiltSample:[filtSamp] repeat 16*16 + 2 * 8*8
	var
	    uint tokenOffset,
		uint(size=8) filtSamp[16*16+2*8*8],
        uint(size=16) blkAddrX, uint(size=16) blkAddrY,
        uint(size=16) puAddrX, uint(size=16) puAddrY,
        int idx
	do
        blkAddrX := xMbSent*16;
		blkAddrY := yMbSent*16;

		foreach uint puY in 0 .. 3
		do
			puAddrY := blkAddrY + puY * 4;
			foreach uint puX in 0 .. 3
			do
				puAddrX := blkAddrX + puX * 4;
				if(getLFByPass(0, puAddrX, puAddrY) != 0) then
					foreach uint y in 0 .. 3
					do
						foreach uint x in 0 .. 3
						do
							idx := puX*4+puY*64+x+y*16;
							if(not DEBUG) then					
								filtSamp[idx] := origPict[0][puAddrY+y][puAddrX+x];
							else
								if(puAddrX+x<picSize[0][0] && puAddrY+y<picSize[0][1]) then
									filtSamp[idx] := origPict[0][puAddrY+y][puAddrX+x];
								else
									filtSamp[idx] := 0;
								end
							end
						end
					end
				else // non-bypass
					foreach uint y in 0 .. 3
					do
						foreach uint x in 0 .. 3
						do
							idx := puX*4+puY*64+x+y*16;
							if(not DEBUG) then					
								filtSamp[idx] := PictBuffer[0][puAddrY+y][puAddrX+x];
							else
								if(puAddrX+x<picSize[0][0] && puAddrY+y<picSize[0][1]) then
									filtSamp[idx] := PictBuffer[0][puAddrY+y][puAddrX+x];
								else
									filtSamp[idx] := 0;
								end
							end
						end
					end
				end
			end	
		end	

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		tokenOffset:= 16*16;

		foreach uint comp in 1 .. 2
		do
			foreach uint puY in 0 .. 3
			do
				puAddrY := blkAddrY + puY * 2;
				foreach uint puX in 0 .. 3
				do
					puAddrX := blkAddrX + puX * 2;
					if(getLFByPass(comp, puAddrX<<1, puAddrY<<1) != 0) then
						foreach uint y in 0 .. 1
						do
							foreach uint x in 0 .. 1
							do
								idx := puX*2+puY*16 +  x+y*8 + tokenOffset;
								if(not DEBUG) then
									filtSamp[idx] := origPict[comp][puAddrY+y][puAddrX+x];
								else
									if(puAddrX+x<picSize[0][0]/2 && puAddrY+y<picSize[0][1]/2) then
										filtSamp[idx] := origPict[comp][puAddrY+y][puAddrX+x];
									else
										filtSamp[idx] := 0;
									end
								end
							end
						end
					else // non-bypass
						foreach uint y in 0 .. 1
						do
							foreach uint x in 0 .. 1
							do
								idx := puX*2+puY*16 +  x+y*8 + tokenOffset;
								if(not DEBUG) then
									filtSamp[idx] := PictBuffer[comp][puAddrY+y][puAddrX+x];
								else
									if(puAddrX+x<picSize[0][0]/2 && puAddrY+y<picSize[0][1]/2) then
										filtSamp[idx] := PictBuffer[comp][puAddrY+y][puAddrX+x];
									else
										filtSamp[idx] := 0;
									end
								end
							end
						end				
					end	
				end
			end
			tokenOffset:= tokenOffset + 8*8;
		end	
		
		nextMbAddr();
	end
	
	sendSamples.done: action ==>
	guard
		not mbFiltered[0][xMbSent][yMbSent] ||
		not mbFiltered[1][xMbSent][yMbSent] ||
		not mbFiltered[2][xMbSent][yMbSent] ||
		yMbSent = picSizeInMb[1]
	end
	
	schedule fsm IsNewPict:
		IsNewPict     (isNewPict     )--> CheckSliceEn;

        CheckSliceEn (checkSliceEn.isTrue )-->GetNumTilesFilt;
		CheckSliceEn (checkSliceEn.isFalse )-->GetNumTilesSkipFilt;

		/* Using SAO */
		GetCuPixFilt (isNewSlice           )--> GetNumTilesFilt;
		GetCuPixFilt (getLFBypassCUInfo    )--> GetCuPixFilt;		
		GetCuPixFilt (getCuPix.launch.init )--> GetCuPixLumaFilt;
		GetCuPixFilt (getCuPix.done        )--> SendLastSamplesFilt;

		GetCuPixLumaFilt (getCuPix.launch.luma     )--> GetCuPixLumaFilt;
		GetCuPixLumaFilt (getCuPix.launch.lumaDone )--> GetCuPixChrFilt;

		GetCuPixChrFilt (getCuPix.launch.chroma     )--> GetCuPixChrFilt;
		GetCuPixChrFilt (getCuPix.launch.chromaDone )--> GetSaoMergeFilt;

		GetNumTilesFilt   (getNumTiles          )--> GetTilesCoordFilt;
		GetTilesCoordFilt (getTilesCoord.launch )--> GetTilesCoordFilt;
		GetTilesCoordFilt (getTilesCoord.done   )--> GetCuPixFilt;

		GetSaoMergeFilt (getSaoMerge.merge   )--> SendSamplesFilt;
		GetSaoMergeFilt (getSaoMerge.noMerge )--> GetSaoTypeIdxFilt;

		GetSaoTypeIdxFilt (getSaoTypeIdx     )--> GetSaoTypeIdxFilt;
		GetSaoTypeIdxFilt (getSaoTypeIdxDone )--> SendSamplesFilt;

		SendSamplesFilt (sendSamples.launch )--> SendSamplesFilt;
		SendSamplesFilt (sendSamples.done   )--> GetCuPixFilt;

		SendLastSamplesFilt (sendSamples.launch )--> SendLastSamplesFilt;
        SendLastSamplesFilt (sendSamples.done   )--> IsNewPict;
		
		/* Not using SAO. */

		GetCuPixSkipFilt (isNewSlice           )--> GetNumTilesSkipFilt;
		GetCuPixSkipFilt (getLFBypassCUInfo    )--> GetCuPixSkipFilt;
		GetCuPixSkipFilt (getCuPix.launch.init )--> GetCuPixLumaSkipFilt;
		GetCuPixSkipFilt (getCuPix.done        )--> SendLastSamplesSkipFilt;

		GetCuPixLumaSkipFilt (getCuPix.launch.luma     )--> GetCuPixLumaSkipFilt;
		GetCuPixLumaSkipFilt (getCuPix.launch.lumaDone )--> GetCuPixChrSkipFilt;

		GetCuPixChrSkipFilt (getCuPix.launch.chroma     )--> GetCuPixChrSkipFilt;
		GetCuPixChrSkipFilt (getCuPix.launch.chromaDone )--> GetSaoMergeSkipFilt;

		GetNumTilesSkipFilt   (getNumTiles          )--> GetTilesCoordSkipFilt;
		GetTilesCoordSkipFilt (getTilesCoord.launch )--> GetTilesCoordSkipFilt;
		GetTilesCoordSkipFilt (getTilesCoord.done   )--> GetCuPixSkipFilt;

		GetSaoMergeSkipFilt (getSaoMerge.skip    )--> SendSamplesSkipFilt;

		SendSamplesSkipFilt (sendSamples.launch )--> SendSamplesSkipFilt;
		SendSamplesSkipFilt (sendSamples.done   )--> GetCuPixSkipFilt;

		SendLastSamplesSkipFilt (sendSamples.launch )--> SendLastSamplesSkipFilt;
		SendLastSamplesSkipFilt (sendSamples.done   )--> IsNewPict;
	end
	priority
		sendSamples.done > sendSamples.launch;
		isNewSlice > getCuPix.launch.init;
	end
end
