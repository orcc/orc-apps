/********************************************************************************

This software module was originally developed by 
khaled JERBI (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-5 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-5.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-5 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-5 once the ISO/IEC 23002-5 has been adopted; and 
(2) to develop the ISO/IEC 23002-5: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-5 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-5 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-5.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-5 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-5

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2011-2014.
 

*****************************************************************************/
// Modified by Damien de Saint Jorre (EPFL)
// Modified by Daniele Renzi (EPFL)
// Modified by Junaid Jameel Ahmad (EPFL)
package org.sc29.wg11.mpegh.part2.main.synParser;

import  std.util.Math.*;
import  std.stdio.Source.*;

import  org.sc29.wg11.mpegh.part2.common.BitstreamReadUtils.*;
import  org.sc29.wg11.mpegh.part2.main.synParser.Algo_ParserUtils.*;
import  org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;
import  org.sc29.wg11.mpegh.part2.common.CabacDecodeBinFunction.*;
import  org.sc29.wg11.mpegh.part2.common.CabacContextConstantHEVC.*;
import  org.sc29.wg11.mpegh.part2.common.CabacContextFunctionHEVC.*;
import  org.sc29.wg11.mpegh.part2.common.CabacParserFunctionHEVC.*;

actor Algo_Parser (uint(size=8) PARSER_ID = 0, uint(size=8) TOTAL_PARSERS = 1)
                                uint(size= 8) byte,
                                uint(size= 9) InWppCtx,
                                uint(size= 8) InWppTopCUInfo
                                ==>
                                uint(size=16) CUInfo,
                                uint(size= 6) IntraPredMode,
                                uint(size=16) SliceAddr,
                                uint(size=16) TilesCoord,
                                uint(size= 8) BitDepth,
                                uint(size= 8) LcuSize,
                                uint(size= 4) PartMode,
               					uint(size= 2) IsPicSlcLcu,
               					uint(size= 2) IsPicSlc,
                				uint(size= 2) LFAcrossSlcTile,
                                uint(size=16) PictSize,
                                 int(size=16) Poc,
                                 int(size= 9) SaoSe,
                                uint(size= 8) SEI_MD5,
                                uint(size= 2) SliceType,
                                bool          SplitTransform,
                                 int(size= 8) TUSize,
                                 int(size=16) Coeff,
                                bool          StrongIntraSmoothing,
                                uint(size=14) DispCoord,
                                uint(size= 5) NumRefIdxLxActive,
                                uint(size= 4) RefPicListModif,
                                 int(size=16) RefPoc,
                                 int(size=16) MvPredSyntaxElem,
                                bool		  Cbf,
                                bool		  DBFDisable,
                                 int(size= 8) DbfSe,
                                uint(size= 8) ReorderPics,
                                 int(size=16) WeightedPred,
                                 int(size= 8) Qp,
                                uint(size= 8) PcmSize,
                                uint(size=16) PcmBlk,
                                uint(size=16) LFBypassCUInfo,
                                uint(size= 9) OutWppCtx,
                                uint(size= 8) OutWppTopCUInfo,
                                 int(size= 8) HeaderControl,
                                uint(size=16) NbTokens

:
        uint(size=8) localBuffer[BUFFER_SIZE];
        uint(size=BUFFER_DEPTH) bufferWriteIdx := 0;
        uint(size=BUFFER_DEPTH) bufferReadIdx := 0;
        uint(size=32) localBufferTotalBits := 0;
        uint(size=2) isNewNal := 0;
        uint(size=64) fifoContent := 0;
        uint(size=8) fifoIdx[1] := [0];
        uint(size= 2) zeroByte := 0;
        uint(size= 16) se_idx;
        uint(size=32) cnt_i;
        uint(size=10) sps_id;
        uint(size=10) pps_id;
        uint NUM_ENTRY_MAX = 64;
        uint entryOffsetsTab[NUM_ENTRY_MAX];
        bool byPassFlag := false;

        // Multi-Parser
        uint(size=8) PARSER_INFO[2] := [0, 1];
        uint nbUnitsToSkip := PARSER_INFO[0];
        int(size=64) nbUnitsProcessed := 0;
        bool bReceiveWppTopCuInfo := false;
        bool bSendWppTopCuInfo := false;
        uint parellelType := 0;
        
        // For each Slice Header (SH).
        uint(size=16) nbTokensPerSH[26] := [0: for int i in 0 .. 25];
        // For each CTU.
        uint(size=16) NbTokensPerCTU[15] := [0: for int i in 0 .. 14];
        
        procedure resetNbTokensPerSH()
        begin
	        nbTokensPerSH := [0: for int i in 0 .. 25];        
        end

        procedure resetNbTokensPerCTU()
        begin
	        NbTokensPerCTU := [0: for int i in 0 .. 14];
        end

		@optimize_c(condition="defined(OPENHEVC_ENABLE)", name="openhevc_init_context_shm")
		procedure init_openhevc() begin end

		initialize ==>
		do
			init_openhevc();
			init_last_sig_coeff_xy_prefix_ctx();
			InitScanningArray(ScanOrder);
			
			// Multi-Parser
        	nbUnitsToSkip := PARSER_ID;
        	PARSER_INFO := [PARSER_ID, TOTAL_PARSERS];
		end

        /**************************************************************************
         **************************************************************************
         *********     Definition of CabacContextFunction       *******************
         **************************************************************************
         *************************************************************************/
         
        uint(size=8) rc_ctx_coeff[3][4][2];
        
        procedure init_last_sig_coeff_xy_prefix_ctx()
        var
           uint(size=8) ctx_coeff[2]
        begin
           foreach uint(size= 8) cIdx in 0 .. 2 do
               foreach uint(size= 8) log2TrafoSize in 2 .. 5 do
                   compute_ctx_coeff_93312(ctx_coeff, log2TrafoSize, cIdx);
                   rc_ctx_coeff[cIdx][log2TrafoSize - 2][CTX_OFFSET_IDX] := ctx_coeff[CTX_OFFSET_IDX];
                   rc_ctx_coeff[cIdx][log2TrafoSize - 2][CTX_SHIFT_IDX] := ctx_coeff[CTX_SHIFT_IDX];
               end
           end
        end

        /*************************************************************************
         * get_LAST_SIGNIFICANT_COEFF_X_PREFIX
         *                +
         * get_LAST_SIGNIFICANT_COEFF_Y_PREFIX
         *************************************************************************/
        procedure get_LAST_SIGNIFICANT_COEFF_XY_PREFIX()
        var
            uint(size= 9) ctxIdx,
		    uint(size=8) ctx_coeff[2],
            uint(size= 8) binIdx := 0,
            uint(size=1) binValue[1] := [1],
            uint(size= 8) binSize = (rc_log2TrafoSize << 1) - 2
        begin
            ctx_coeff[CTX_OFFSET_IDX] := rc_ctx_coeff[rc_cIdx][rc_log2TrafoSize - 2][CTX_OFFSET_IDX];
            ctx_coeff[CTX_SHIFT_IDX] := rc_ctx_coeff[rc_cIdx][rc_log2TrafoSize - 2][CTX_SHIFT_IDX];
            
            //get_LAST_SIGNIFICANT_COEFF_X_PREFIX
            if DEBUG_CABAC then
                //println(" LAST_SIGNIFICANT_COEFF_X_PREFIX ==> "+(1<<rc_log2TrafoSize));
                println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
            end
           
            while binIdx <= binSize && binValue[0] = 1 do
                ctxIdx := @inline context_93312(binIdx, ctx_coeff);
                @inline
        	    decodeDecisionTop(ctxIdx, binValue, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_X_PREFIX, fifoContent, fifoIdx);
                binIdx := binIdx + 1;
            end
		    LastSignificantCoeffX := binIdx - 1 + binValue[0];
            if DEBUG_CABAC then
                //println(" LAST_SIGNIFICANT_COEFF_X_PREFIX = "+debinValue[0]);
            end

            //get_LAST_SIGNIFICANT_COEFF_Y_PREFIX
            binIdx := 0;
            binValue[0] := 1;
            if DEBUG_CABAC then
                //println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX ==> "+(1<<rc_log2TrafoSize));
                println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
            end
            while binIdx <= binSize && binValue[0] = 1 do
                ctxIdx := @inline context_93312(binIdx, ctx_coeff);
                @inline
        	    decodeDecisionTop(ctxIdx, binValue, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_Y_PREFIX, fifoContent, fifoIdx);
                binIdx := binIdx + 1;
            end
		    LastSignificantCoeffY := binIdx - 1 + binValue[0];
            if DEBUG_CABAC then
                //println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX = "+debinValue[0]);
            end
        end
    

		function updateDecoderTid(uint(size=6) nal_unit_type) --> uint(size=3)
		:
			if(targetTID <= decoderTID) then
				targetTID
			else
				if(nal_unit_type = NAL_IDR_W_RADL || nal_unit_type = NAL_IDR_N_LP ||
				   nal_unit_type = NAL_BLA_W_LP   || nal_unit_type = NAL_BLA_W_RADL ||
				   nal_unit_type = NAL_BLA_N_LP) then
					targetTID
				elsif((currentTID <= decoderTID + 1) && (nal_unit_type = NAL_TSA_N || nal_unit_type = NAL_TSA_R)) then
					targetTID
				elsif((currentTID = decoderTID + 1) && (nal_unit_type = NAL_STSA_N || nal_unit_type = NAL_STSA_R)) then
					currentTID
				else
					decoderTID
				end
			end
		end
        /**************************************************************************
         **************************************************************************
         ********        Bitstream Reader                     *********************
         **************************************************************************
         *************************************************************************/

        /**************************************************************************
         * search_start_code or getByte
         *************************************************************************/
        uint countAEB := 0;
        uint(size=32) locationAEB[1024];
        read_nal_init.launch : action byte:[ b ] ==>
        guard
        	isNewNal != 2
        do
            if b != EPR_VALUE or zeroByte != 3 then
            	if isNewNal > 0 then
            	  localBuffer[bufferWriteIdx] := b;
            	  bufferWriteIdx := bufferWriteIdx + 1;
            	end
            	isNewNal := isNewNal + castBoolToInt(b = START_CODE_VALUE and zeroByte = 3);
            else
            	if b = EPR_VALUE then //println("AntiEmulationByte");
            		locationAEB[countAEB] := bufferWriteIdx - 1;
            		countAEB := countAEB + 1;            		
            	end
            end
            if b = 0 then
            	zeroByte := ((zeroByte << 1) + 1) & 0x3;
            else
            	zeroByte := 0;
            end
        end
                
        read_nal.launch : action byte:[ b ] ==>
        guard
        	isNewNal != 2
        do
            if b != EPR_VALUE or zeroByte != 3 then
            	isNewNal := isNewNal + castBoolToInt(b = START_CODE_VALUE and zeroByte = 3);
            	localBuffer[bufferWriteIdx] := b;
            	bufferWriteIdx := bufferWriteIdx + 1;
            else
            	if b = EPR_VALUE then // println("AntiEmulationByte");
            		locationAEB[countAEB] := bufferWriteIdx - 1;            		
            		countAEB := countAEB + 1;
            	end
            end
            if b = 0 then
            	zeroByte := ((zeroByte << 1) + 1) & 0x3;
            else
            	zeroByte := 0;
            end
        end
        
        read_nal.done : action ==>
        guard
        	isNewNal = 2
        do
            isNewNal := 1;
            localBufferTotalBits := bufferWriteIdx<<3; 
            bufferWriteIdx := 0;
            bufferReadIdx := 0;
            zeroByte := 0;
            
            load_fifo();
        end
        
        procedure load_fifo()
        var
           uint(size=8) b
        begin
           while not @inline isFifoFull(fifoIdx[0])
           do
             b := localBuffer[bufferReadIdx];
             fifoIdx[0] := fifoIdx[0] + 8;
             fifoContent := (fifoContent << 8) + b;
             bufferReadIdx := bufferReadIdx + 1;
           end
        end
        
        function get_nal_consumed_bits() --> uint(size=32)
        	: (bufferReadIdx << 3) - fifoIdx[0]
        end	

        function get_nal_remaining_bits() --> uint(size=32)
        	: localBufferTotalBits - get_nal_consumed_bits()
        end
        
		function more_rbsp_data() --> bool
			: get_nal_remaining_bits() > 0 && show_bits(8, fifoContent, fifoIdx[0]) != 0x80
		end
		
		function more_data_in_sei_payload() --> bool
			: if(isByteAlign(fifoIdx[0]) && (sei_payloadSize<<3) != sei_payloadPos) then false else true end
		end	

		function payload_extension_present() --> bool
			: if(show_bits(1, fifoContent, fifoIdx[0]) != 0x1 && (sei_payloadSize<<3) > sei_payloadPos) then true else false end
		end	

	    procedure skip_bytes(uint(size=32) numBytes)
	    begin
	    	while(numBytes > 0) do
	    		load_fifo();
	    		skip_bits(8, fifoIdx);
	    		numBytes := numBytes - 1;
	    	end
	    end
        
        /**************************************************************************
         **************************************************************************
         ********        NAL UNIT                             *********************
         **************************************************************************
         *************************************************************************/
        
        /**************************************************************************
         * search_start_code
         *************************************************************************/
        start_code.init: action ==>
        guard
        	isNewNal = 0
        do
        end
        
        start_code.done: action ==>
        guard
        	isNewNal > 0
        do
			fifoIdx[0] := 0;
			zeroByte := 0;
			countAEB := 0;
            if DEBUG_BITSTREAM then
            	println("start_code.done");
            end
        end
        /**************************************************************************
         * read_nal_unit_header
         *************************************************************************/
        uint(size=3) currentTID := 0;
        uint(size=3) targetTID  := 7;
        uint(size=3) decoderTID := 7;
        
        uint(size= 6) nal_unit_type;
		uint numPicDecoded := 0;

        read_nal_unit_header : action ==>
        var
        	uint(size=32) res[1]
        do
            load_fifo();
            if DEBUG_BITSTREAM then
            	println("=========== NAL_UNIT ===========");
            	//forbidden_zero_bit
				fifoIdx[0] := fifoIdx[0] - 1;
            	vld_u_name(6, fifoContent, fifoIdx, res,
            	"nal_unit_type                           ");
            	nal_unit_type := res[0];
            	//num_reserved_zero_6bits
				fifoIdx[0] := fifoIdx[0] - 6;
            	vld_u_name(3, fifoContent, fifoIdx, res,
            	"nuh_temporal_id_plus1                   ");
            	currentTID := res[0] - 1;
            else
				fifoIdx[0] := fifoIdx[0] - 1;
            	vld_u(6, fifoContent, fifoIdx, res);
            	nal_unit_type := res[0];
				fifoIdx[0] := fifoIdx[0] - 6;
            	vld_u(3, fifoContent, fifoIdx, res);
            	currentTID := res[0] - 1;
            end
            if(isVclNal(nal_unit_type)) then
	            numPicDecoded := numPicDecoded + 1;
			end
            se_idx := 1;
        end

        /**************************************************************************
         * look_for.VPS_header
         *************************************************************************/
        look_for.VPS_header: action ==>
        guard
        	nal_unit_type = NAL_VPS
        do
            if DEBUG_PARSER then
            	println("=========== Video Parameter Set ID:   ===========");
            end
        end
        /**************************************************************************
         * look_for.SEI_header
         *************************************************************************/
        look_for.SEI_header: action ==>
        guard
        	nal_unit_type = NAL_SEI_PREFIX or nal_unit_type = NAL_SEI_SUFFIX
        do
            if DEBUG_PARSER then
            	println("=========== SEI message ===========");
            end
        end
        /**************************************************************************
         * look_for.SPS_header
         *************************************************************************/
        look_for.SPS_header: action ==>
        guard
        	nal_unit_type = NAL_SPS
        do
            if DEBUG_PARSER then
            	println("=========== Sequence Parameter Set ID:   ===========");
            end
        end
        /**************************************************************************
         * look_for.PPS_header
         *************************************************************************/
        look_for.PPS_header: action ==>
        guard
       		nal_unit_type = NAL_PPS
        do
            if DEBUG_PARSER then
            	println("=========== Picture Parameter Set ID:   ===========");
            end
        end
        /**************************************************************************
         * look_for.Slice_header
         *************************************************************************/
		function getLastUserChar() --> uint(size=8) : 0 end

		uint(size=8) CHAR_0 = 0x30;
		uint(size=8) CHAR_7 = 0x37;
		uint(size=8) CHAR_PLUS = 0x2B;
		uint(size=8) CHAR_MINUS = 0x2D;
		procedure updateTargetTid()
		var
	   		uint(size=8) userChar
		begin
            userChar := getLastUserChar();
            //println("Character read : " + userChar);
            if(userChar >= CHAR_0 && userChar <= CHAR_7) then
            	targetTID := userChar - CHAR_0;
            	println("New targetTID : " + targetTID);
            elsif(userChar = CHAR_PLUS) then
            	targetTID := targetTID + 1;
            	if(targetTID > 7) then
            		targetTID := 7;
            	end
            	println("New targetTID : " + targetTID);
            elsif(userChar = CHAR_MINUS) then
            	if(targetTID > 0) then
            		targetTID := targetTID - 1;
            	end
            	println("New targetTID : " + targetTID);
            end
		end

		bool skipRASL  := true;
		bool noRaslOutput;
		bool skipTrailAndRADL := true;
	
        look_for.Slice_header: action ==>
        guard
	        isVclNal(nal_unit_type)
        do
            if DEBUG_PARSER then
            	println("=========== Slice ===========");
           end
           updateTargetTid();
            if isIRAP(nal_unit_type) then
            	//Skip RASL pictures after the first IRAP and after BLA picture.
            	skipRASL := skipTrailAndRADL || nal_unit_type = NAL_BLA_W_LP;
            	noRaslOutput := skipRASL;
            	skipTrailAndRADL := false;
            	
            elsif isTrailing(nal_unit_type) then
				noRaslOutput := false;
            	skipCurrentNal := skipTrailAndRADL;
            else
				noRaslOutput := false;
            	skipCurrentNal := skipTrailAndRADL ||
            		(skipRASL && nal_unit_type != NAL_RADL_N && nal_unit_type != NAL_RADL_R);
            	if(skipCurrentNal) then
										print("skippedNal :\t");
	            	printNalUnitType(nal_unit_type);
	            	println("");
            	end	
            end
//            printNalUnitType(nal_unit_type);
//            println("\t\tTid : " + currentTID);
            if(not skipCurrentNal) then
	            decoderTID := updateDecoderTid(nal_unit_type);
	            if(currentTID > decoderTID) then
	            	skipCurrentNal := true;
	            end
            end
        end
        /**************************************************************************
         * look_for_other_header
         *************************************************************************/
        look_for_other_header: action ==>
        end

		skipCurrentNal.isTrue: action ==>
		guard
			skipCurrentNal
		do
			println("\tNAL skipped");
			skipCurrentNal := false;
		end

        /**************************************************************************
         **************************************************************************
         ********        Video Parameter Set HEADER           *********************
         **************************************************************************
         *************************************************************************/
	    bool vps_base_layer_internal_flag;
	    uint(size= 6) vps_max_layers_minus1;
	    uint(size= 3) vps_max_sub_layers_minus1;
	    uint(size= 6) vps_max_nuh_reserved_zero_layer_id;
	    uint(size= 1) vps_timing_info_present_flag;
	    uint(size=10) vps_num_op_sets_minus1;
	    uint(size=10) vps_num_hrd_parameters;
	    uint(size= 5) vps_profile_idc := 1;
		uint(size= 8) video_sequence_id := 0;

	    bool vps_sub_layer_profile_present_flag[32] := [false: for int i in 0 .. 31];
	    bool vps_sub_layer_level_present_flag[32] := [false: for int i in 0 .. 31];
		
	    /**************************************************************************
	     * parse_vps_ptl
	     *************************************************************************/
		procedure parse_vps_ptl(bool profilePresentFlag)
		var
			uint(size=32) res[1]
		begin
	        load_fifo();
	        if(profilePresentFlag) then
	        	skip_bits_name( 2, fifoIdx, "general_profile_space                   			");
	        	skip_bits_name( 1, fifoIdx, "general_tier_flag                       			");
	        	vld_u_name(5, fifoContent, fifoIdx, res, "general_profile_idc                   ");
	        	vps_profile_idc := res[0] & 32; // 32 = 2^5
	        	skip_bits_name(32, fifoIdx, "general_profile_compatibility_flag[i]	 			");
	
	        	skip_bits_name( 1, fifoIdx, "general_progressive_source_flag         			");
	        	skip_bits_name( 1, fifoIdx, "general_interlaced_source_flag          			");
	        	skip_bits_name( 1, fifoIdx, "general_non_packed_constraint_flag      			");
	        	skip_bits_name( 1, fifoIdx, "general_frame_only_constraint_flag      			");
	
		        load_fifo();
	            skip_bits_name(44, fifoIdx, "general_reserved_zero_44bits            			");
	        end

	        skip_bits_name( 8, fifoIdx, "general_level_idc										");
			foreach int cnt_i in 0 .. (vps_max_sub_layers_minus1-1) do
			    load_fifo();
				res[0] := 0;
		    	vld_u_name(1, fifoContent, fifoIdx, res, "sub_layer_profile_present_flag[i]		");
			    vps_sub_layer_profile_present_flag[cnt_i] := (res[0] = 1);
			    vld_u_name(1, fifoContent, fifoIdx, res, "sub_layer_level_present_flag[i]		");
			    vps_sub_layer_level_present_flag[cnt_i] := (res[0] = 1);
			end
			
			load_fifo();
			if(vps_max_sub_layers_minus1 > 0) then
				skip_bits_name(2 * (7 - vps_max_sub_layers_minus1 + 1), fifoIdx, "reserved_zero_2bits[i]      ");
			end
			
	        foreach int cnt_i in 0 .. (vps_max_sub_layers_minus1-1) do
			    load_fifo();
				if (vps_sub_layer_profile_present_flag[cnt_i]) then
			        skip_bits_name( 2, fifoIdx, "sub_layer_profile_space[i]              ");
			        skip_bits_name( 1, fifoIdx, "sub_layer_tier_flag[i]                  ");
			        skip_bits_name( 5, fifoIdx, "sub_layer_profile_idc[i]                ");
		            skip_bits_name(32, fifoIdx, "sub_layer_profile_compatibility_flags[i]");

		        	skip_bits_name( 1, fifoIdx, "sub_layer_progressive_source_flag       ");
		        	skip_bits_name( 1, fifoIdx, "sub_layer_interlaced_source_flag        ");
		        	skip_bits_name( 1, fifoIdx, "sub_layer_non_packed_constraint_flag    ");
		        	skip_bits_name( 1, fifoIdx, "sub_layer_frame_only_constraint_flag    ");
		
			        load_fifo();
		            skip_bits_name(44, fifoIdx, "sub_layer_reserved_zero_44bits          ");
			    end
			    if (sps_sub_layer_level_present_flag[cnt_i]) then
			        skip_bits_name( 8, fifoIdx, "sub_layer_level_idc[i]                  ");
			    end
			end
		end

	    /**************************************************************************
	     * parse_vps_hrd
	     *************************************************************************/
		procedure parse_vps_hrd(int(size=32) hrdIdx, bool commonInfPresentFlag)
		var
			uint(size=32) ures[1],
			uint(size=32) maxNumSubLayersMinus1 := vps_max_sub_layers_minus1,
			// TODO: store decoded params for every hrdIdx.
			bool vps_nal_hrd_parameters_present_flag,
			bool vps_vcl_hrd_parameters_present_flag,
			bool vps_hrd_sub_pic_cpb_params_present_flag,
			bool vps_hrd_fixed_pic_rate_within_cvs_flag[32],
			bool vps_hrd_low_delay_hrd_flag[32],
			uint(size=32) vps_hrd_cpb_cnt_minus1[32]
		begin
			if(commonInfPresentFlag) then
				load_fifo();
		        vld_u_name(1, fifoContent, fifoIdx, ures, "nal_hrd_parameters_present_flag             	");
		        vps_nal_hrd_parameters_present_flag := if(ures[0] = 1) then true else false end;
		        vld_u_name(1, fifoContent, fifoIdx, ures, "vcl_hrd_parameters_present_flag             	");
		        vps_vcl_hrd_parameters_present_flag := if(ures[0] = 1) then true else false end;
		        if(vps_nal_hrd_parameters_present_flag or vps_vcl_hrd_parameters_present_flag) then
		        	vld_u_name(1, fifoContent, fifoIdx, ures, "sub_pic_cpb_params_present_flag        	");
		        	vps_hrd_sub_pic_cpb_params_present_flag := if(ures[0] = 1) then true else false end;
		        	if(ures[0] = 1) then
		        		skip_bits_name( 8, fifoIdx, "tick_divisor_minus2                  				");
		        		skip_bits_name( 5, fifoIdx, "du_cpb_removal_delay_length_minus1         		");
		        		skip_bits_name( 1, fifoIdx, "sub_pic_cpb_params_in_pic_timing_sei_flag        	");
		        		skip_bits_name( 5, fifoIdx, "dpb_output_delay_du_length_minus1           		");
		        	end
		        	skip_bits_name( 4, fifoIdx, "bit_rate_scale           								");
		        	skip_bits_name( 4, fifoIdx, "cpb_size_scale           								");
		        	if(ures[0] != 0) then
		        		skip_bits_name( 4, fifoIdx, "cpb_size_du_scale                  				");
		        	end
		        	// TODO Note: Default values for following three is 23 not zero.
	        		skip_bits_name( 5, fifoIdx, "initial_cpb_removal_delay_length_minus1         		");
	        		skip_bits_name( 5, fifoIdx, "au_cpb_removal_delay_length_minus1        				");
	        		skip_bits_name( 5, fifoIdx, "dpb_output_delay_length_minus1           				");
		        end
		   end
		   
		   foreach int i in 0 .. maxNumSubLayersMinus1 do
		   		load_fifo();
		        vld_u_name(1, fifoContent, fifoIdx, ures, "fixed_pic_rate_general_flag             		");
		        if(ures[0] = 0) then
		        	vld_u_name(1, fifoContent, fifoIdx, ures, "fixed_pic_rate_within_cvs_flag        	");
		        	vps_hrd_fixed_pic_rate_within_cvs_flag[i] := if(ures[0] = 1) then true else false end;
		        else
		        	vps_hrd_fixed_pic_rate_within_cvs_flag[i] := true;
		        end
		        
		        vps_hrd_low_delay_hrd_flag[i]	:= false;	// By default, set to false.
		        vps_hrd_cpb_cnt_minus1[i] 		:= 0;		// By default, set to 0.
		        if(vps_hrd_low_delay_hrd_flag[i]) then
		        	vld_ue_name(fifoContent, fifoIdx, ures, "elemental_duration_in_tc_minus1        	");
		        else
		        	vld_u_name( 1, fifoContent, fifoIdx, ures, "low_delay_hrd_flag        				");
		        	vps_hrd_low_delay_hrd_flag[i] := if(ures[0] = 1) then true else false end;
		        end
		        if(not vps_hrd_low_delay_hrd_flag[i]) then
		        	vld_ue_name(fifoContent, fifoIdx, ures, "cpb_cnt_minus1        						");
		        	vps_hrd_cpb_cnt_minus1[i] := ures[0];
		        end
		   		
		   		load_fifo();
		   		foreach int nalOrVcl in 0 .. 1 do
		   			if( (nalOrVcl = 0 and vps_nal_hrd_parameters_present_flag) ||
		   				(nalOrVcl = 1 and vps_vcl_hrd_parameters_present_flag) ) then
		   				foreach int j in 0 .. vps_hrd_cpb_cnt_minus1[i] do
		   					vld_ue_name(fifoContent, fifoIdx, ures, "bit_rate_value_minus1        		");
		   					vld_ue_name(fifoContent, fifoIdx, ures, "cpb_size_value_minus1        		");
		   					if(vps_hrd_sub_pic_cpb_params_present_flag) then
			   					vld_ue_name(fifoContent, fifoIdx, ures, "cpb_size_du_value_minus1       ");
			   					vld_ue_name(fifoContent, fifoIdx, ures, "bit_rate_du_value_minus1       ");		   						
		   					end
		   					vld_u_name(1, fifoContent, fifoIdx, ures, "cbr_flag             			");
		   				end
		   			end
		   		end
			end
		end

	    /**************************************************************************
	     * parse_vps_extension
	     *************************************************************************/
		procedure parse_vps_extension()
		var
			uint(size=32) res[1]
		begin
			load_fifo();
			while(not isByteAlign(fifoIdx[0])) do
				load_fifo();
				vld_u_name(1, fifoContent, fifoIdx, res, "vps_extension_alignment_bit_equal_to_one		");
			end
			
			parse_vps_multilayer_extension();
			
			vld_u_name(1, fifoContent, fifoIdx, res, "vps_extension2_flag								");
			if(res[0] != 0) then
				vld_u_name(1, fifoContent, fifoIdx, res, "vps_3d_extension_flag							");
				if(res[0] != 0) then
					while(not isByteAlign(fifoIdx[0])) do
						load_fifo();
						vld_u_name(1, fifoContent, fifoIdx, res, "vps_3d_extension_alignment_bit_equal_to_one");
					end
					// vps_3d_extension(); TODO
				end

				vld_u_name(1, fifoContent, fifoIdx, res, "vps_extension3_flag							");
				if(res[0] != 0) then
					while(more_rbsp_data()) do
						load_fifo();
						vld_u_name(1, fifoContent, fifoIdx, res, "vps_extension_data_flag				");
					end
				end
			end
	    end
	    
	    procedure parse_vps_multilayer_extension()
	    var
	    	uint(size=32) res[1],
	    	uint(size= 1) splitting_flag,
	    	bool vps_nuh_layer_id_present_flag,
	    	uint(size=16) num_add_layer_sets,

	    	uint(size=16) NumScalabilityTypes := 0,
	    	uint(size=16) NumViews := 0,			// TODO calculate/initialize?
	    	uint(size=16) NumIndependentLayers := 0 // TODO calculate/initialize?
	    begin
			if(vps_max_layers_minus1 > 0 && vps_base_layer_internal_flag) then
				parse_vps_ptl(false);
			end
			
			load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, res, "splitting_flag									");
			splitting_flag := res[0];
			
			foreach int i in 0 .. 15 do
				vld_u_name(1, fifoContent, fifoIdx, res, "scalability_mask_flag[i]						");
				NumScalabilityTypes := NumScalabilityTypes + res[0];
			end
			
			foreach int j in 0 .. (NumScalabilityTypes - splitting_flag) do
				load_fifo();
				vld_u_name(3, fifoContent, fifoIdx, res, "dimension_id_len_minus1[j]					");
			end
			
			vld_u_name(1, fifoContent, fifoIdx, res, "vps_nuh_layer_id_present_flag						");
			vps_nuh_layer_id_present_flag := if(res[0] != 0) then true else false end;
			
			foreach int i in 1 .. vps_max_layers_minus1 do
				if(vps_nuh_layer_id_present_flag) then
					vld_u_name(6, fifoContent, fifoIdx, res, "layer_id_in_nuh[i]						");
				end
				if(splitting_flag != 0) then
					foreach int j in 0 .. (NumScalabilityTypes-1) do
						vld_ue_name(fifoContent, fifoIdx, res, "dimension_id[i][j]       				");
					end
				end
			end
			
			vld_u_name(4, fifoContent, fifoIdx, res, "view_id_len										");
			if(res[0] > 0) then
				load_fifo();
				foreach int i in 0 .. NumViews-1 do
					vld_ue_name(fifoContent, fifoIdx, res, "view_id_val[i]       						"); 
				end
			end
			
			foreach int i in 1 .. vps_max_layers_minus1 do
				foreach int j in 0 .. i do
					load_fifo();
					vld_u_name(1, fifoContent, fifoIdx, res, "direct_dependency_flag[i][j]       		");
				end
			end
			
			load_fifo();
			if(NumIndependentLayers > 1) then
				vld_ue_name(fifoContent, fifoIdx, res, "num_add_layer_sets       						");
				num_add_layer_sets := res[0];
			end
			
			foreach int i in 0 .. num_add_layer_sets-1 do
				foreach int j in 1 .. NumIndependentLayers-1 do
					load_fifo();
					vld_ue_name(fifoContent, fifoIdx, res, "highest_layer_idx_plus1[i][j]       		");
				end 
			end
			
			vld_u_name(1, fifoContent, fifoIdx, res, "vps_sub_layers_max_minus1_present_flag			");
			if(res[0] != 0) then
				load_fifo();
				foreach int i in 0 .. vps_max_layers_minus1-1 do
					vld_u_name(3, fifoContent, fifoIdx, res, "sub_layers_vps_max_minus1[i]       		"); 
				end
			end
			
	    end	

        /**************************************************************************
         * read_VPS_Header
         *************************************************************************/
        read_VPS_Header: action ==>
        var
        	uint(size=32) res[1],
        	int startIdx,
        	int endIdx,
        	uint(size= 1) cprms_present_flag := 0
        do
            load_fifo();
        	video_sequence_id := video_sequence_id + 1;
            vld_u_name(4, fifoContent, fifoIdx, res, "vps_video_parameter_set_id				");
            vld_u_name(1, fifoContent, fifoIdx, res, "vps_base_layer_internal_flag				");
            vps_base_layer_internal_flag := if (res[0] != 0) then true else false end;
            vld_u_name(1, fifoContent, fifoIdx, res, "vps_base_layer_available_flag				");
            vld_u_name(6, fifoContent, fifoIdx, res, "vps_max_layers_minus1						");
            vps_max_layers_minus1 := res[0];
            vld_u_name(3, fifoContent, fifoIdx, res, "vps_max_sub_layers_minus1					");
	        vps_max_sub_layers_minus1 := res[0];
	        if(vps_max_sub_layers_minus1+1 > decoderTID) then
	        	println("ERROR: vps_max_sub_layers_minus1+1 > decoderTID");
	        end
	        vld_u_name(1, fifoContent, fifoIdx, res, "vps_temporal_id_nesting_flag				");
	        vld_u_name(16, fifoContent, fifoIdx, res, "vps_reserved_ffff_16bits					");

			parse_vps_ptl(true);

	        load_fifo();
	        vld_u_name(1, fifoContent, fifoIdx, res, "vps_sub_layer_ordering_info_present_flag	");
	        if res[0] = 1 then
	            startIdx  := 0;
	        else
	            startIdx  := vps_max_sub_layers_minus1;
	        end

	        foreach int cnt_i in startIdx .. vps_max_sub_layers_minus1 do
		        load_fifo();
		        vld_ue_name(fifoContent, fifoIdx, res, "vps_max_dec_pic_buffering[i]            ");
		        vld_ue_name(fifoContent, fifoIdx, res, "vps_num_reorder_pics[i]                 ");
		        vld_ue_name(fifoContent, fifoIdx, res, "vps_max_latency_increase_plus1[i]		");
	    	end
	    	
	        load_fifo();
	        vld_u_name(6, fifoContent, fifoIdx, res, "vps_max_nuh_reserved_zero_layer_id		");
	        vps_max_nuh_reserved_zero_layer_id := res[0];
	        vld_ue_name(fifoContent, fifoIdx, res, "vps_max_op_sets_minus1						");
	        vps_num_op_sets_minus1 := res[0];
	        
	        startIdx  := 1;
	        endIdx  := vps_num_op_sets_minus1 + 1; // TODO : bypass layer_id_included_flag()
	        foreach int cnt_i in startIdx .. endIdx do
		        load_fifo();
		        foreach int(size=8) i in 0 .. vps_max_nuh_reserved_zero_layer_id - 1 do
		            vld_u_name(1, fifoContent, fifoIdx, res, "layer_id_included_flag[][i]		");
		        end
		    end

	        load_fifo();
	        vld_u_name(1, fifoContent, fifoIdx, res, "vps_timing_info_present_flag				");
	        vps_timing_info_present_flag := res[0];
	        if vps_timing_info_present_flag = 1 then
		        load_fifo();
		        skip_bits_name(32, fifoIdx, "vps_num_units_in_tick								");
		        load_fifo();
		        skip_bits_name(32, fifoIdx, "vps_time_scale										");
		        
		        load_fifo();
		        vld_u_name(1, fifoContent, fifoIdx, res, "vps_poc_proportional_to_timing_flag   ");
		        if res[0] = 1 then
		            vld_ue_name(fifoContent, fifoIdx, res, "vps_num_ticks_poc_diff_one_minus1   ");
		        end
		        vld_ue_name(fifoContent, fifoIdx, res, "vps_num_hrd_parameters                  ");
		        vps_num_hrd_parameters := res[0];
		        
		        foreach int cnt_i in 0 .. (vps_num_hrd_parameters-1) do
			        load_fifo();
			        cprms_present_flag := 1;
			        vld_ue_name(fifoContent, fifoIdx, res, "hrd_op_set_idx[i]					");
			        if cnt_i > 0 then
			            vld_u_name(1, fifoContent, fifoIdx, res, "cprms_present_flag[i]			");
			            cprms_present_flag := res[0];
			        end			        
					parse_vps_hrd(cnt_i, if cprms_present_flag = 1 then true else false end);			        
		        end
	        end

	        load_fifo();
	        vld_u_name(1, fifoContent, fifoIdx, res, "vps_extension_flag						");
	        if res[0] = 1 then
	        	parse_vps_extension();
	        end
	    end

		/**************************************************************************
		 **************************************************************************
		 ********        SEI message                          *********************
		 **************************************************************************
		 *************************************************************************/
		bool         need_md5 := false;
		bool         md5_needed := false;
		/**************************************************************************
		 * read_SEI_Header
		 *************************************************************************/
	    uint(size=16) sei_payloadType;
	    uint(size=16) sei_payloadSize;
	    uint(size=16) sei_payloadPos;

	    int(size= 8) sei_hashType;
	    uint(size=8) sei_hash[3][17];

	    read_SEI_Header.start: action ==>
	    guard se_idx = 1
		do
	        sei_payloadType     := 0;
	        sei_payloadSize     := 0;
	        sei_payloadPos		:= 0;
	        sei_hashType		:= -1;
	        	        
			parse_sei_payload();

			if(need_md5 and (sei_payloadType = 256 || sei_payloadType = 132)) then
				se_idx := 2;
			else
				se_idx := 3;
			end
	    end	    

	    read_SEI_Header.md5: action ==> SEI_MD5:[[sei_hash[i][j]: for int i in 0 .. 2, for int j in 0 .. 16]] repeat 3 * 17
	    guard se_idx = 2 and sei_hashType = 0 
	    do
	    	se_idx := 3;
	    	need_md5 := false;
	    	
	    	nbTokensPerSH[11] := nbTokensPerSH[11] + 3 * 17; // SEI_MD5	    	
	    end

	    read_SEI_Header.crc: action ==>
	    guard se_idx = 2 and sei_hashType = 1 
	    do
	    	se_idx := 3;	    	
	    end

	    read_SEI_Header.checksum: action ==>
	    guard se_idx = 2 and sei_hashType = 2 
	    do
	    	se_idx := 3;	    	
	    end
	    
	    read_SEI_Header_done: action ==>
	    guard 
	    	se_idx = 3
	    do
	    	se_idx := 4;
	    end
	    
		procedure parse_sei_payload()
	    var
	    	uint(size=32) res[1] := [0xFF]
		begin
	        load_fifo();
	        while(res[0] = 0xFF) do
	        	load_fifo();
	        	vld_u_name(8, fifoContent, fifoIdx, res, "payload_type							");
	        	sei_payloadType := sei_payloadType + res[0];
	        end	
	        res[0] := 0xFF;
	        while(res[0] = 0xFF) do
	        	load_fifo();
	        	vld_u_name(8, fifoContent, fifoIdx, res, "payload_size							");
	        	sei_payloadSize := sei_payloadSize + res[0];
	        end
	        
	        if(nal_unit_type = NAL_SEI_PREFIX) then
	        	if(sei_payloadType = 256) then
	        		parse_picture_hash();
	        	else
	        		println("Skipped PREFIX SEI "+sei_payloadType);
	        		skip_bytes(sei_payloadSize);
	        	end	
	        else // nal_unit_type = NAL_SEI_PREFIX
	        	if(sei_payloadType = 132) then
	        		parse_picture_hash();
	        	else
	        		println("Skipped SUFFIX SEI "+sei_payloadType);
	        		skip_bytes(sei_payloadSize);
	        	end
	        end
	        
	        load_fifo();
			if(more_data_in_sei_payload()) then
 				if(payload_extension_present()) then
 					vld_ue_name(fifoContent, fifoIdx, res, "reserved_payload_extension_data		");
 				end
 				
 				skip_bits_name( 1, fifoIdx, "payload_one_bit_equal_to_one						");
 				while(not isByteAlign(fifoIdx[0])) do
 					skip_bits_name( 1, fifoIdx, "payload_one_bit_equal_to_zero					");
 				end
			end
		end

	    procedure parse_picture_hash()
	    var
	    	uint(size=32) res[1]
	    begin
	    	load_fifo();
	    	vld_u_name(8, fifoContent, fifoIdx, res, "hash_type									");
	    	sei_payloadPos := sei_payloadPos + 8;
	    	sei_hashType := res[0];

	    	foreach int cIdx in 0 .. 2 do
	    		load_fifo();
	    		sei_hash[cIdx][0] := 1; 	// Send 1 signaling enabling of SEI hash for each component
	    		if(sei_hashType = 0) then
	    			foreach int j in 1 .. 16 do
	    				load_fifo();
	    				vld_u_name(  8, fifoContent, fifoIdx, res, "picture_md5					");
	    				sei_hash[cIdx][j] := res[0];
	    			end
	    		elsif(sei_hashType = 1) then
	    			println("Picture CRC is not yet supported"); 		// TODO
	    			skip_bits(16, fifoIdx);
	    			sei_payloadPos := sei_payloadPos + 16;
	    		elsif(sei_hashType = 2) then
	    			println("Picture checksum is not yet supported");	// TODO
	    			skip_bits(32, fifoIdx);
	    			sei_payloadPos := sei_payloadPos + 32;
	    		end
	    	end
	    end
	    /**************************************************************************
	     **************************************************************************
	     ********        Sequence Parameter Set HEADER        *********************
	     **************************************************************************
	     *************************************************************************/
		bool sps_id_decoded[16] := [false : for int i in 0 .. 15];
	    uint(size= 4) sps_max_sub_layers_minus1[NB_MAX_SPS];
	    uint(size=16) sps_pic_width_in_luma_samples[NB_MAX_SPS];
		uint(size=16) sps_pic_height_in_luma_samples[NB_MAX_SPS];
		uint(size= 1) sps_separate_colour_plane_flag[NB_MAX_SPS];
	    uint(size= 2) sps_chroma_format_idc[NB_MAX_SPS];
	    uint(size= 5) sps_profile_idc[NB_MAX_SPS];
	
	    bool sps_profile_present_flag := true;
	    bool sps_sub_layer_level_present_flag[64] := [false: for int i in 0 .. 63];
	    bool sps_sub_layer_profile_present_flag[64] := [false: for int i in 0 .. 63];

	    uint(size= 8) sps_log2_max_pic_order_cnt_lsb_minus4[NB_MAX_SPS];
	    uint(size=32) max_poc_lsb[NB_MAX_SPS];
	    int sps_bit_depth_luma[NB_MAX_SPS];
	    int sps_bit_depth_chroma[NB_MAX_SPS];
	    int sps_bit_depth_minus5[NB_MAX_SPS][3];

		bool sps_sub_layer_ordering_info_present_flag;
		//!TODO: Should be sps...[NB_MAX_SPS][NB_MAX_TEMPORAL_LAYER] with NB_MAX_TEMPORAL_LAYER = 8
		uint sps_max_dec_pic_buffering[NB_MAX_SPS];
		uint sps_num_reorder_pics[NB_MAX_SPS];
		uint sps_max_latency_pict[NB_MAX_SPS];

	    uint(size= 8) sps_log2_min_coding_block_size[NB_MAX_SPS];
	    uint(size= 8) sps_log2_min_pu_size[NB_MAX_SPS];
	    uint(size= 8) sps_min_pu_width[NB_MAX_SPS];
	    uint(size= 8) sps_log2_diff_max_min_coding_block_size[NB_MAX_SPS];
	    uint(size= 8) sps_log2_min_transform_block_size[NB_MAX_SPS];
	    uint(size= 8) sps_log2_diff_max_min_transform_block_size[NB_MAX_SPS];
	    //uint(size=16) sps_maxCUWidth[NB_MAX_SPS];

	    uint(size= 8) sps_max_transform_hierarchy_depth_inter[NB_MAX_SPS];
	    uint(size= 8) sps_max_transform_hierarchy_depth_intra[NB_MAX_SPS];
	    uint(size= 1) sps_scaling_list_enabled_flag[NB_MAX_SPS];
	    uint(size=16) sps_ctb_width[NB_MAX_SPS];
	    uint(size=16) sps_ctb_height[NB_MAX_SPS];
	    uint(size=16) sps_log2_ctb_size[NB_MAX_SPS];
	    int(size=32) min_cb_width;

	    uint(size= 1) sps_sample_adaptive_offset_enabled_flag[NB_MAX_SPS];
	    uint(size= 8) sps_num_short_term_ref_pic_sets[NB_MAX_SPS];
	    uint(size= 1) sps_pcm_enabled_flag[NB_MAX_SPS];
	    uint(size= 1) amp_enabled_flag;
	    uint(size= 8) sps_sl[NB_MAX_SPS][4][6][64];
	    uint(size= 8) sps_sl_dc[NB_MAX_SPS][2][6];

		uint log2_min_pcm_cb_size[NB_MAX_SPS];
		uint log2_max_pcm_cb_size[NB_MAX_SPS];
		uint pcm_bit_depth_luma[NB_MAX_SPS];
		uint pcm_bit_depth_chroma[NB_MAX_SPS];
		uint pcm_loop_filter_disable_flag[NB_MAX_SPS];

	    int(size=8) pcRPS[NB_MAX_SPS][NB_MAX_PICS+1][PC_RPS_STRUCT_SIZE];

	    uint(size= 1) sps_long_term_ref_pics_present_flag[NB_MAX_SPS];
	    uint(size= 1) sps_temporal_mvp_enable_flag[NB_MAX_SPS];
	    bool          sps_strong_intra_smoothing_enable_flag[NB_MAX_SPS];
	    uint(size= 6) sps_num_long_term_ref_pics_sps[NB_MAX_SPS];
	    uint(size=16) lt_ref_pic_poc_lsb_sps[32];
	    uint(size= 8) used_by_curr_pic_lt_sps_flag[32];	

	    /**************************************************************************
	     * parse_sps_ptl
	     *************************************************************************/
		procedure parse_sps_ptl()
		var
			uint(size=32) res[1]
		begin
	        load_fifo();
        	skip_bits_name( 2, fifoIdx, "general_profile_space                   ");
        	skip_bits_name( 1, fifoIdx, "general_tier_flag                       ");
        	vld_u_name(5, fifoContent, fifoIdx, res, "general_profile_idc        ");
        	sps_profile_idc[sps_id] := res[0] & 32; // 32 = 2^5
        	skip_bits_name(32, fifoIdx, "general_profile_compatibility_flag[i]	 ");

        	skip_bits_name( 1, fifoIdx, "general_progressive_source_flag         ");
        	skip_bits_name( 1, fifoIdx, "general_interlaced_source_flag          ");
        	skip_bits_name( 1, fifoIdx, "general_non_packed_constraint_flag      ");
        	skip_bits_name( 1, fifoIdx, "general_frame_only_constraint_flag      ");

	        load_fifo();
            skip_bits_name(44, fifoIdx, "general_reserved_zero_44bits            ");
	        skip_bits_name( 8, fifoIdx, "general_level_idc                       ");
	        
			foreach int cnt_i in 0 .. (sps_max_sub_layers_minus1[sps_id]-1) do
			    load_fifo();
				res[0] := 0;
		    	vld_u_name(1, fifoContent, fifoIdx, res, "sub_layer_profile_present_flag[i]   ");
			    sps_sub_layer_profile_present_flag[cnt_i] := (res[0] = 1);
			    vld_u_name(1, fifoContent, fifoIdx, res, "sub_layer_level_present_flag[i]     ");
			    sps_sub_layer_level_present_flag[cnt_i] := (res[0] = 1);
			end

			load_fifo();
			if(sps_max_sub_layers_minus1[sps_id] > 0) then
				skip_bits_name(2 * (7 - sps_max_sub_layers_minus1[sps_id] + 1), fifoIdx, "reserved_zero_2bits[i]      ");
			end
			
	        foreach int cnt_i in 0 .. (sps_max_sub_layers_minus1[sps_id]-1) do
			    load_fifo();
				if (sps_sub_layer_profile_present_flag[cnt_i]) then
			        skip_bits_name( 2, fifoIdx, "sub_layer_profile_space[i]              ");
			        skip_bits_name( 1, fifoIdx, "sub_layer_tier_flag[i]                  ");
			        skip_bits_name( 5, fifoIdx, "sub_layer_profile_idc[i]                ");
		            skip_bits_name(32, fifoIdx, "sub_layer_profile_compatibility_flags[i]");

		        	skip_bits_name( 1, fifoIdx, "sub_layer_progressive_source_flag       ");
		        	skip_bits_name( 1, fifoIdx, "sub_layer_interlaced_source_flag        ");
		        	skip_bits_name( 1, fifoIdx, "sub_layer_non_packed_constraint_flag    ");
		        	skip_bits_name( 1, fifoIdx, "sub_layer_frame_only_constraint_flag    ");
		
			        load_fifo();
		            skip_bits_name(44, fifoIdx, "sub_layer_reserved_zero_44bits          ");
			    end
			    if (sps_sub_layer_level_present_flag[cnt_i]) then
			        skip_bits_name( 8, fifoIdx, "sub_layer_level_idc[i]                  ");
			    end
			end
		end
			
	    /**************************************************************************
	     * parse_sps_scaling_list_data
	     *************************************************************************/
		procedure parse_sps_scaling_list_data() 
		var
            int(size=32) ires[1],
            uint(size=32) ures[1],

			int matrixEndMinus1,
	        int sizeIdMemCpyCase,
            int delta,
	        int coefNum,
	        int nextCoef,
	        int nextCoefPos
		begin
	        load_fifo();
			foreach int matrixId in 0 .. 5 do // 4x4 default is 16
	        	foreach int i in 0 .. 15 do
	        		sps_sl[sps_id][0][matrixId][i] := 16;
	        	end
	        	sps_sl_dc[sps_id][0][matrixId] := 16; // default for 16x16
	        	sps_sl_dc[sps_id][1][matrixId] := 16; // default for 32x32
	        end
	        foreach int i in 0 .. 63 do
	        	sps_sl[sps_id][1][0][i] := default_scaling_list_intra[i];
	        	sps_sl[sps_id][1][1][i] := default_scaling_list_intra[i];
	        	sps_sl[sps_id][1][2][i] := default_scaling_list_intra[i];
	        	sps_sl[sps_id][1][3][i] := default_scaling_list_inter[i];
	        	sps_sl[sps_id][1][4][i] := default_scaling_list_inter[i];
	        	sps_sl[sps_id][1][5][i] := default_scaling_list_inter[i];
	        	sps_sl[sps_id][2][0][i] := default_scaling_list_intra[i];
	        	sps_sl[sps_id][2][1][i] := default_scaling_list_intra[i];
	        	sps_sl[sps_id][2][2][i] := default_scaling_list_intra[i];
	        	sps_sl[sps_id][2][3][i] := default_scaling_list_inter[i];
	        	sps_sl[sps_id][2][4][i] := default_scaling_list_inter[i];
	        	sps_sl[sps_id][2][5][i] := default_scaling_list_inter[i];
	        	sps_sl[sps_id][3][0][i] := default_scaling_list_intra[i];
	        	sps_sl[sps_id][3][1][i] := default_scaling_list_inter[i];
	        end
	        vld_u_name(1, fifoContent, fifoIdx, ures, "sps_scaling_list_data_present_flag      ");
	        
	        if ures[0] = 1 then
				foreach int sizeId in 0 .. 3 do
					if sizeId = 3 then matrixEndMinus1 := 1; else matrixEndMinus1 := 5; end
					foreach int matrixId in 0 .. matrixEndMinus1 do
					    load_fifo();
						vld_u_name(1, fifoContent, fifoIdx, ures, "scaling_list_pred_mode_flag             ");
	
					    if ures[0] = 0 then
					    	vld_ue_name(fifoContent, fifoIdx, ures, "delta                                   ");
					    	delta := ures[0]; // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
					    	if delta != 0 then // Copy from previous array.
					    		if (matrixId - delta < 0) then
					    			println("Invalid delta in scaling list data");
					    		end
					    		if sizeId > 0 then
					    			sizeIdMemCpyCase := 64;
					    		else
					    			sizeIdMemCpyCase := 16;
					    		end
					    		foreach int k in 0 .. sizeIdMemCpyCase - 1 do
					    			sps_sl[sps_id][sizeId][matrixId][k] :=
					    			sps_sl[sps_id][sizeId][matrixId - delta][k];
					    		end
					    		if (sizeId > 1) then
					    			sps_sl_dc[sps_id][sizeId - 2][matrixId] :=
					    			sps_sl_dc[sps_id][sizeId - 2][matrixId - delta];
					    		end
					    	end
					    else
					    	nextCoef := 8;
					    	coefNum := min(64, (1 << (4 + (sizeId << 1))));
					    	if (sizeId > 1) then
					    		vld_se_name(fifoContent, fifoIdx, ires, "scaling_list_dc_coef                    ");
					    		nextCoef := ires[0] + 8;
					    		sps_sl_dc[sps_id][sizeId - 2][matrixId] := nextCoef;
					    	end
					    	
					    	foreach int i in 0 .. (coefNum-1) do
					    		load_fifo();
					    		vld_se_name(fifoContent, fifoIdx, ires, "scaling_list_delta_coef                 ");
					    		nextCoef := (nextCoef + ires[0]+ 256) & 255;
	
								if (sizeId = 0) then
							        nextCoefPos := 4 * hevc_diag_scan4x4_y[i] + hevc_diag_scan4x4_x[i];
							    else
							        nextCoefPos := 8 * hevc_diag_scan8x8_y[i] + hevc_diag_scan8x8_x[i];
							    end
					    		sps_sl[sps_id][sizeId][matrixId][nextCoefPos] := nextCoef;
					    	end
					    end
					end
				end
				
			    if sps_chroma_format_idc[sps_id] = 3 then 
					foreach int i in 0 .. 63 do
			            sps_sl[sps_id][3][1][i] := sps_sl[sps_id][2][1][i];
			            sps_sl[sps_id][3][2][i] := sps_sl[sps_id][2][2][i];
			            sps_sl[sps_id][3][4][i] := sps_sl[sps_id][2][4][i];
			            sps_sl[sps_id][3][5][i] := sps_sl[sps_id][2][5][i];
			        end
			        sps_sl_dc[sps_id][1][1] := sps_sl_dc[sps_id][0][1];
			        sps_sl_dc[sps_id][1][2] := sps_sl_dc[sps_id][0][2];
			        sps_sl_dc[sps_id][1][4] := sps_sl_dc[sps_id][0][4];
			        sps_sl_dc[sps_id][1][5] := sps_sl_dc[sps_id][0][5];
			    end	        	
	        end
		end

	    /**************************************************************************
	     * parse_sps_vui
	     *************************************************************************/
		procedure parse_sps_vui()
		var
			uint(size=32) ures[1]
		begin
			load_fifo();
	        vld_u_name(1, fifoContent, fifoIdx, ures, "aspect_ratio_info_present_flag             	");
	        if(ures[0] = 1) then
	        	vld_u_name(8, fifoContent, fifoIdx, ures, "aspect_ratio_idc              		  	");
	        	if(ures[0] = 255) then
	        		skip_bits_name(16, fifoIdx, "sar_width                  					  	");
	        		skip_bits_name(16, fifoIdx, "sar_width                  					  	");
	        	end	
	        end

	        vld_u_name(1, fifoContent, fifoIdx, ures, "overscan_info_present_flag              	  	");
	        if(ures[0] = 1) then
	        	skip_bits_name( 1, fifoIdx, "overscan_appropriate_flag		  						");
	        end
	        
	        load_fifo();
	        vld_u_name(1, fifoContent, fifoIdx, ures, "video_signal_type_present_flag             	");
	        if(ures[0] = 1) then
	        	skip_bits_name(3, fifoIdx, "video_format		   				  					");
	        	skip_bits_name(1, fifoIdx, "video_full_range_flag		   	  						");
	        	vld_u_name(1, fifoContent, fifoIdx, ures, "colour_description_present_flag        	");
	        	if(ures[0] = 1) then
	        		skip_bits_name( 8, fifoIdx, "colour_primaries                  				  	");
	        		skip_bits_name( 8, fifoIdx, "transfer_characteristics                  		  	");
	        		skip_bits_name( 8, fifoIdx, "matrix_coefficients           					  	");
	        	end	
	        end

	        vld_u_name(1, fifoContent, fifoIdx, ures, "chroma_loc_info_present_flag            	  	");
	        if(ures[0] = 1) then
	        	vld_ue_name(fifoContent, fifoIdx, ures, "chroma_sample_loc_type_top_field	  		");
	        	vld_ue_name(fifoContent, fifoIdx, ures, "chroma_sample_loc_type_bottom_field  		");
	        end
	        
	        skip_bits_name( 1, fifoIdx, "neutral_chroma_indication_flag                  			");
	        skip_bits_name( 1, fifoIdx, "field_seq_flag                  							");
	        skip_bits_name( 1, fifoIdx, "frame_field_info_present_flag     							");	        

	        load_fifo();
	        vld_u_name(1, fifoContent, fifoIdx, ures, "default_display_window_flag            	  	");
	        if(ures[0] = 1) then
	        	vld_ue_name(fifoContent, fifoIdx, ures, "def_disp_win_left_offset	  				");
	        	vld_ue_name(fifoContent, fifoIdx, ures, "def_disp_win_right_offset	  				");
	        	vld_ue_name(fifoContent, fifoIdx, ures, "def_disp_win_top_offset	  				");
	        	vld_ue_name(fifoContent, fifoIdx, ures, "def_disp_win_bottom_offset	  				");
	        end

	        vld_u_name(1, fifoContent, fifoIdx, ures, "vui_timing_info_present_flag            	  	");
	        if(ures[0] = 1) then
				load_fifo();
				skip_bits_name(32, fifoIdx, "vui_num_units_in_tick									");
				skip_bits_name(32, fifoIdx, "vui_time_scale]										");
	        	load_fifo();
	        	vld_u_name(1, fifoContent, fifoIdx, ures, "vui_poc_proportional_to_timing_flag      ");
	        	if(ures[0] = 1) then
	        		vld_ue_name(fifoContent, fifoIdx, ures, "vui_num_ticks_poc_diff_one_minus1	  	");
	        	end
	        	vld_u_name(1, fifoContent, fifoIdx, ures, "hrd_parameters_present_flag       		");
	        	if(ures[0] = 1) then
	        		parse_sps_hrd();
	        	end
	        end
	        
	        load_fifo();
	        vld_u_name(1, fifoContent, fifoIdx, ures, "bitstream_restriction_flag            	  	");
	        if(ures[0] = 1) then
	        	skip_bits_name( 1, fifoIdx, "tiles_fixed_structure_flag		  						");
	        	skip_bits_name( 1, fifoIdx, "motion_vectors_over_pic_boundaries_flag		  		");
	        	skip_bits_name( 1, fifoIdx, "restricted_ref_pic_lists_flag		  					");
	        	vld_ue_name(fifoContent, fifoIdx, ures, "min_spatial_segmentation_idc  				");
	        	if(ures[0] >= 4096) then
	        		println("ERROR: VUI param: min_spatial_segmentation_idc >= 4096");
	        	end
	        	vld_ue_name(fifoContent, fifoIdx, ures, "max_bytes_per_pic_denom	  				");
	        	vld_ue_name(fifoContent, fifoIdx, ures, "max_bits_per_mincu_denom	  				");
	        	vld_ue_name(fifoContent, fifoIdx, ures, "log2_max_mv_length_horizontal	  			");
	        	vld_ue_name(fifoContent, fifoIdx, ures, "log2_max_mv_length_vertical	  			");
	        end
		end

	    /**************************************************************************
	     * parse_sps_hrd
	     *************************************************************************/
		procedure parse_sps_hrd()
		var
			uint(size=32) ures[1],
			uint(size=32) maxNumSubLayersMinus1 := sps_max_sub_layers_minus1[sps_id] - 1,
			
			bool sps_nal_hrd_parameters_present_flag[NB_MAX_SPS],
			bool sps_vcl_hrd_parameters_present_flag[NB_MAX_SPS],
			bool sps_hrd_sub_pic_cpb_params_present_flag[NB_MAX_SPS],
			bool sps_hrd_fixed_pic_rate_within_cvs_flag[NB_MAX_SPS][32],
			bool sps_hrd_low_delay_hrd_flag[NB_MAX_SPS][32],
			uint(size=32) sps_hrd_cpb_cnt_minus1[NB_MAX_SPS][32]
		begin
			load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, ures, "nal_hrd_parameters_present_flag             	");
			sps_nal_hrd_parameters_present_flag[sps_id] := if(ures[0] = 1) then true else false end;
			vld_u_name(1, fifoContent, fifoIdx, ures, "vcl_hrd_parameters_present_flag             	");
			sps_vcl_hrd_parameters_present_flag[sps_id] := if(ures[0] = 1) then true else false end;
			if(sps_nal_hrd_parameters_present_flag[sps_id] or sps_vcl_hrd_parameters_present_flag[sps_id]) then
				vld_u_name(1, fifoContent, fifoIdx, ures, "sub_pic_cpb_params_present_flag        	");
				sps_hrd_sub_pic_cpb_params_present_flag[sps_id] := if(ures[0] = 1) then true else false end;
				if(ures[0] = 1) then
					skip_bits_name( 8, fifoIdx, "tick_divisor_minus2                  				");
					skip_bits_name( 5, fifoIdx, "du_cpb_removal_delay_length_minus1         		");
					skip_bits_name( 1, fifoIdx, "sub_pic_cpb_params_in_pic_timing_sei_flag        	");
					skip_bits_name( 5, fifoIdx, "dpb_output_delay_du_length_minus1           		");
				end
				skip_bits_name( 4, fifoIdx, "bit_rate_scale           								");
				vld_u_name( 4, fifoContent, fifoIdx, ures, "cpb_size_scale           				");
				if(ures[0] != 0) then
					skip_bits_name( 4, fifoIdx, "cpb_size_du_scale                  				");
				end
				skip_bits_name( 5, fifoIdx, "initial_cpb_removal_delay_length_minus1         		");
				skip_bits_name( 5, fifoIdx, "au_cpb_removal_delay_length_minus1        				");
				skip_bits_name( 5, fifoIdx, "dpb_output_delay_length_minus1           				");
			end
			
			foreach int i in 0 .. maxNumSubLayersMinus1 do				
		   		load_fifo();
		        vld_u_name(1, fifoContent, fifoIdx, ures, "fixed_pic_rate_general_flag             	");
		        if(ures[0] = 0) then
		        	vld_u_name(1, fifoContent, fifoIdx, ures, "fixed_pic_rate_within_cvs_flag    	");
		        	sps_hrd_fixed_pic_rate_within_cvs_flag[sps_id][i] := if(ures[0] = 1) then true else false end;
		        else
		        	sps_hrd_fixed_pic_rate_within_cvs_flag[sps_id][i] := true;
		        end
		        
		        sps_hrd_low_delay_hrd_flag[sps_id][i]	:= false;	// By default, set to false.
		        sps_hrd_cpb_cnt_minus1[sps_id][i] 		:= 0;		// By default, set to 0.
		        if(sps_hrd_low_delay_hrd_flag[sps_id][i]) then
		        	vld_ue_name(fifoContent, fifoIdx, ures, "elemental_duration_in_tc_minus1		");
		        else
		        	vld_u_name( 1, fifoContent, fifoIdx, ures, "low_delay_hrd_flag					");
		        	sps_hrd_low_delay_hrd_flag[sps_id][i] := if(ures[0] = 1) then true else false end;
		        end
		        if(not sps_hrd_low_delay_hrd_flag[sps_id][i]) then
		        	vld_ue_name(fifoContent, fifoIdx, ures, "cpb_cnt_minus1							");
		        	sps_hrd_cpb_cnt_minus1[sps_id][i] := ures[0];
		        end
		   		
		   		load_fifo();
		   		foreach int nalOrVcl in 0 .. 1 do
		   			if( (nalOrVcl = 0 and sps_nal_hrd_parameters_present_flag[sps_id]) ||
		   				(nalOrVcl = 1 and sps_vcl_hrd_parameters_present_flag[sps_id]) ) then
		   				foreach int j in 0 .. sps_hrd_cpb_cnt_minus1[sps_id][i] do
		   					vld_ue_name(fifoContent, fifoIdx, ures, "bit_rate_value_minus1			");
		   					vld_ue_name(fifoContent, fifoIdx, ures, "cpb_size_value_minus1			");
		   					if(sps_hrd_sub_pic_cpb_params_present_flag[sps_id]) then
			   					vld_ue_name(fifoContent, fifoIdx, ures, "cpb_size_du_value_minus1	");
			   					vld_ue_name(fifoContent, fifoIdx, ures, "bit_rate_du_value_minus1	");		   						
		   					end
		   					vld_u_name(1, fifoContent, fifoIdx, ures, "cbr_flag						");
		   				end
		   			end
		   		end
		   	end
		end	

	    /**************************************************************************
	     * parse_sps_extension
	     *************************************************************************/
		procedure parse_sps_extension()
		var 
            uint(size=32) ures[1],
            bool sps_range_extension_flag,
            bool sps_multilayer_extension_flag,
            bool sps_3d_extension_flag,
            bool sps_extension_5bits
		begin
	    	load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, ures, "sps_range_extension_flag					");
			sps_range_extension_flag := if(ures[0] != 0) then true else false end;
			vld_u_name(1, fifoContent, fifoIdx, ures, "sps_multilayer_extension_flag			");
			sps_multilayer_extension_flag := if(ures[0] != 0) then true else false end;
			vld_u_name(1, fifoContent, fifoIdx, ures, "sps_3d_extension_flag					");
			sps_3d_extension_flag := if(ures[0] != 0) then true else false end;
			vld_u_name(1, fifoContent, fifoIdx, ures, "sps_extension_5bits						");
			sps_extension_5bits := if(ures[0] != 0) then true else false end;

			if(sps_range_extension_flag) then // sps_range_extension()
				vld_u_name(1, fifoContent, fifoIdx, ures, "transform_skip_rotation_enabled_flag				");
				vld_u_name(1, fifoContent, fifoIdx, ures, "transform_skip_context_enabled_flag				");
				vld_u_name(1, fifoContent, fifoIdx, ures, "implicit_rdpcm_enabled_flag						");
				vld_u_name(1, fifoContent, fifoIdx, ures, "explicit_rdpcm_enabled_flag						");
				vld_u_name(1, fifoContent, fifoIdx, ures, "extended_precision_processing_flag				");
				vld_u_name(1, fifoContent, fifoIdx, ures, "intra_smoothing_disabled_flag					");
				vld_u_name(1, fifoContent, fifoIdx, ures, "high_precision_offsets_enabled_flag				");
				vld_u_name(1, fifoContent, fifoIdx, ures, "persistent_rice_adaptation_enabled_flag			");
				vld_u_name(1, fifoContent, fifoIdx, ures, "cabac_bypass_alignment_enabled_flag				");
			end

			if(sps_multilayer_extension_flag) then // sps_multilayer_extension()
				vld_u_name(1, fifoContent, fifoIdx, ures, "inter_view_mv_vert_constraint_flag				");
			end

			if(sps_3d_extension_flag) then
			
			end

			if(sps_extension_5bits) then
			
			end
		end

	    /**************************************************************************
	     * read_SPS_Header
	     *************************************************************************/
	    read_SPS_Header: action ==>
	    var
	    	uint(size=32) res[1],
        	int startIdx
	    do
	        load_fifo();
	        vld_u_name(4, fifoContent, fifoIdx, res,
	        "sps_video_parameter_set_id              ");
	        vld_u_name(3, fifoContent, fifoIdx, res,
	        "sps_max_sub_layers_minus1               ");
	        sps_max_sub_layers_minus1[sps_id] := res[0];
	        vld_u_name(1, fifoContent, fifoIdx, res,
	        "sps_temporal_id_nesting_flag            ");
	        
	        parse_sps_ptl();

	        load_fifo();
			vld_ue_name(fifoContent, fifoIdx, res, "sps_seq_parameter_set_id                ");
	        sps_id := res[0];
	        sps_id_decoded[sps_id] := true;
	        vld_ue_name(fifoContent, fifoIdx, res, "sps_chroma_format_idc                   ");
	        sps_chroma_format_idc[sps_id] := res[0];
	        if res[0] = 3 then
	        	vld_u_name(1, fifoContent, fifoIdx, res,
	        	"separate_colour_plane_flag              ");
	        	sps_separate_colour_plane_flag[sps_id] := res[0];
	        end
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "pic_width_in_luma_samples               ");
	        sps_pic_width_in_luma_samples[sps_id] := res[0];
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "pic_height_in_luma_samples              ");
	        sps_pic_height_in_luma_samples[sps_id] := res[0];

	    	load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, res, "conformance_window_flag               ");
	        if res[0] = 1 then
	        	vld_ue_name(fifoContent, fifoIdx, res,
	        	"conf_win_left_offset                    ");
	        	vld_ue_name(fifoContent, fifoIdx, res,
	        	"conf_win_right_offset                   ");
	        	vld_ue_name(fifoContent, fifoIdx, res,
	        	"conf_win_top_offset                     ");
	        	vld_ue_name(fifoContent, fifoIdx, res,
	        	"conf_win_bottom_offset                  ");
	        end
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "sps_bit_depth_luma_minus8                   ");
	        sps_bit_depth_luma[sps_id] := res[0] + 8;
	        sps_bit_depth_minus5[sps_id][0] := res[0] + 8 - 5;
	        qp_bd_offset_luma := 6 * res[0];
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "sps_bit_depth_chroma_minus8                 ");
	        sps_bit_depth_chroma[sps_id] := res[0] + 8;
	        sps_bit_depth_minus5[sps_id][1] := res[0] + 8 - 5;
	        sps_bit_depth_minus5[sps_id][2] := res[0] + 8 - 5;
	        qp_bd_offset_chroma := 6 * res[0];
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "log2_max_pic_order_cnt_lsb_minus4       ");
	        sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] := res[0];
	        max_poc_lsb[sps_id] := 1 <<
	        (sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4);
	        vld_u_name(1, fifoContent, fifoIdx, res,
	        "sps_sub_layer_ordering_info_present_flag");
	        sps_sub_layer_ordering_info_present_flag := res[0] != 0;
	        if sps_sub_layer_ordering_info_present_flag then
	        	startIdx := 0;
	        else
	        	startIdx := sps_max_sub_layers_minus1[sps_id];
	        end
	        
	        foreach int cnt_i in startIdx .. sps_max_sub_layers_minus1[sps_id] do
				load_fifo();
				vld_ue_name(    fifoContent, fifoIdx, res, "sps_max_dec_pic_buffering_minus1        ");
				sps_max_dec_pic_buffering[cnt_i] := res[0] + 1;
				
				vld_ue_name(    fifoContent, fifoIdx, res, "sps_num_reorder_pics                    ");
				sps_num_reorder_pics[cnt_i] := res[0];
				
				vld_ue_name(    fifoContent, fifoIdx, res, "sps_max_latency_increase_plus1			");
				if(res[0] = 0) then
					sps_max_latency_pict[cnt_i] := 0;
				else
					sps_max_latency_pict[cnt_i] := sps_num_reorder_pics[cnt_i] + res[0] - 1;
				end				
			end
			
			if not sps_sub_layer_ordering_info_present_flag then
				foreach int i in 0 .. startIdx do
					sps_max_dec_pic_buffering[i] := sps_max_dec_pic_buffering[startIdx];
					sps_num_reorder_pics[i] := sps_num_reorder_pics[startIdx];
					sps_max_latency_pict[i] := sps_max_latency_pict[startIdx];
				end
			end

	        load_fifo();
			vld_ue_name(fifoContent, fifoIdx, res, "log2_min_coding_block_size_minus3       ");
	        sps_log2_min_coding_block_size[sps_id] := res[0] + 3;
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "log2_diff_max_min_coding_block_size     ");
	        sps_log2_diff_max_min_coding_block_size[sps_id] := res[0];
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "log2_min_transform_block_size_minus2    ");
	        sps_log2_min_transform_block_size[sps_id] := res[0] + 2;
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "log2_diff_max_min_transform_block_size  ");
	        sps_log2_diff_max_min_transform_block_size[sps_id] := res[0];
	        //sps_maxCUWidth[sps_id] := 1 << (Log2MinCbSize +
	        //sps_log2_diff_max_min_coding_block_size[sps_id]);
	        
	        sps_log2_min_pu_size[sps_id] := sps_log2_min_coding_block_size[sps_id] - 1;
	        sps_min_pu_width[sps_id] := sps_pic_width_in_luma_samples[sps_id]  >> sps_log2_min_pu_size[sps_id];

	        min_cb_width := sps_pic_width_in_luma_samples[sps_id] >> sps_log2_min_coding_block_size[sps_id];
	        sps_log2_ctb_size[sps_id] := sps_log2_min_coding_block_size[sps_id] + sps_log2_diff_max_min_coding_block_size[sps_id];
	        sps_ctb_width[sps_id] := (sps_pic_width_in_luma_samples[sps_id]  + (1 << sps_log2_ctb_size[sps_id]) - 1) >> sps_log2_ctb_size[sps_id];
	        sps_ctb_height[sps_id] := (sps_pic_height_in_luma_samples[sps_id]  + (1 << sps_log2_ctb_size[sps_id]) - 1) >> sps_log2_ctb_size[sps_id];

	        load_fifo();
			vld_ue_name(fifoContent, fifoIdx, res, "max_transform_hierarchy_depth_inter     ");
	        sps_max_transform_hierarchy_depth_inter[sps_id] := res[0];
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "max_transform_hierarchy_depth_intra     ");
	        sps_max_transform_hierarchy_depth_intra[sps_id] := res[0];
	        vld_u_name(1, fifoContent, fifoIdx, res,
	        "sps_scaling_list_enabled_flag           ");
	        sps_scaling_list_enabled_flag[sps_id] := res[0];
	               
	        if sps_scaling_list_enabled_flag[sps_id] = 1 then
	        	parse_sps_scaling_list_data();
	        end
	        
	        load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, res,
	        "amp_enabled_flag                        ");
	        amp_enabled_flag := res[0];
	        vld_u_name(1, fifoContent, fifoIdx, res,
	        "sample_adaptive_offset_enabled_flag     ");
	        sps_sample_adaptive_offset_enabled_flag[sps_id] := res[0];
	        vld_u_name(1, fifoContent, fifoIdx, res,
	        "pcm_enabled_flag                        ");
	        sps_pcm_enabled_flag[sps_id] := res[0];
	        if sps_pcm_enabled_flag[sps_id] = 1 then
	        	vld_u_name(4, fifoContent, fifoIdx, res,
	        	"pcm_sample_bit_depth_luma_minus1        ");
	        	pcm_bit_depth_luma[sps_id] := res[0] + 1;
	        	vld_u_name(4, fifoContent, fifoIdx, res,
	        	"pcm_sample_bit_depth_chroma_minus1      ");
	        	pcm_bit_depth_chroma[sps_id] := res[0] + 1;
	        	vld_ue_name(fifoContent, fifoIdx, res,
	        	"log2_min_pcm_luma_coding_block_size_minus3");
	        	log2_min_pcm_cb_size[sps_id] := res[0] + 3;
	        	vld_ue_name(fifoContent, fifoIdx, res,
	        	"log2_diff_max_min_pcm_luma_coding_block_size");
	        	log2_max_pcm_cb_size[sps_id] := log2_min_pcm_cb_size[sps_id] +
	        	res[0];
	        	vld_u_name(1, fifoContent, fifoIdx, res,
	        	"pcm_loop_filter_disable_flag            ");
	        	pcm_loop_filter_disable_flag[sps_id] := res[0];
	        	
	        	if(pcm_bit_depth_luma[sps_id] > (sps_bit_depth_luma[sps_id])) then
	        		println("ERROR: PCM bit depth for LUMA is greater than normal normal LUMA bit depth)\n");
	        	end
	        	
	        	if(pcm_bit_depth_chroma[sps_id] > (sps_bit_depth_chroma[sps_id])) then
	        		println("ERROR: PCM bit depth for Chroma is greater than normal normal Cb bit depth)\n");
	        	end
	        end
	        vld_ue_name(fifoContent, fifoIdx, res,
	        "num_short_term_ref_pic_sets             ");
	        sps_num_short_term_ref_pic_sets[sps_id] := res[0];
	        
	    	foreach int cnt_i in 0 .. (sps_num_short_term_ref_pic_sets[sps_id]-1) do
	    		load_fifo();
				parseShortTermRefPicSet(cnt_i);
			end
			
	        load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, res,
	        "long_term_ref_pics_present_flag         ");
	        sps_long_term_ref_pics_present_flag[sps_id] := res[0];
	        if res[0] = 1 then
	        	vld_ue_name(fifoContent, fifoIdx, res,
	        	"num_long_term_ref_pics_sps              ");
	        	sps_num_long_term_ref_pics_sps[sps_id] := res[0];
	        	foreach int i in 0 .. sps_num_long_term_ref_pics_sps[sps_id] - 1
	        	do
	        		vld_u_name(sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4,
	        		fifoContent, fifoIdx, res, "lt_ref_pic_poc_lsb_sps                  ");
	        		lt_ref_pic_poc_lsb_sps[i] := res[0];
	        		vld_u_name(1, fifoContent, fifoIdx, res,
	        		"used_by_curr_pic_lt_sps_flag            ");
	        		used_by_curr_pic_lt_sps_flag[i] := res[0];
	        	end
	        end
	        vld_u_name(1, fifoContent, fifoIdx, res,
	        "sps_temporal_mvp_enable_flag            ");
	        sps_temporal_mvp_enable_flag[sps_id] := res[0];
	        vld_u_name(1, fifoContent, fifoIdx, res,
	        "sps_strong_intra_smoothing_enable_flag  ");
	        sps_strong_intra_smoothing_enable_flag[sps_id] := res[0] = 1;
	        vld_u_name(1, fifoContent, fifoIdx, res,
	        "vui_parameters_present_flag             ");
	        if res[0] = 1 then
	        	parse_sps_vui();
	        end
	        
	        load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, res,
	        "sps_extension_flag                      ");
	        if res[0] = 1 then
	        	parse_sps_extension();
	        end

	        set_sps_drived_vars();
	    end

	    /**************************************************************************
	     **************************************************************************
	     ********        Picture Parameter Set HEADER         *********************
	     **************************************************************************
	     *************************************************************************/
		bool pps_id_decoded[64] := [false : for int i in 0 .. 63];
	    uint(size= 8) pps_sps_id[NB_MAX_PPS];
	    uint(size= 2) pps_tiles_enabled_flag[NB_MAX_PPS];
	
	    uint(size= 1) pps_dependent_slice_segments_enabled_flag[NB_MAX_PPS];
		uint(size= 1) pps_output_flag_present_flag[NB_MAX_PPS];
		uint(size= 3) pps_num_extra_slice_header_bits[NB_MAX_PPS];
	    uint(size= 1) pps_sign_data_hiding_flag[NB_MAX_PPS];
	    uint(size= 1) pps_cabac_init_present_flag[NB_MAX_PPS];
	    uint(size= 8) pps_num_ref_idx_l0_default_active_minus1[NB_MAX_PPS];
	    uint(size= 8) pps_num_ref_idx_l1_default_active_minus1[NB_MAX_PPS];
	     int(size=32) pps_init_qp_minus26[NB_MAX_PPS];
	    uint(size= 1) pps_transform_skip_enabled_flag[NB_MAX_PPS];
	    bool          pps_constrained_intra_pred_flag[NB_MAX_PPS];
	    uint(size= 1) pps_cu_qp_delta_enabled_flag[NB_MAX_PPS];
	    uint(size=16) pps_diff_cu_qp_delta_depth[NB_MAX_PPS];
	     int(size= 8) pps_chroma_qp_offset[NB_MAX_PPS][3];
	    uint(size= 1) pps_slice_chroma_qp_offsets_present_flag[NB_MAX_PPS];
	    uint(size= 1) pps_weighted_pred_flag[NB_MAX_PPS];
		uint(size= 1) pps_weighted_bipred_flag[NB_MAX_PPS];
	    uint(size= 1) pps_transquant_bypass_enable_flag[NB_MAX_PPS];
	    uint(size= 1) pps_entropy_coding_sync_enabled_flag[NB_MAX_PPS];
	    uint(size= 8) pps_num_tile_columns_minus1[NB_MAX_PPS];
	    uint(size= 8) pps_num_tile_rows_minus1[NB_MAX_PPS];
	    uint(size= 1) pps_uniform_spacing_flag[NB_MAX_PPS];

	    uint(size=16) pps_column_width[NB_MAX_PPS][PICT_WIDTH / MIN_CTB_SIZE_Y];
	    uint(size=16) pps_row_height[NB_MAX_PPS][PICT_HEIGHT / MIN_CTB_SIZE_Y];
	    uint(size= 1) pps_scaling_list_data_present_flag[NB_MAX_PPS];

	    uint(size= 1) pps_deblocking_filter_control_present_flag[NB_MAX_PPS];
	    uint(size =1) deblocking_filter_override_enabled_flag[NB_MAX_PPS];
	    uint(size= 1) pps_loop_filter_across_tile_enabled_flag[NB_MAX_PPS];
	    uint(size= 1) pps_loop_filter_across_slice_enabled_flag[NB_MAX_PPS];
	    uint(size= 1) pps_lists_modification_present_flag[NB_MAX_PPS];
		uint(size= 1) pps_slice_segment_header_extension_present_flag[NB_MAX_PPS];
		uint(size= 1) pps_disable_deblocking_filter_flag[NB_MAX_PPS];
		uint(size= 1) pps_beta_offset[NB_MAX_PPS];
		uint(size= 1) pps_tc_offset[NB_MAX_PPS];
		uint(size= 8) pps_log2_parallel_merge_level[NB_MAX_PPS];
		uint(size= 8) pps_sl[NB_MAX_PPS][4][6][64];
		uint(size= 8) pps_sl_dc[NB_MAX_PPS][2][6];
	    
	    /**************************************************************************
	     * parse_pps_scaling_list_data
	     *************************************************************************/
		procedure parse_pps_scaling_list_data() 
		var
            int(size=32) ires[1],
            uint(size=32) ures[1],

			int matrixEndMinus1,
	        int sizeIdMemCpyCase,
            int delta,
	        int coefNum,
	        int nextCoef,
	        int nextCoefPos
		begin
			foreach int matrixId in 0 .. 5 do
	        	// 4x4 default is 16
		        foreach int i in 0 .. 15 do
	                pps_sl[pps_id][0][matrixId][i] := 16;
		        end
		        pps_sl_dc[pps_id][0][matrixId] := 16; // default for 16x16
		        pps_sl_dc[pps_id][1][matrixId] := 16; // default for 32x32
	        end
	        foreach int i in 0 .. 63 do
	            pps_sl[pps_id][1][0][i] := default_scaling_list_intra[i];
	            pps_sl[pps_id][1][1][i] := default_scaling_list_intra[i];
	            pps_sl[pps_id][1][2][i] := default_scaling_list_intra[i];
	            pps_sl[pps_id][1][3][i] := default_scaling_list_inter[i];
	            pps_sl[pps_id][1][4][i] := default_scaling_list_inter[i];
	            pps_sl[pps_id][1][5][i] := default_scaling_list_inter[i];
	            pps_sl[pps_id][2][0][i] := default_scaling_list_intra[i];
	            pps_sl[pps_id][2][1][i] := default_scaling_list_intra[i];
	            pps_sl[pps_id][2][2][i] := default_scaling_list_intra[i];
	            pps_sl[pps_id][2][3][i] := default_scaling_list_inter[i];
	            pps_sl[pps_id][2][4][i] := default_scaling_list_inter[i];
	            pps_sl[pps_id][2][5][i] := default_scaling_list_inter[i];
	            pps_sl[pps_id][3][0][i] := default_scaling_list_intra[i];
	            pps_sl[pps_id][3][1][i] := default_scaling_list_inter[i];
	        end

			foreach int sizeId in 0 .. 3 do
				if sizeId = 3 then matrixEndMinus1 := 1; else matrixEndMinus1 := 5; end
				foreach int matrixId in 0 .. matrixEndMinus1 do
				    load_fifo();
					vld_u_name(1, fifoContent, fifoIdx, ures, "scaling_list_pred_mode_flag             ");

				    if ures[0] = 0 then
				    	vld_ue_name(fifoContent, fifoIdx, ures, "delta                                 ");
				    	delta := ures[0]; // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
				    	if delta != 0 then // Copy from previous array.
				    		if (matrixId - delta < 0) then
				    			println("Invalid delta in scaling list data");
				    		end
				    		if sizeId > 0 then
				    			sizeIdMemCpyCase := 64;
				    		else
				    			sizeIdMemCpyCase := 16;
				    		end
				    		foreach int k in 0 .. sizeIdMemCpyCase - 1 do
				    			pps_sl[pps_id][sizeId][matrixId][k] :=
				    			pps_sl[pps_id][sizeId][matrixId - delta][k];
				    		end
				    		if (sizeId > 1) then
				    			pps_sl_dc[pps_id][sizeId - 2][matrixId] :=
				    			pps_sl_dc[pps_id][sizeId - 2][matrixId - delta];
				    		end
				    	end
				    else
				    	nextCoef := 8;
				    	coefNum := min(64, (1 << (4 + (sizeId << 1))));
				    	if (sizeId > 1) then
				    		vld_se_name(fifoContent, fifoIdx, ires, "scaling_list_dc_coef                    ");
				    		nextCoef := ires[0] + 8;
				    		pps_sl_dc[pps_id][sizeId - 2][matrixId] := nextCoef;
				    	end
				    	
				    	foreach int i in 0 .. (coefNum-1) do
				    		load_fifo();
				    		vld_se_name(fifoContent, fifoIdx, ires, "scaling_list_delta_coef                 ");
				    		nextCoef := (nextCoef + ires[0]+ 256) & 255;

							if (sizeId = 0) then
						        nextCoefPos := 4 * hevc_diag_scan4x4_y[i] + hevc_diag_scan4x4_x[i];
						    else
						        nextCoefPos := 8 * hevc_diag_scan8x8_y[i] + hevc_diag_scan8x8_x[i];
						    end
				    		pps_sl[pps_id][sizeId][matrixId][nextCoefPos] := nextCoef;
				    	end
				    end
				end
			end
			
		    if sps_chroma_format_idc[sps_id] = 3 then 
				foreach int i in 0 .. 63 do
		            pps_sl[pps_id][3][1][i] := pps_sl[pps_id][2][1][i];
		            pps_sl[pps_id][3][2][i] := pps_sl[pps_id][2][2][i];
		            pps_sl[pps_id][3][4][i] := pps_sl[pps_id][2][4][i];
		            pps_sl[pps_id][3][5][i] := pps_sl[pps_id][2][5][i];
		        end
		        pps_sl_dc[pps_id][1][1] := pps_sl_dc[pps_id][0][1];
		        pps_sl_dc[pps_id][1][2] := pps_sl_dc[pps_id][0][2];
		        pps_sl_dc[pps_id][1][4] := pps_sl_dc[pps_id][0][4];
		        pps_sl_dc[pps_id][1][5] := pps_sl_dc[pps_id][0][5];
		    end
		end

	    /**************************************************************************
	     * parse_pps_extension
	     *************************************************************************/
		procedure parse_pps_extension() 
		var
            int(size=32) ires[1],
            uint(size=32) ures[1],
            bool pps_range_extension_flag,            
            bool pps_multilayer_extension_flag,
            bool pps_3d_extension_flag,
            bool pps_extension_5bits
		begin
	    	load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, ures, "pps_range_extension_flag					");
			pps_range_extension_flag := if(ures[0] != 0) then true else false end;
			vld_u_name(1, fifoContent, fifoIdx, ures, "pps_multilayer_extension_flag			");
			pps_multilayer_extension_flag := if(ures[0] != 0) then true else false end;
			vld_u_name(1, fifoContent, fifoIdx, ures, "pps_3d_extension_flag					");
			pps_3d_extension_flag := if(ures[0] != 0) then true else false end;
			vld_u_name(1, fifoContent, fifoIdx, ures, "pps_extension_5bits						");
			pps_extension_5bits := if(ures[0] != 0) then true else false end;

			if(pps_range_extension_flag) then // pps_range_extension()
				if(pps_transform_skip_enabled_flag[pps_id] != 0) then
					vld_ue_name(fifoContent, fifoIdx, ures, "log2_max_transform_skip_block_size_minus2			");
				end
				
				vld_u_name(1, fifoContent, fifoIdx, ures, "cross_component_prediction_enabled_flag				");
				vld_u_name(1, fifoContent, fifoIdx, ures, "chroma_qp_offset_list_enabled_flag					");
				load_fifo();
				if(ures[0] != 0) then
					vld_ue_name(fifoContent, fifoIdx, ures, "diff_cu_chroma_qp_offset_depth						");
					vld_ue_name(fifoContent, fifoIdx, ures, "chroma_qp_offset_list_len_minus1					");
					
					foreach int i in 0 .. ures[0] do
						load_fifo();
						vld_se_name(fifoContent, fifoIdx, ires, "cb_qp_offset_list[i]							");
						vld_se_name(fifoContent, fifoIdx, ires, "cb_qp_offset_list[i]							");
					end
				end
				load_fifo();				
				vld_ue_name(fifoContent, fifoIdx, ures, "log2_sao_offset_scale_luma								");
				vld_ue_name(fifoContent, fifoIdx, ures, "log2_sao_offset_scale_chroma							");
			end

			if(pps_multilayer_extension_flag) then // pps_multilayer_extension()
				load_fifo();
				vld_u_name(1, fifoContent, fifoIdx, ures, "poc_reset_info_present_flag							");
				vld_u_name(1, fifoContent, fifoIdx, ures, "pps_infer_scaling_list_flag							");
				if(ures[0] != 0) then
					vld_u_name(6, fifoContent, fifoIdx, ures, "pps_scaling_list_ref_layer_id					");
				end
				vld_ue_name(fifoContent, fifoIdx, ures, "num_ref_loc_offsets									");
				foreach int i in 0 .. ures[0]-1 do
					load_fifo();
					vld_u_name(6, fifoContent, fifoIdx, ures, "ref_loc_offset_layer_id[i]						");
					vld_u_name(1, fifoContent, fifoIdx, ures, "scaled_ref_layer_offset_present_flag[i]			");
					if(ures[0] != 0) then
						load_fifo();
						vld_se_name(fifoContent, fifoIdx, ires, 
							"scaled_ref_layer_left_offset[ref_loc_offset_layer_id[[i]]							");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"scaled_ref_layer_top_offset[ref_loc_offset_layer_id[[i]]							");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"scaled_ref_layer_right_offset[ref_loc_offset_layer_id[[i]]							");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"scaled_ref_layer_bottom_offset[ref_loc_offset_layer_id[[i]]						");
					end
					
					load_fifo();
					vld_u_name(1, fifoContent, fifoIdx, ures, "ref_region_offset_present_flag[i]				");
					if(ures[0] != 0) then
						vld_se_name(fifoContent, fifoIdx, ires, 
							"ref_region_left_offset[ref_loc_offset_layer_id[[i]]								");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"ref_region_top_offset[ref_loc_offset_layer_id[[i]]									");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"ref_region_right_offset[ref_loc_offset_layer_id[[i]]								");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"ref_region_bottom_offset[ref_loc_offset_layer_id[[i]]								");
					end

					load_fifo();
					vld_u_name(1, fifoContent, fifoIdx, ures, "resample_phase_set_present_flag[i]				");
					if(ures[0] != 0) then
						vld_se_name(fifoContent, fifoIdx, ires, 
							"phase_hor_luma[ref_loc_offset_layer_id[[i]]										");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"phase_ver_luma[ref_loc_offset_layer_id[[i]]										");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"phase_hor_chroma_plus8[ref_loc_offset_layer_id[[i]]								");
						vld_se_name(fifoContent, fifoIdx, ires, 
							"phase_ver_chroma_plus8[ref_loc_offset_layer_id[[i]]								");
					end
				end
				
				load_fifo();
				vld_u_name(1, fifoContent, fifoIdx, ures, "colour_mapping_enabled_flag 							");
				if(ures[0] != 0) then // colour_mapping_table()
					parse_pps_color_mapping_table();
				end
			end

			if(pps_3d_extension_flag) then
			
			end

			if(pps_extension_5bits) then
			
			end
		end

	    /**************************************************************************
	     * parse_pps_color_mapping_table
	     *************************************************************************/
		procedure parse_pps_color_mapping_table()
		var
            int(size=32) ires[1],
            uint(size=32) ures[1],
            uint(size=2) cm_octant_depth,
            uint(size=2) cm_y_part_num_log2
		begin
			vld_ue_name(fifoContent, fifoIdx, ures, "num_cm_ref_layers_minus1							");
			foreach int i in 0 .. ures[0] do
				load_fifo();
				vld_u_name(6, fifoContent, fifoIdx, ures, "cm_ref_layer_id[i]							");
			end
			vld_u_name(2, fifoContent, fifoIdx, ures, "cm_octant_depth									");
			cm_octant_depth := ures[0];
			vld_u_name(2, fifoContent, fifoIdx, ures, "cm_y_part_num_log2								");
			cm_y_part_num_log2 := ures[0];
			load_fifo();
			vld_ue_name(fifoContent, fifoIdx, ures, "luma_bit_depth_cm_input_minus8						");
			vld_ue_name(fifoContent, fifoIdx, ures, "chroma_bit_depth_cm_input_minus8					");
			vld_ue_name(fifoContent, fifoIdx, ures, "luma_bit_depth_cm_output_minus8					");
			vld_ue_name(fifoContent, fifoIdx, ures, "chroma_bit_depth_cm_output_minus8					");
			load_fifo();
			vld_u_name(2, fifoContent, fifoIdx, ures, "cm_res_quant_bits								");
			vld_u_name(2, fifoContent, fifoIdx, ures, "cm_delta_flc_bits_minus1							");
			
			if(cm_octant_depth = 1) then
				vld_se_name(fifoContent, fifoIdx, ires, "cm_adapt_threshold_u_delta						");
				vld_se_name(fifoContent, fifoIdx, ires, "cm_adapt_threshold_v_delta						");
			end
			parse_pps_colour_mapping_octants(cm_octant_depth, cm_y_part_num_log2, 0, 0, 0, 0, 1<<cm_octant_depth);
		end
		
	    /**************************************************************************
	     * parse_pps_colour_mapping_octants
	     *************************************************************************/
		procedure parse_pps_colour_mapping_octants(uint(size=2) cm_octant_depth, uint(size=2) cm_y_part_num_log2, 
											   	uint(size=2) inpDepth, uint(size=8) idxY, 
											   	uint(size=8) idxCb, uint(size=8) idxCr, 
											  	uint(size=8) inpLength)
		var
            uint(size=32) ures[1] := [0],
            uint(size=8) PartNumY := 1 << cm_y_part_num_log2,
            uint(size=8) idxShiftY,
            uint(size=32) res_coeff_q,
            uint(size=32) res_coeff_r
		begin
			load_fifo();
			if(inpDepth < cm_octant_depth) then
				vld_u_name(1, fifoContent, fifoIdx, ures, "split_octant_flag							");
			end
			
			if(ures[0] != 0) then
				foreach int k in 0 .. 1 do
					foreach int m in 0 .. 1 do
						foreach int n in 0 .. 1 do
							// TODO recursive procedural calls are not allowed in RVC-CAL?
							/*
							parse_pps_colour_mapping_octants(cm_octant_depth, cm_y_part_num_log2, 
								inpDepth + 1, idxY + PartNumY * k * inpLength / 2, 
								idxCb + m * inpLength / 2, idxCr + n * inpLength / 2, 
								inpLength / 2 );*/							
						end
					end
				end
			else
				foreach int i in 0 .. PartNumY-1 do
					idxShiftY := idxY + ( i << (cm_octant_depth - inpDepth));
					foreach int j in 0 .. 3 do
						vld_u_name(1, fifoContent, fifoIdx, ures, "coded_res_flag[idxShiftY][idxCb][idxCr][j]			");
						if(ures[0] != 0) then
							foreach int c in 0 .. 2 do
								load_fifo();
								vld_ue_name(fifoContent, fifoIdx, ures, "res_coeff_q[idxShiftY][idxCb][idxCr][j][c]		");
								res_coeff_q := ures[0];
								vld_ue_name(fifoContent, fifoIdx, ures, "res_coeff_r[idxShiftY][idxCb][idxCr][j][c]		");
								res_coeff_r := ures[0];
								
								if(res_coeff_q != 0 || res_coeff_r != 0) then
									vld_ue_name(fifoContent, fifoIdx, ures, "res_coeff_s[idxShiftY][idxCb][idxCr][j][c]	");
								end
							end
						end	
					end
				end
			end	
		end
				

	    /**************************************************************************
	     * read_PPS_Header
	     *************************************************************************/
	    read_PPS_Header: action ==>
	    var
            int(size=32) ires[1],
            uint(size=32) ures[1],
            int sum := 0
	    do
	    	load_fifo();
	        vld_ue_name(fifoContent, fifoIdx, ures, "pps_pic_parameter_set_id					");
	        pps_id := ures[0];
	        vld_ue_name(fifoContent, fifoIdx, ures, "pps_seq_parameter_set_id					");
	        sps_id := ures[0];
	        pps_sps_id[pps_id] := ures[0];
	        cnt_i  := 0;

    		pps_num_tile_columns_minus1[pps_id]       := 0;
    		pps_num_tile_rows_minus1[pps_id]          := 0;
    		pps_uniform_spacing_flag[pps_id]          := 1;
			pps_id_decoded[pps_id] := sps_id_decoded[sps_id];
			skipCurrentNal := not sps_id_decoded[sps_id];

	        load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, ures, "dependent_slice_segments_enabled_flag   ");
	        pps_dependent_slice_segments_enabled_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "output_flag_present_flag                ");
	        pps_output_flag_present_flag[pps_id] := ures[0];
	        vld_u_name(3, fifoContent, fifoIdx, ures, "num_extra_slice_header_bits             ");
	        pps_num_extra_slice_header_bits[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "sign_data_hiding_flag                   ");
	        pps_sign_data_hiding_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "cabac_init_present_flag                 ");
	        pps_cabac_init_present_flag[pps_id] := ures[0];
	        vld_ue_name(fifoContent, fifoIdx, ures, "num_ref_idx_l0_default_active_minus1      ");
	        pps_num_ref_idx_l0_default_active_minus1[pps_id] := ures[0];
	        vld_ue_name(fifoContent, fifoIdx, ures, "num_ref_idx_l1_default_active_minus1      ");
	        pps_num_ref_idx_l1_default_active_minus1[pps_id] := ures[0];
	        vld_se_name(fifoContent, fifoIdx, ires, "init_qp_minus26                           ");
	        pps_init_qp_minus26[pps_id] := ires[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "constrained_intra_pred_flag             ");
	        pps_constrained_intra_pred_flag[pps_id] := ures[0] != 0;
	        vld_u_name(1, fifoContent, fifoIdx, ures, "transform_skip_enabled_flag             ");
	        pps_transform_skip_enabled_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "cu_qp_delta_enabled_flag                ");
	        pps_cu_qp_delta_enabled_flag[pps_id] := ures[0];
	        if ures[0] = 1 then
	        	vld_ue_name(fifoContent, fifoIdx, ures, "diff_cu_qp_delta_depth                ");
	        	pps_diff_cu_qp_delta_depth[pps_id] := ures[0];
	        else
	        	pps_diff_cu_qp_delta_depth[pps_id] := 0;
	        end
	        vld_se_name(fifoContent, fifoIdx, ires, "pps_cb_qp_offset                          ");
	        pps_chroma_qp_offset[pps_id][1] := ires[0];
	        vld_se_name(fifoContent, fifoIdx, ires, "pps_cr_qp_offset                          ");
	        pps_chroma_qp_offset[pps_id][2] := ires[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "pps_slice_chroma_qp_offsets_present_flag");
	        pps_slice_chroma_qp_offsets_present_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "weighted_pred_flag                      ");
	        pps_weighted_pred_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "weighted_bipred_flag                    ");
	        pps_weighted_bipred_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "transquant_bypass_enable_flag           ");
	        pps_transquant_bypass_enable_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "tiles_enabled_flag                      ");
	        pps_tiles_enabled_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "entropy_coding_sync_enabled_flag        ");
	        pps_entropy_coding_sync_enabled_flag[pps_id] := ures[0];
	        
	        pps_num_tile_columns_minus1[pps_id] := 0;
	        pps_num_tile_rows_minus1[pps_id] := 0;
	        pps_uniform_spacing_flag[pps_id] := 1;
	        pps_loop_filter_across_tile_enabled_flag[pps_id] := 1;
	        if pps_tiles_enabled_flag[pps_id] = 1 then
	        	vld_ue_name(fifoContent, fifoIdx, ures, "num_tile_columns_minus1               ");
	        	pps_num_tile_columns_minus1[pps_id] := ures[0];
	        	vld_ue_name(fifoContent, fifoIdx, ures, "num_tile_rows_minus1                  ");
	        	pps_num_tile_rows_minus1[pps_id] := ures[0];
	        	vld_u_name(1, fifoContent, fifoIdx, ures, "uniform_spacing_flag                ");
	        	pps_uniform_spacing_flag[pps_id] := ures[0];

				if pps_uniform_spacing_flag[pps_id] = 0 then
					sum := 0;
					foreach int cnt_i in 0 .. (pps_num_tile_columns_minus1[pps_id]-1) do
				        load_fifo();
						vld_ue_name(    fifoContent, fifoIdx, ures, "column_width[ ]           ");
				        pps_column_width[pps_id][cnt_i] := ures[0] + 1;
				        sum := sum + pps_column_width[pps_id][cnt_i];
				        if cnt_i >= (PICT_WIDTH / MIN_CTB_SIZE_Y) then
				                println("Error read_PPS_Header.se_idx_3.loop : "+cnt_i+" >= "+(PICT_WIDTH / MIN_CTB_SIZE_Y));
				        end
					end				
					pps_column_width[pps_id][pps_num_tile_columns_minus1[pps_id]] := sps_ctb_width[sps_id] - sum;
					
					sum := 0;
					foreach int cnt_i in 0 .. (pps_num_tile_rows_minus1[pps_id]-1) do
					    load_fifo();
				        vld_ue_name(    fifoContent, fifoIdx, ures, "row_height[ ]             ");
				        pps_row_height[pps_id][cnt_i] := ures[0] + 1;
				        sum := sum + pps_row_height[pps_id][cnt_i];
				        if cnt_i >= (PICT_HEIGHT / MIN_CTB_SIZE_Y) then
				        	println("Error read_PPS_Header.se_idx_4.loop : "+cnt_i+" >= "+(PICT_HEIGHT / MIN_CTB_SIZE_Y));
				        end
				        
				        pps_row_height[pps_id][pps_num_tile_rows_minus1[pps_id]] := sps_ctb_height[sps_id] - sum;
					end
				end

                vld_u_name(1, fifoContent, fifoIdx, ures, "loop_filter_across_tiles_enabled_flag   ");
                pps_loop_filter_across_tile_enabled_flag[pps_id] := ures[0];
	        end
	        
	        vld_u_name(1, fifoContent, fifoIdx, ures, "loop_filter_across_slices_enabled_flag      ");
	        pps_loop_filter_across_slice_enabled_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "deblocking_filter_control_present_flag      ");
	        pps_deblocking_filter_control_present_flag[pps_id] := ures[0];
			deblocking_filter_override_enabled_flag[pps_id] := 0;
	        if pps_deblocking_filter_control_present_flag[pps_id] = 1 then
	            vld_u_name(1, fifoContent, fifoIdx, ures, "deblocking_filter_override_enabled_flag ");
	            deblocking_filter_override_enabled_flag[pps_id] := ures[0];
	            vld_u_name(1, fifoContent, fifoIdx, ures, "pps_disable_deblocking_filter_flag      ");
	            pps_disable_deblocking_filter_flag[pps_id] := ures[0];
	            if ures[0] = 0 then
	                vld_se_name(fifoContent, fifoIdx, ires, "pps_beta_offset_div2                  ");
	                pps_beta_offset[pps_id] := ires[0] << 1;
	                vld_se_name(fifoContent, fifoIdx, ires, "pps_tc_offset_div2                    ");
	                pps_tc_offset[pps_id] := ires[0] << 1;
	            end
	            
	        end
	        
	        vld_u_name(1, fifoContent, fifoIdx, ures, "pps_scaling_list_data_present_flag          ");
	        pps_scaling_list_data_present_flag[pps_id] := ures[0];
	        if pps_scaling_list_data_present_flag[pps_id] = 1 then
	        	parse_pps_scaling_list_data();
	        end
	        
	    	load_fifo();
			vld_u_name(1, fifoContent, fifoIdx, ures, "lists_modification_present_flag             ");
	    	pps_lists_modification_present_flag[pps_id] := ures[0];
	        vld_ue_name(fifoContent, fifoIdx, ures, "log2_parallel_merge_level_minus2              ");
	        pps_log2_parallel_merge_level[pps_id] := ures[0] + 2;
	        vld_u_name(1, fifoContent, fifoIdx, ures, "slice_segment_header_extension_present_flag");
	        pps_slice_segment_header_extension_present_flag[pps_id] := ures[0];
	        vld_u_name(1, fifoContent, fifoIdx, ures, "pps_extension_flag                          ");
	        if ures[0] = 1 then
	        	parse_pps_extension();
	        end

	        set_pps_drived_vars();
	    end
	        
	
	        /**************************************************************************
	         **************************************************************************
	         ********        Slice HEADER                         *********************
	         **************************************************************************
	         *************************************************************************/
	
	        /**************************************************************************
	         * read_SliceHeader.se_idx_1
	         *************************************************************************/
	    uint(size= 8) Log2CtbSize;
	    uint(size= 8) Log2MinCbSize;
	    uint(size=16) PicWidthInCtbsY;
	    uint(size=16) PicHeightInCtbsY;
	    uint(size=16) PicSizeInCtbsY;
	    uint(size=16) nbMaxCUsPerCTU;
		uint(size=16) PictSize[2];

        uint(size= 8) Log2MinTrafoSize;
        uint(size= 8) Log2MaxTrafoSize;
        uint(size=16) ctbAddrRStoTS[CTB_ADDR_TS_MAX];
        uint(size=16) ctbAddrTStoRS[CTB_ADDR_TS_MAX];
        uint(size=16) TileId[CTB_ADDR_TS_MAX];
        uint(size=16) nbCtbTile[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
        uint(size=16) nbCtbPerTile[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
        uint(size=16) colTileInPix[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
        uint(size=16) rowTileInPix[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
        uint(size=16) colWidth[NB_MAX_PPS][PICT_WIDTH / MIN_CTB_SIZE_Y];
        uint(size=16) rowHeight[NB_MAX_PPS][PICT_HEIGHT / MIN_CTB_SIZE_Y];

	    procedure set_sps_drived_vars()
	    begin
	        Log2MinCbSize     := sps_log2_min_coding_block_size[sps_id] ;
	        Log2CtbSize       := Log2MinCbSize + sps_log2_diff_max_min_coding_block_size[sps_id];
	        Log2MinTrafoSize  := sps_log2_min_transform_block_size[sps_id];
	        Log2MaxTrafoSize  := Log2MinTrafoSize + sps_log2_diff_max_min_transform_block_size[sps_id];
	        nbMaxCUsPerCTU	  := (1 << Log2CtbSize) >> Log2MinCbSize;
		    PictSize[0]		  := sps_pic_width_in_luma_samples[sps_id];
		    PictSize[1]		  := sps_pic_height_in_luma_samples[sps_id];
	        PicWidthInCtbsY   := ( sps_pic_width_in_luma_samples[sps_id]  + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
	        PicHeightInCtbsY  := ( sps_pic_height_in_luma_samples[sps_id] + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
	        PicSizeInCtbsY    := PicWidthInCtbsY * PicHeightInCtbsY;	    	
	    end

	    procedure set_pps_drived_vars()
	    var
			uint(size=16) column_width[PICT_WIDTH / MIN_CTB_SIZE_Y]	= [pps_column_width[pps_id][ i ] : for int i in 0 .. (PICT_WIDTH / MIN_CTB_SIZE_Y)-1],
		    uint(size=16) row_height[PICT_HEIGHT / MIN_CTB_SIZE_Y]  = [pps_row_height[pps_id][ i ] : for int i in 0 .. (PICT_HEIGHT / MIN_CTB_SIZE_Y)-1],
		    uint(size= 8) num_tile_columns_minus1           		= pps_num_tile_columns_minus1[pps_id],
		    uint(size= 8) num_tile_rows_minus1                      = pps_num_tile_rows_minus1[pps_id],
		    uint(size= 1) uniform_spacing_flag                      = pps_uniform_spacing_flag[pps_id],

            uint(size=16) ColBd[PICT_WIDTH / MIN_CTB_SIZE_Y],
            uint(size=16) RowBd[PICT_HEIGHT / MIN_CTB_SIZE_Y],
            uint(size=16) tileX,
            uint(size=16) tileY,
            uint(size=16) val,
            uint(size=16) tbX,
            uint(size=16) tbY,
            uint(size=16) tIdx,
            uint count := 0
	    begin
	        if num_tile_columns_minus1 >= (PICT_WIDTH / MIN_CTB_SIZE_Y) then
	            println("Error read_SliceData.init : ColumnWidth : "+num_tile_columns_minus1+" >= "+(PICT_WIDTH / MIN_CTB_SIZE_Y));
	        end
	        if uniform_spacing_flag = 1 then
	            foreach int i in 0 .. num_tile_columns_minus1 do
	                colWidth[pps_id][ i ] := ((i + 1)*PicWidthInCtbsY) / (num_tile_columns_minus1+1) - (i*PicWidthInCtbsY) / (num_tile_columns_minus1+1);
	                colTileInPix[ i + 1 ] :=   (colWidth[pps_id][ i ] << Log2CtbSize) + colTileInPix[ i ];
	                if i = num_tile_columns_minus1 then
	                    colTileInPix[ i + 1 ] := PictSize[0];
	                end
	            end
	        else
	            colWidth[pps_id][ num_tile_columns_minus1 ] := PicWidthInCtbsY;
	            if num_tile_columns_minus1 = 0 then
	            	colTileInPix[ 1 ] := PictSize[0];
	            else
		            foreach int i in 0 .. num_tile_columns_minus1 - 1 do
		                colWidth[pps_id][ i ] := column_width[ i ] ;
		                colWidth[pps_id][ num_tile_columns_minus1 ] := colWidth[pps_id][ num_tile_columns_minus1 ] - colWidth[pps_id][ i ];
		                colTileInPix[ i + 1 ] :=   (colWidth[pps_id][ i ] << Log2CtbSize) + colTileInPix[ i ];
		                if i = num_tile_columns_minus1 - 1 then
		                    colTileInPix[ i + 2 ] := PictSize[0];
		                end
		            end
		    	end
	        end

	        if num_tile_rows_minus1 >= (PICT_HEIGHT / MIN_CTB_SIZE_Y) then
	            println("Error read_SliceData.init : RowHeight : "+num_tile_rows_minus1+" >= "+(PICT_HEIGHT / MIN_CTB_SIZE_Y));
	        end
	        if uniform_spacing_flag = 1 then
	            foreach int i in 0 .. num_tile_rows_minus1 do
	                rowHeight[pps_id][ i ] := ((i+1)*PicHeightInCtbsY) / (num_tile_rows_minus1+1) - (i*PicHeightInCtbsY) / (num_tile_rows_minus1+1);
	                rowTileInPix[ i + 1 ] :=   (rowHeight[pps_id][ i ] << Log2CtbSize) + rowTileInPix[ i ];
	                if i = num_tile_rows_minus1 then
	                    rowTileInPix[ i + 1 ] := PictSize[1];
	                end
	            end
	        else
	            rowHeight[pps_id][ num_tile_rows_minus1 ] := PicHeightInCtbsY;
	            if num_tile_rows_minus1 = 0 then
	            	rowTileInPix[ 1 ] := PictSize[1];
	            else 
		            foreach int i in 0 .. num_tile_rows_minus1 - 1 do
		                rowHeight[pps_id][ i ] := row_height[ i ];
		                rowHeight[pps_id][ num_tile_rows_minus1 ] := rowHeight[pps_id][ num_tile_columns_minus1 ] - rowHeight[pps_id][ i ];
		                rowTileInPix[ i + 1 ] :=   (rowHeight[pps_id][ i ] << Log2CtbSize) + rowTileInPix[ i ];
		                if i = num_tile_rows_minus1 - 1 then
		                    rowTileInPix[ i + 2 ] := PictSize[1];
		                end
		            end
		    	end
	        end

            foreach int i in 0 .. num_tile_rows_minus1 do
            	foreach int j in 0 .. num_tile_columns_minus1 do
            		nbCtbPerTile[count] := rowHeight[pps_id][i] * colWidth[pps_id][j];
            		if count = 0 then
            			nbCtbTile[count] := rowHeight[pps_id][i] * colWidth[pps_id][j];
            		else
            			nbCtbTile[count] := nbCtbTile[count - 1] + rowHeight[pps_id][i] * colWidth[pps_id][j];
            		end
            		count := count + 1;
            	end
            end
            ColBd[0] := 0;
            foreach int i in 0 .. num_tile_columns_minus1 do
            	ColBd[i + 1] := ColBd[i] + colWidth[pps_id][i];
            end
            RowBd[0] := 0;
            foreach int i in 0 .. num_tile_rows_minus1 do
            	RowBd[i + 1] := RowBd[i] + rowHeight[pps_id][i];
            end

            /*********************************************************************
             * 6.5 Conversion process for coding tree block address
             * in coding tree block raster order to tile scan order
             ********************************************************************/
            if PicHeightInCtbsY * PicWidthInCtbsY >= CTB_ADDR_TS_MAX then
                    println("Error read_SliceData.init : CtbAddrTS : "+(PicHeightInCtbsY * PicWidthInCtbsY)+" >= "+CTB_ADDR_TS_MAX);
            end
            foreach int ctbAddrRS_v in 0 .. PicSizeInCtbsY - 1 do
                    tbX   := ctbAddrRS_v mod PicWidthInCtbsY;
                    tbY   := ctbAddrRS_v / PicWidthInCtbsY;
                    tileX := 0;
                    tileY := 0;
                    foreach int i in 0 .. num_tile_columns_minus1 do
                            if tbX < ColBd[i + 1] then
                                    tileX := i;
                                    i := num_tile_columns_minus1;
                            end
                    end
                    foreach int j in 0 .. num_tile_rows_minus1 do
                            if tbY < RowBd[j + 1] then
                                    tileY := j;
                                    j := num_tile_rows_minus1;
                            end
                    end
                    val := 0;
                    foreach int i in 0 .. tileX-1 do
                            val := val + rowHeight[pps_id][ tileY ] * colWidth[pps_id][ i ];
                    end
                    foreach int j in 0 .. tileY-1 do
                            val := val + PicWidthInCtbsY * rowHeight[pps_id][ j ];
                    end
                    val                                              := val + ( tbY - RowBd[tileY] ) * colWidth[pps_id][tileX] + tbX - ColBd[tileX];
                    ctbAddrRStoTS[ ctbAddrRS_v ] := val;
                    ctbAddrTStoRS[ val ]             := ctbAddrRS_v;
            end

            tIdx := 0;
            foreach int j in 0 .. num_tile_rows_minus1 do
                    foreach int i in 0 .. num_tile_columns_minus1 do
                            foreach int y in RowBd[ j ] .. RowBd[ j + 1 ] - 1 do
                                    foreach int x in ColBd[ i ] .. ColBd[ i + 1 ] - 1 do
                                            TileId[ ctbAddrRStoTS[ y*PicWidthInCtbsY + x ] ] := tIdx;
                                    end
                            end
                            tIdx := tIdx + 1;
                    end
            end
	    end

	    uint(size= 1) slice_temporal_mvp_enable_flag;
	    uint(size= 1) slice_loop_filter_across_slices_enabled_flag;
	    uint(size= 3) slice_type;
	    uint(size=32) slice_segment_address;
	    uint(size= 1) slice_sample_adaptive_offset_flag[4];
	     int(size=32) poc;

		procedure compute_POC(int pic_order_cnt_lsb)
		var
		     int iPOClsb = pic_order_cnt_lsb,
		     int iPrevPOC = poc,
		     int iMaxPOClsb := max_poc_lsb[sps_id],
		     int iPrevPOClsb := iPrevPOC & (iMaxPOClsb - 1),
		     int iPrevPOCmsb := iPrevPOC - iPrevPOClsb,
		     int iPOCmsb
		begin
		    if( (iPOClsb < iPrevPOClsb) and ( (iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2) ) ) then
		    	iPOCmsb := iPrevPOCmsb + iMaxPOClsb;
		    elsif( (iPOClsb > iPrevPOClsb) and ( (iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2) ) ) then
		 		iPOCmsb := iPrevPOCmsb - iMaxPOClsb;
		   	else
				iPOCmsb := iPrevPOCmsb;
			end
			
			if (nal_unit_type = NAL_BLA_W_LP   or
	       		nal_unit_type = NAL_BLA_W_RADL or
	       		nal_unit_type = NAL_BLA_N_LP)
	        then
	        	iPOCmsb := 0;
	       	end
	        
		    poc := iPOCmsb + iPOClsb;
		end
	
	    uint(size= 1) first_slice_segment_in_pic_flag := 1;
	    uint(size= 1) dependent_slice_segment_flag;
	    uint(size=16) num_long_term_sps := 0;
	    uint(size=16) num_long_term_pics := 0;
	    uint(size= 8) poc_lsb_lt[32];
	    uint(size= 8) UsedByCurrPicLt[32];
	    uint(size= 8) DeltaPocMsbCycleLt[32];
	    uint(size= 8) delta_poc_msb_present_flag[32];
	    int pic_order_cnt_lsb;
	    uint slice_addr := 0;
	    uint no_output_of_prior_pics_flag;
	    uint pic_output_flag;
		uint(size= 4) part_mode;
		bool skipCurrentNal := false;
	    
	    read_SliceHeader.se_idx_1 : action ==>
	    guard
	        se_idx = 1
	    var
	        uint(size=32) res[1]
	    do
	    	load_fifo();
	        vld_u_name(1, fifoContent, fifoIdx, res, "first_slice_segment_in_pic_flag         		");
	        first_slice_segment_in_pic_flag := res[0];

	        no_output_of_prior_pics_flag := 0;
			if isIRAP(nal_unit_type) then
				vld_u_name(  1, fifoContent, fifoIdx, res, "no_output_of_prior_pics_flag            ");
				no_output_of_prior_pics_flag := res[0];
			end
	        vld_ue_name(fifoContent, fifoIdx, res, "slice_pic_parameter_set_id              		");
	        pps_id := res[0];
	        if(pps_id_decoded[pps_id] = false) then
	        	skipCurrentNal := true;
 	        else
	        	if(first_slice_segment_in_pic_flag = 1) then
	        		md5_needed := need_md5;
	        		need_md5 := true;
	        	end
		        sps_id := pps_sps_id[pps_id];
		        dependent_slice_segment_flag := 0;
		
		        load_fifo();
		        if first_slice_segment_in_pic_flag = 0 then
		        	if (pps_dependent_slice_segments_enabled_flag[pps_id] = 1) then
		                vld_u_name(  1, fifoContent, fifoIdx, res, "dependent_slice_segment_flag                    			");
		                dependent_slice_segment_flag := res[0];
		            end
		        	vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifoContent, fifoIdx, res, "slice_segment_address                  ");
		            slice_segment_address := res[0];
		           	if (dependent_slice_segment_flag = 0) then
		                slice_addr := slice_segment_address;
		            end
		       	else
		            slice_segment_address := 0;
		            slice_addr := 0;
		        end
		        
		        if first_slice_segment_in_pic_flag = 1 then
		            part_mode := PART_MODE_PICT;
		        elsif dependent_slice_segment_flag = 0 then
		            part_mode := PART_MODE_SLICE_INDEP;
		        else
		            part_mode := PART_MODE_SLICE_DEP;
		        end
		        se_idx := 400;
			end
	    end

		read_SliceHeader.sendMD5.launch: action ==> SEI_MD5:[0, 0, 0], PartMode:[part_mode]
		guard
			se_idx = 400 and first_slice_segment_in_pic_flag = 1 and
			md5_needed
		do
	        if dependent_slice_segment_flag = 0 then
	        	se_idx := 200;
	        else
	        	se_idx := 6;
	        end

	        // Tokens Count
	        nbTokensPerSH[11] := nbTokensPerSH[11] + 3; // SEI_MD5
	        nbTokensPerSH[4] := nbTokensPerSH[4] + 1;	// PartMode
		end

		read_SliceHeader.sendMD5.skip: action ==> PartMode:[part_mode]
		guard
			se_idx = 400 and (first_slice_segment_in_pic_flag = 0 or
			not md5_needed)
		do
	        if dependent_slice_segment_flag = 0 then
	        	se_idx := 200;
	        else
	        	se_idx := 6;
	        end

	        // Tokens Count
	        nbTokensPerSH[4] := nbTokensPerSH[4] + 1;	// PartMode        
	    end
        
	    read_SliceHeader.se_idx_11 : action ==> Poc:[poc], SliceType:[slice_type]
	    guard
	            se_idx = 200
	    var
	        uint(size=32) res[1],
	        uint(size= 8) numbits := 0
	    do
			load_fifo();
			foreach int i in 0 .. (pps_num_extra_slice_header_bits[pps_id] - 1) do
	            vld_u_name(1, fifoContent, fifoIdx, res, "slice_reserved_flag[i]									");
	        end
	        load_fifo();
	        vld_ue_name(fifoContent, fifoIdx, res, "slice_type														");
	        slice_type := res[0];

	        pic_output_flag := 1;
			if(pps_output_flag_present_flag[pps_id] = 1) then
				vld_u_name(  1, fifoContent, fifoIdx, res, "pic_output_flag											");
				pic_output_flag := res[0];
			end
	        if sps_separate_colour_plane_flag[sps_id] = 1 then
	        	vld_u_name(2, fifoContent, fifoIdx, res, "colour_plane_id											");
	    	end
	    	if nal_unit_type = NAL_IDR_W_RADL or nal_unit_type = NAL_IDR_N_LP then
	        	poc := 0;
	        else
	        	load_fifo();
	        	vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifoContent, fifoIdx, res, "slice_pic_order_cnt_lsb");
	            pic_order_cnt_lsb := res[0];
	            compute_POC(res[0]);	//compute the number of POC
	            vld_u_name(1, fifoContent, fifoIdx, res, "short_term_ref_pic_set_sps_flag							");
	            if res[0] != 0 then
	                while ((1 << numbits) < sps_num_short_term_ref_pic_sets[sps_id]) do
	                    numbits := numbits + 1;
	                end
	           		res[0] := 0;
	            	if (numbits > 0) then
	            		load_fifo();
	                	vld_u_name(   numbits, fifoContent, fifoIdx, res, "short_term_ref_pic_set_idx				");
	           		end
	                pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]] := [pcRPS[sps_id][res[0]][i] : for int i in 0 .. PC_RPS_STRUCT_SIZE - 1];
	    			parseSliceHeaderLongtermPics();
	       		else
	    			parseShortTermRefPicSet(sps_num_short_term_ref_pic_sets[sps_id]);
	    			parseSliceHeaderLongtermPics();
	    		end
	    		
				if sps_temporal_mvp_enable_flag[sps_id] = 1 then
					vld_u_name(1, fifoContent, fifoIdx, res, "slice_temporal_mvp_enable_flag						");
					slice_temporal_mvp_enable_flag := res[0];
				else
					slice_temporal_mvp_enable_flag := 0;
				end
	    	end

 		    parseSliceHeaderSaoParams();
        	parseSliceHeaderRefPicListsIndices();

            se_idx := 10;
            cnt_i := 0;

            // Tokens Count
	        nbTokensPerSH[9] := nbTokensPerSH[9] + 1;   // Poc
	        nbTokensPerSH[12] := nbTokensPerSH[12] + 1; // SliceType
		end
		
		procedure parseShortTermRefPicSet(uint(size=8) idxRps)
	    var
			uint(size=32) res[1],
			uint(size= 1) inter_rps_flag := 0,
			uint(size=16) delta_idx      := 1,
			uint(size= 8) rIdx,
			 int(size=32) deltaRPS,
			 int(size=32) deltaPOC,
			 int(size=32) k    := 0,
			 int(size=32) k0   := 0,
			 int(size=32) k1   := 0,
			 int(size=32) delta_rps_sign,
			 int(size=32) abs_delta_rps,
			 int(size=32) prev := 0
   		begin
   			load_fifo();
	 		if idxRps != 0 then
	 			vld_u_name(1, fifoContent, fifoIdx, res, "inter_ref_pic_set_prediction_flag				"); 
	 			inter_rps_flag := res[0];
	 		end

			if inter_rps_flag = 1 then
				if idxRps = sps_num_short_term_ref_pic_sets[sps_id] then
		  			vld_ue_name(fifoContent, fifoIdx, res, "delta_idx_minus1                        	");
		  			delta_idx := res[0] + 1;
				end
	    		rIdx := idxRps - delta_idx;
	    		vld_u_name(1, fifoContent, fifoIdx, res, "delta_rps_sign								");
	    		delta_rps_sign	:= res[0];
	    		load_fifo();
	    		vld_ue_name(fifoContent, fifoIdx, res, "abs_delta_rps_minus1							");
	    		abs_delta_rps := res[0] + 1;
	    		deltaRPS := (1 - (delta_rps_sign<<1)) * (abs_delta_rps);
	    		foreach uint(size=8) i in 0 ..  pcRPS[sps_id][rIdx][NUM_PICS] do
	    			load_fifo();
	    			vld_u_name(1, fifoContent, fifoIdx, res, "used_by_curr_pic_flag						");
	    			if res[0] = 0 then
		    			vld_u_name(1, fifoContent, fifoIdx, res, "use_delta_flag						");
		    			res[0] := res[0] << 1;
	    			end
	    			if res[0] = 1 or res[0] = 2 then
	    				if i < pcRPS[sps_id][rIdx][NUM_PICS] then
	    					deltaPOC := deltaRPS + pcRPS[sps_id][rIdx][DELTAPOC+i];
	    				else
	    					deltaPOC := deltaRPS;
						end
						pcRPS[sps_id][idxRps][DELTAPOC+k] := deltaPOC;
						pcRPS[sps_id][idxRps][USED+k] := if res[0] = 1 then 1 else 0 end;
				        if deltaPOC < 0 then
	          				k0 := k0 + 1;
	        			else 
	          				k1 := k1 + 1;
	        			end
	        			k := k + 1;
	    			end
	    		end
	    		pcRPS[sps_id][idxRps][NUM_PICS]          := k;
	    		pcRPS[sps_id][idxRps][NUM_NEGATIVE_PICS] := k0;
				pcRPS[sps_id][idxRps][NUM_POSITIVE_PICS] := k1;
				sortDeltaPOC(sps_id, idxRps, pcRPS);
	  		else
	    		vld_ue_name(fifoContent, fifoIdx, res, "num_negative_pics                       		");
	    		pcRPS[sps_id][idxRps][NUM_NEGATIVE_PICS] := res[0];
	    		vld_ue_name(fifoContent, fifoIdx, res, "num_positive_pics                       		");
	    		pcRPS[sps_id][idxRps][NUM_POSITIVE_PICS] := res[0];
	    		pcRPS[sps_id][idxRps][NUM_PICS] := pcRPS[sps_id][idxRps][NUM_NEGATIVE_PICS] + res[0];

	    		if pcRPS[sps_id][idxRps][NUM_NEGATIVE_PICS] != 0 then
	    			prev := 0;
	    			foreach int i in 0 .. (pcRPS[sps_id][idxRps][NUM_NEGATIVE_PICS]-1) do
						load_fifo();
						vld_ue_name(fifoContent, fifoIdx, res, "delta_poc_s0_minus1						");
						prev := prev-res[0]-1;
						pcRPS[sps_id][idxRps][DELTAPOC+i] := prev;
						vld_u_name(1, fifoContent, fifoIdx, res, "used_by_curr_pic_s0_flag				");
						pcRPS[sps_id][idxRps][USED+i] := res[0];
	    			end
	    			
	    		end

				if pcRPS[sps_id][idxRps][NUM_POSITIVE_PICS] != 0 then
					prev := 0;
    				foreach int i in pcRPS[sps_id][idxRps][NUM_NEGATIVE_PICS] .. (pcRPS[sps_id][idxRps][NUM_PICS] - 1) do
						load_fifo();
						vld_ue_name(fifoContent, fifoIdx, res, "delta_poc_s1_minus1						");
						prev := prev+res[0]+1;
						pcRPS[sps_id][idxRps][DELTAPOC+i] := prev;
						vld_u_name(1, fifoContent, fifoIdx, res, "used_by_curr_pic_s1_flag				");
						pcRPS[sps_id][idxRps][USED+i] := res[0];
    				end
				end
	    	end
	    end

		procedure parseSliceHeaderLongtermPics()
		var
			uint(size=32) res[1],
			uint(size= 8) lt_idx_sps := 0,
			uint(size= 8) prevDeltaMSB := 0
		begin
			load_fifo();
			num_long_term_sps := 0;
			num_long_term_pics := 0;
			
			if sps_long_term_ref_pics_present_flag[sps_id] = 1 then
				if sps_num_long_term_ref_pics_sps[sps_id] > 0 then
					vld_ue_name(fifoContent, fifoIdx, res, "num_long_term_sps                       ");
					num_long_term_sps := res[0];
				end
			    vld_ue_name(fifoContent, fifoIdx, res, "num_long_term_pics							");
			    num_long_term_pics := res[0];
			    foreach int i in 0 .. (num_long_term_sps + num_long_term_pics - 1) do
			    	load_fifo();
			    	if i < num_long_term_sps then
			    		if num_long_term_pics > 1 then
			                vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifoContent, fifoIdx, res, "lt_idx_sps");
			                lt_idx_sps := res[0];
			        	end
			            poc_lsb_lt[i] := lt_ref_pic_poc_lsb_sps[lt_idx_sps];
			            UsedByCurrPicLt[i] := used_by_curr_pic_lt_sps_flag[lt_idx_sps];
			    	else
			            vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifoContent, fifoIdx, res, "poc_lsb_lt");
			            poc_lsb_lt[i] := res[0];
			            vld_u_name(1, fifoContent, fifoIdx, res, "used_by_curr_pic_lt_flag			");
			            UsedByCurrPicLt[i] :=  res[0];
			        end

			        vld_u_name(1, fifoContent, fifoIdx, res, "delta_poc_msb_present_flag			");
			        delta_poc_msb_present_flag[i] := res[0];
			        if res[0] = 1 then
			    		vld_ue_name(fifoContent, fifoIdx, res, "delta_poc_msb_cycle_lt_minus1		");
			    		DeltaPocMsbCycleLt[i] := res[0];

			        	if( i != 0 && i != num_long_term_sps ) then
			                DeltaPocMsbCycleLt[i] := DeltaPocMsbCycleLt[i] + prevDeltaMSB;
			            end
			        else
			        	if( i != num_long_term_sps ) then
			                DeltaPocMsbCycleLt[i] := 0;
			            end
			        end
			        prevDeltaMSB := DeltaPocMsbCycleLt[i];	                    
			    end
			end
		end
		
		procedure parseSliceHeaderSaoParams()
		var
			uint(size=32) res[1]
		begin
		    load_fifo();
	        if( sps_sample_adaptive_offset_enabled_flag[sps_id] = 1) then
	            vld_u_name(1, fifoContent, fifoIdx, res, "slice_sao_luma_flag                     ");
	            slice_sample_adaptive_offset_flag[0] := res[0];
	            vld_u_name(1, fifoContent, fifoIdx, res, "slice_sao_chroma_flag                   ");
	            slice_sample_adaptive_offset_flag[1] := res[0];
	            slice_sample_adaptive_offset_flag[2] := res[0];
	        else
	            slice_sample_adaptive_offset_flag[0] := 0;
	    		slice_sample_adaptive_offset_flag[1] := 0;
	    		slice_sample_adaptive_offset_flag[2] := 0;
	        end
		end

        uint(size= 8) num_ref_idx_l0_active;
        uint(size= 8) num_ref_idx_l1_active;
        uint(size= 1) mvd_l1_zero_flag;
        uint(size= 8) ref_pic_list_modification_flag_lx[2] := [0,0];
        uint(size=4) list_entry_lx [2][32];

        uint(size=16) MaxNumMergeCand;
        uint(size= 1) cabac_init_flag;
        uint(size= 1) collocated_from_lX := 0;
        uint(size= 3) collocated_ref_idx := 0;
        uint(size= 2) weighted_pred_flag := 0;
                
        procedure parseSliceHeaderRefPicListsIndices()
        var
	        uint(size=32) res[1],
	        int NumPocTotalCurr := 0,
	        uint(size= 1) collocated_from_l0_flag := 1
        begin
            load_fifo();
			num_ref_idx_l0_active    := 0;
            num_ref_idx_l1_active    := 0;
            mvd_l1_zero_flag         := 0;

			cabac_init_flag		:= 0;
			collocated_from_lX	:= 0;
			collocated_ref_idx	:= 0;
            weighted_pred_flag	:= 0;
            
            if slice_type = P_SLICE or slice_type = B_SLICE then
                vld_u_name(1, fifoContent, fifoIdx, res, "num_ref_idx_active_override_flag					");
                if res[0] = 1 then
                    vld_ue_name(fifoContent, fifoIdx, res, "num_ref_idx_l0_active_minus1					");
                    num_ref_idx_l0_active := res[0] + 1;
                    if slice_type = B_SLICE then
                    	load_fifo();
                        vld_ue_name(fifoContent, fifoIdx, res, "num_ref_idx_l1_active_minus1				");
                        num_ref_idx_l1_active := res[0] + 1;
                    end
                else
	                num_ref_idx_l0_active := pps_num_ref_idx_l0_default_active_minus1[pps_id] + 1;
	                num_ref_idx_l1_active := pps_num_ref_idx_l1_default_active_minus1[pps_id] + 1;
                end

                ref_pic_list_modification_flag_lx[0] := 0;
                ref_pic_list_modification_flag_lx[1] := 0;

                foreach int i in 0 .. (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS]- 1) do
                	if (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED + i] = 1) then
                		NumPocTotalCurr := NumPocTotalCurr + 1;
                	end
                end

                foreach int i in pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS] .. (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_PICS]-1) do
                    if (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+i] = 1) then
                        NumPocTotalCurr := NumPocTotalCurr + 1;
                    end
                end

                foreach int i in 0 .. (num_long_term_sps + num_long_term_pics - 1) do
                    if (UsedByCurrPicLt[i] = 1) then
                        NumPocTotalCurr := NumPocTotalCurr + 1;
                    end
                end

                if pps_lists_modification_present_flag[pps_id] = 1 and NumPocTotalCurr > 1 then
                    vld_u_name(1, fifoContent, fifoIdx, res, "ref_pic_list_modification_flag_l0				");
                    ref_pic_list_modification_flag_lx[0] := res[0];
                    if ref_pic_list_modification_flag_lx[0] = 1 then
                        foreach int i in 0 .. (num_ref_idx_l0_active - 1) do
                        	load_fifo();
                            vld_u_name(log2((NumPocTotalCurr-1)<<1) , fifoContent, fifoIdx, res, "list_entry_lx");
                            list_entry_lx[0][i] := res[0];
                        end
                    end

                    if slice_type = B_SLICE then
                        vld_u_name(1, fifoContent, fifoIdx, res, "ref_pic_list_modification_flag_l1			");
                        ref_pic_list_modification_flag_lx[1] := res[0];
                        if ref_pic_list_modification_flag_lx[1] = 1 then
                            foreach int i in 0 .. (num_ref_idx_l1_active - 1) do
                            	load_fifo();
                                vld_u_name(log2((NumPocTotalCurr-1)<<1) , fifoContent, fifoIdx, res, "list_entry_lx");
                                list_entry_lx[1][i] := res[0];
                            end
                        end
                    end
                end

                if slice_type = B_SLICE then
                    vld_u_name(1, fifoContent, fifoIdx, res, "mvd_l1_zero_flag								");
                    mvd_l1_zero_flag := res[0];
               	end

				load_fifo();
				if pps_cabac_init_present_flag[pps_id] = 1 then
					vld_u_name(1, fifoContent, fifoIdx, res, "cabac_init_flag								");
					cabac_init_flag := res[0];
				end
				if slice_temporal_mvp_enable_flag = 1 then
					res[0] := 1;
					if( slice_type = B_SLICE ) then
						vld_u_name(1, fifoContent, fifoIdx, res, "collocated_from_l0_flag					");
						collocated_from_l0_flag := res[0];
						collocated_from_lX := res[0];
					end
				    if ( collocated_from_l0_flag = 1 and num_ref_idx_l0_active > 1 ) or 
				       ( collocated_from_l0_flag = 0 and num_ref_idx_l1_active > 1 ) then
						vld_ue_name(fifoContent, fifoIdx, res, "collocated_ref_idx							");
						collocated_ref_idx := res[0];
					end
				end
				if pps_weighted_pred_flag[pps_id] = 1 or pps_weighted_bipred_flag[pps_id] = 1 then
					weighted_pred_flag := 1;
				end
            end
        end
        /**************************************************************************
         * read_SliceHeader.sendRefPOC
         *************************************************************************/
        int(size=16)  pocTables[5][NB_MAX_PICS];
        int numPic[5];
        uint(size= 8) idxNumPic;
        uint(size= 8) idxRefPoc;

        procedure setRefTables(int sps_id, int idx, int(size=8) pc_rps[NB_MAX_SPS][NB_MAX_PICS+1][PC_RPS_STRUCT_SIZE], int poc)
        var
                uint j := 0,
                uint k := 0,
                int pocLt := poc_lsb_lt[0]
        begin
                foreach int i in 0 .. pc_rps[sps_id][idx][NUM_NEGATIVE_PICS] - 1
                do
	            	if (pc_rps[sps_id][idx][USED + i] = 1) then
	            		pocTables[ST_CURR_BEF][j] := poc + pc_rps[sps_id][idx][DELTAPOC + i];
	            		j := j + 1;
	            		
	            	else
	            		pocTables[ST_FOLL][k] := poc + pc_rps[sps_id][idx][DELTAPOC + i];
	            		k := k + 1;
	            		
	            	end
                end
                numPic[ST_CURR_BEF] := j;
                j := 0;
                foreach int i in
                pc_rps[sps_id][idx][NUM_NEGATIVE_PICS] ..
                pc_rps[sps_id][idx][NUM_PICS] - 1 do
                	if (pc_rps[sps_id][idx][USED + i] = 1) then
                		pocTables[ST_CURR_AFT][j] := poc + pc_rps[sps_id][idx][DELTAPOC + i];
                		j := j + 1;
                		
                	else
                		pocTables[ST_FOLL][k] := poc + pc_rps[sps_id][idx][DELTAPOC + i];
                		k := k + 1;
                	end
                end
                numPic[ST_CURR_AFT] := j;
                numPic[ST_FOLL] := k;
                j := 0;
                k := 0;
                foreach int i in 0 .. (num_long_term_sps + num_long_term_pics) - 1 do
                	pocLt := poc_lsb_lt[i];
                	if delta_poc_msb_present_flag[i] = 1 then
                		pocLt := pocLt + poc - DeltaPocMsbCycleLt[i] * max_poc_lsb[sps_id] - pic_order_cnt_lsb;
                	end
                	if UsedByCurrPicLt[i] = 1 then
                		pocTables[LT_CURR][j] := pocLt;
                		j := j + 1;
                	else
                		pocTables[LT_FOLL][k] := pocLt;
                		k := k + 1;
                	end
                end
                numPic[LT_CURR] := j;
                numPic[LT_FOLL] := k;
        end

        read_SliceHeader.sendRefPOC.init : action ==> NumRefIdxLxActive:[num_ref_idx_l0_active, num_ref_idx_l1_active]
        guard
                se_idx = 10
        do
                if(poc != 0) then
                	setRefTables(sps_id, sps_num_short_term_ref_pic_sets[sps_id], pcRPS, poc);
                else
                	numPic := [0: for int i in 0 .. 4];
                end	

                idxNumPic := 0;
                se_idx    := 101;
                
		        // Tokens Count
		        nbTokensPerSH[16] := nbTokensPerSH[16] + 2; // NumRefIdxLxActive
        end

        read_SliceHeader.sendListEntryL0Flag : action ==> RefPicListModif:[ref_pic_list_modification_flag_lx[0]]
        guard
                se_idx = 101
        do
                if ref_pic_list_modification_flag_lx[0] = 0 then
                        se_idx := 201;
                else
                        se_idx := 102;
                end

		        // Tokens Count
		        nbTokensPerSH[17] := nbTokensPerSH[17] + 1; // RefPicListModif
        end

        read_SliceHeader.sendListEntryL0Loop : action ==> RefPicListModif:[list_entry_lx[0][cnt_i - 1]]
        guard
                se_idx = 102,
                cnt_i < num_ref_idx_l0_active
        do
                cnt_i := cnt_i + 1;
                
		        // Tokens Count
		        nbTokensPerSH[17] := nbTokensPerSH[17] + 1; // RefPicListModif              
        end

        read_SliceHeader.sendListEntryL0End : action ==>
        guard
                se_idx = 102,
                cnt_i = num_ref_idx_l0_active
        do
                cnt_i := 0;
                se_idx := 201;
        end

        read_SliceHeader.sendListEntryL1Flag : action ==> RefPicListModif:[ref_pic_list_modification_flag_lx[1]]
        guard
                se_idx = 201
        do
                if ref_pic_list_modification_flag_lx[1] = 0 then
                        se_idx := 11;
                else
                        se_idx := 202;
                end
                
	        // Tokens Count
	        nbTokensPerSH[17] := nbTokensPerSH[17] + 1; // RefPicListModif
        end

        read_SliceHeader.sendListEntryL1Loop : action ==> RefPicListModif:[list_entry_lx[1][cnt_i - 1]]
        guard
                se_idx = 202,
                cnt_i < num_ref_idx_l1_active
        do
                cnt_i := cnt_i + 1;
                
	        // Tokens Count
	        nbTokensPerSH[17] := nbTokensPerSH[17] + 1; // RefPicListModif
        end

        read_SliceHeader.sendListEntryL1End : action ==>
        guard
                se_idx = 202,
                cnt_i = num_ref_idx_l1_active
        do
                cnt_i := 0;
                se_idx    := 11;
        end
        
        read_SliceHeader.sendRefPOC.sendSize : action ==> RefPoc:[refPocSize]
        guard
                se_idx = 11
        var
                int(size=16) refPocSize = numPic[idxNumPic]
        do
                if numPic[idxNumPic] = 0 then
                        idxNumPic := idxNumPic + 1;
                        if idxNumPic = 5 then
                                se_idx := 3;
                        end
                else
                        idxRefPoc := 0;
                        se_idx    := 12;
                end
                
		        // Tokens Count
		        nbTokensPerSH[18] := nbTokensPerSH[18] + 1; // RefPoc                
        end
        read_SliceHeader.sendRefPOC.sendRefPoc : action ==> RefPoc:[refPoc]
        guard
                se_idx = 12
        var
                int(size=16) refPoc = pocTables[idxNumPic][idxRefPoc]
        do
                idxRefPoc := idxRefPoc + 1;
                if idxRefPoc = numPic[idxNumPic] then
                        idxNumPic := idxNumPic + 1;
                        if idxNumPic = 5 then
                                se_idx := 3;
                        else
                                se_idx := 11;
                        end
                end

		        // Tokens Count
		        nbTokensPerSH[18] := nbTokensPerSH[18] + 1; // RefPoc
        end
        /**************************************************************************
         * read_SliceHeader.se_idx_3
         *************************************************************************/
        read_SliceHeader.se_idx_3 : action ==> WeightedPred:[weighted_pred_flag]
        guard
                se_idx = 3
        do
                if weighted_pred_flag != 0 then
					se_idx := 4;
                else
                	se_idx := 5;
                end

		        // Tokens Count
		        nbTokensPerSH[23] := nbTokensPerSH[23] + 1; // WeightedPred
        end
        /**************************************************************************
         * read_SliceHeader.se_idx_4
         *************************************************************************/
        uint(size= 1) luma_weight_l0_flag[16];
        uint(size= 1) chroma_weight_l0_flag[16];
         int(size= 8) delta_luma_weight_l0;
         int(size= 8) luma_offset_l0;
         int(size= 8) delta_chroma_weight_l00;
         int(size= 8) delta_chroma_weight_l01;
         int(size= 10) delta_chroma_offset_l00;
         int(size= 10) delta_chroma_offset_l01;

        uint(size= 1) luma_weight_l1_flag[16];
        uint(size= 1) chroma_weight_l1_flag[16];
         int(size= 8) delta_luma_weight_l1;
         int(size= 8) luma_offset_l1;
         int(size= 8) delta_chroma_weight_l10;
         int(size= 8) delta_chroma_weight_l11;
         int(size= 10) delta_chroma_offset_l10;
         int(size= 10) delta_chroma_offset_l11;

        weighted_start : action ==> WeightedPred:[luma_log2_weight_denom, delta_chroma_log2_weight_denom]
        guard
                se_idx = 4,
                slice_type = P_SLICE or slice_type = B_SLICE,
                (pps_weighted_pred_flag[pps_id] = 1 and slice_type = P_SLICE) or ( pps_weighted_bipred_flag[pps_id] = 1 and slice_type = B_SLICE )
        var
		        int(size=32) ires[1],
		        uint(size=32) ures[1],
                uint(size= 3) luma_log2_weight_denom := 0,
                 int(size= 4) delta_chroma_log2_weight_denom :=0
        do
                load_fifo();
				vld_ue_name(fifoContent, fifoIdx, ures, "luma_log2_weight_denom                  ");
                luma_log2_weight_denom := ures[0];
        		if sps_chroma_format_idc[sps_id] != 0 then
                        vld_se_name(fifoContent, fifoIdx, ires, "delta_chroma_log2_weight_denom          ");
                        delta_chroma_log2_weight_denom := ires[0];
                end
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 2; // WeightedPred                
        end

        weighted_luma_l0 : action ==> WeightedPred:[luma_weight_l0_flag[cnt_i - 1]]
        var
                uint(size=32) res[1]
        do
                load_fifo();
				vld_u_name(1, fifoContent, fifoIdx, res, "luma_weight_lX_flag                     ");
                luma_weight_l0_flag[cnt_i] := res[0];
                cnt_i := cnt_i +1;
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 1; // WeightedPred                
        end

        weighted_end_luma_l0 : action ==>
        guard
                cnt_i = num_ref_idx_l0_active
        do
                cnt_i := 0;
        end

        weighted_chroma_l0 : action ==> WeightedPred:[chroma_weight_l0_flag[cnt_i - 1]]
        guard
                sps_chroma_format_idc[sps_id] = 1
        var
                uint(size=32) res[1]
        do
                load_fifo();
				vld_u_name(1, fifoContent, fifoIdx, res, "chroma_weight_lX_flag                   ");
                chroma_weight_l0_flag[cnt_i] := res[0];
                cnt_i := cnt_i + 1;
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 1; // WeightedPred                
        end

        weighted_end_chroma_l0 : action ==>
        guard
                cnt_i = num_ref_idx_l0_active
        do
                cnt_i := 0;
        end


        weighted_deltaLuma_l0_skip_loop : action ==>
        guard
                luma_weight_l0_flag[cnt_i] = 0,
                chroma_weight_l0_flag[cnt_i] = 0,
                cnt_i < num_ref_idx_l0_active
        do
                cnt_i := cnt_i + 1;
        end

        weighted_deltaLuma_l0_skip_loop_done : action ==>
        guard
                cnt_i = num_ref_idx_l0_active,
                slice_type = B_SLICE
        do
                cnt_i := 0;
        end

        weighted_deltaLuma_l0__skip_all : action ==>
        guard
                cnt_i = num_ref_idx_l0_active,
                slice_type != B_SLICE
        do
                cnt_i := 0;
                se_idx := 5;
        end

        weighted_deltaLuma_l0_send : action ==> WeightedPred:[delta_luma_weight_l0, luma_offset_l0]
        guard
                luma_weight_l0_flag[cnt_i] = 1,
                cnt_i < num_ref_idx_l0_active
        var
                int(size=32) res[1]
        do
                load_fifo();
				vld_se_name(fifoContent, fifoIdx, res, "delta_luma_weight_lX                    ");
                delta_luma_weight_l0 := res[0];
                vld_se_name(fifoContent, fifoIdx, res, "luma_offset_lX                          ");
                luma_offset_l0 := res[0];
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 2; // WeightedPred                
        end

        weighted_deltaLuma_l0_skip : action ==>
        guard
                cnt_i < num_ref_idx_l0_active,
                luma_weight_l0_flag[cnt_i] = 0
        end

        weighted_deltaChroma_l0_skip : action ==>
        guard
                cnt_i < num_ref_idx_l0_active,
                chroma_weight_l0_flag[cnt_i] = 0
        do
                cnt_i := cnt_i + 1;
        end

        weighted_deltaChroma_l0_send : action ==> WeightedPred:[delta_chroma_weight_l00]
        guard
                cnt_i < num_ref_idx_l0_active,
                chroma_weight_l0_flag[cnt_i] = 1
        var
                int(size=32) res[1]
        do
                load_fifo();
				vld_se_name(fifoContent, fifoIdx, res, "delta_chroma_weight_lX                  ");
                delta_chroma_weight_l00 := res[0];
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 1; // WeightedPred                
        end

        weighted_deltaChroma_offset_l0_send : action ==> WeightedPred:[delta_chroma_offset_l00, delta_chroma_weight_l01, delta_chroma_offset_l01]
        guard
                cnt_i < num_ref_idx_l0_active,
                chroma_weight_l0_flag[cnt_i] = 1
        var
                int(size=32) res[1]
        do
                load_fifo();
				vld_se_name(fifoContent, fifoIdx, res, "delta_chroma_offset_lX                  ");
                delta_chroma_offset_l00 := res[0];
                vld_se_name(fifoContent, fifoIdx, res, "delta_chroma_weight_lX                  ");
                delta_chroma_weight_l01 := res[0];
                vld_se_name(fifoContent, fifoIdx, res, "delta_chroma_offset_lX                  ");
                delta_chroma_offset_l01 := res[0];
                cnt_i := cnt_i + 1;
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 3; // WeightedPred                
        end

        weighted_luma_l1 : action ==>  WeightedPred:[luma_weight_l1_flag[cnt_i-1]]
        guard
                slice_type = B_SLICE
        var
                uint(size=32) res[1]
        do
                load_fifo();
				vld_u_name(1, fifoContent, fifoIdx, res, "luma_weight_lX_flag                     ");
                luma_weight_l1_flag[cnt_i] := res[0];
                cnt_i := cnt_i + 1;
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 1;  // WeightedPred               
        end

        weighted_end_luma_l1 : action ==>
        guard
                slice_type = B_SLICE,
                cnt_i = num_ref_idx_l1_active
        do
                cnt_i := 0;
        end

        weighted_chroma_l1_skip : action ==>
        guard
                sps_chroma_format_idc[sps_id] = 0
        do
                cnt_i := 0;
        end

        weighted_chroma_l1 : action ==>  WeightedPred:[chroma_weight_l1_flag[cnt_i - 1]]
        guard
                sps_chroma_format_idc[sps_id] != 0
        var
                uint(size=32) res[1]
        do
                load_fifo();
				vld_u_name(1, fifoContent, fifoIdx, res, "chroma_weight_lX_flag                   ");
                chroma_weight_l1_flag[cnt_i] := res[0];
                cnt_i := cnt_i + 1;
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 1; // WeightedPred                
        end

        weighted_end_chroma_l1 : action ==>
        guard
                sps_chroma_format_idc[sps_id] != 0,
                cnt_i = num_ref_idx_l1_active
        do
                cnt_i := 0;
        end

        weighted_deltaLuma_l1_skip_loop : action ==>
        guard
                luma_weight_l1_flag[cnt_i] = 0,
                chroma_weight_l1_flag[cnt_i] = 0
        do
                cnt_i := cnt_i + 1;
        end

        weighted_deltaLuma_l1_skip_loop_done : action ==>
        guard
                cnt_i = num_ref_idx_l1_active
        do
                cnt_i := 0;
                se_idx := 5;
        end

        weighted_deltaLuma_l1_send : action ==> WeightedPred:[delta_luma_weight_l1, luma_offset_l1]
        guard
                cnt_i < num_ref_idx_l1_active,
                luma_weight_l1_flag[cnt_i] = 1
        var
                int(size=32) res[1]
        do
                load_fifo();
				vld_se_name(fifoContent, fifoIdx, res, "delta_luma_weight_lX                    ");
                delta_luma_weight_l1 := res[0];
                vld_se_name(fifoContent, fifoIdx, res, "luma_offset_lX                          ");
                luma_offset_l1 := res[0];
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 2; // WeightedPred                
        end

        weighted_deltaLuma_l1_skip : action ==>
        guard
                cnt_i < num_ref_idx_l1_active,
                luma_weight_l1_flag[cnt_i] = 0
        end

        weighted_deltaChroma_l1_skip : action ==>
        guard
                cnt_i < num_ref_idx_l1_active,
                chroma_weight_l1_flag[cnt_i] = 0
        do
                cnt_i := cnt_i + 1;
        end

        weighted_deltaChroma_l1_send : action ==> WeightedPred:[delta_chroma_weight_l10]
        guard
                cnt_i < num_ref_idx_l1_active,
                chroma_weight_l1_flag[cnt_i] = 1
        var
                int(size=32) res[1]
        do
                load_fifo();
				vld_se_name(fifoContent, fifoIdx, res, "delta_chroma_weight_lX                  ");
                delta_chroma_weight_l10 := res[0];
                
	            // Tokens Count
	            nbTokensPerSH[23] := nbTokensPerSH[23] + 1; // WeightedPred                
        end

        weighted_deltaChroma_offset_l1_send : action ==> WeightedPred:[delta_chroma_offset_l10,delta_chroma_weight_l11,delta_chroma_offset_l11]
        guard
                cnt_i < num_ref_idx_l1_active,
                chroma_weight_l1_flag[cnt_i] = 1
        var
                int(size=32) res[1]
        do
                load_fifo();
				vld_se_name(fifoContent, fifoIdx, res, "delta_chroma_offset_lX                  ");
                delta_chroma_offset_l10 := res[0];
                vld_se_name(fifoContent, fifoIdx, res, "delta_chroma_weight_lX                  ");
                delta_chroma_weight_l11 := res[0];
                vld_se_name(fifoContent, fifoIdx, res, "delta_chroma_offset_lX                  ");
                delta_chroma_offset_l11 := res[0];
                cnt_i := cnt_i + 1;

				// Tokens Count
				nbTokensPerSH[23] := nbTokensPerSH[23] + 3;  // WeightedPred
        end  
		
        /**************************************************************************
         * read_SliceHeader.se_idx_5
         *************************************************************************/
         int(size= 8) slice_qp;
         int(size= 8) slice_chroma_qp_offset[3];
		uint(size=16) qp_bd_offset_luma;
		uint(size=16) qp_bd_offset_chroma;

        read_SliceHeader.se_idx_5 : action ==> DBFDisable:[slice_disable_deblocking_filter_flag !=0],
                DbfSe:[betaOff, tcOff, pps_chroma_qp_offset[pps_id][1] + slice_chroma_qp_offset[1], pps_chroma_qp_offset[pps_id][2] + slice_chroma_qp_offset[2]]
        guard
                se_idx = 5
        var
		        int(size=32) ires[1],
		        uint(size=32) ures[1],
                uint(size= 1) slice_disable_deblocking_filter_flag := pps_disable_deblocking_filter_flag[pps_id],
                int(size=8) betaOff := pps_beta_offset[pps_id],
                int(size=8) tcOff := pps_tc_offset[pps_id]
        do
                load_fifo();
				if slice_type = P_SLICE or slice_type = B_SLICE then
                    vld_ue_name(fifoContent, fifoIdx, ures, "five_minus_max_num_merge_cand           		");
                    MaxNumMergeCand := 5 - ures[0];
                end
                vld_se_name(fifoContent, fifoIdx, ires, "slice_qp_delta                          			");
                slice_qp := pps_init_qp_minus26[pps_id] + 26 + ires[0];
                slice_chroma_qp_offset := [0, 0, 0];

                if pps_slice_chroma_qp_offsets_present_flag[pps_id] = 1 then
                    vld_se_name(fifoContent, fifoIdx, ires, "slice_cb_qp_offset                      		");
                    slice_chroma_qp_offset[1] := ires[0];
                    vld_se_name(fifoContent, fifoIdx, ires, "slice_cr_qp_offset                      		");
                    slice_chroma_qp_offset[2] := ires[0];
                end
                if (pps_deblocking_filter_control_present_flag[pps_id] = 1) then
                
                end
                if (pps_deblocking_filter_control_present_flag[pps_id] = 1) then
                	ures[0] := 0;
                	if (deblocking_filter_override_enabled_flag[pps_id] = 1) then
                		vld_u_name(1, fifoContent, fifoIdx, ures, "deblocking_filter_override_flag			");
                	end
                	if ures[0] = 1 then
                		vld_u_name(1, fifoContent, fifoIdx, ures, "slice_disable_deblocking_filter_flag		");
                		slice_disable_deblocking_filter_flag := ures[0];
                		if (slice_disable_deblocking_filter_flag = 0) then
                			vld_se_name(fifoContent, fifoIdx, ires, "beta_offset_div2						");
                			betaOff := ires[0] << 1;
                			vld_se_name(fifoContent, fifoIdx, ires, "tc_offset_div2							");
                			tcOff := ires[0] << 1;
                		end
                	end
                end
                if (pps_loop_filter_across_slice_enabled_flag[sps_id] = 1 and
                (slice_sample_adaptive_offset_flag[0] = 1 or
                slice_sample_adaptive_offset_flag[1] = 1 or
                slice_disable_deblocking_filter_flag = 0)) then
                	vld_u_name(1, fifoContent, fifoIdx, ures, "slice_loop_filter_across_slices_enabled_flag");
                	slice_loop_filter_across_slices_enabled_flag := if(ures[0] != 0) then 1 else 0 end;
                else
                	slice_loop_filter_across_slices_enabled_flag := pps_loop_filter_across_slice_enabled_flag[sps_id];	
                end
                se_idx := se_idx + 1;

	            // Tokens Count
	            nbTokensPerSH[20] := nbTokensPerSH[20] + 1; // DBFDisable
	            nbTokensPerSH[21] := nbTokensPerSH[21] + 4; // DbfSe
        end

        uint(size=32) num_entry_offsets := 0;
        uint(size=16) num_entry_point_offsets := 0;
        uint(size=16) num_entry_point_offsets_plus1 := 0;

        read_SliceHeader_done : action ==> StrongIntraSmoothing:[sps_strong_intra_smoothing_enable_flag[sps_id], pps_constrained_intra_pred_flag[pps_id]]
        guard
			se_idx = 6
        var
			uint(size=32) res[1],
			uint(size= 8) offset_len,
			uint(size=16) slice_segment_header_extension_length := 0
        do
            if pps_tiles_enabled_flag[pps_id] = 1 or pps_entropy_coding_sync_enabled_flag[pps_id] = 1 then
            	load_fifo();
            	vld_ue_name(fifoContent, fifoIdx, res, "num_entry_point_offsets                 						");
            	num_entry_point_offsets := res[0];
            	num_entry_point_offsets_plus1 := res[0] + 1;

            	if (pps_tiles_enabled_flag[pps_id] = 1 and num_entry_point_offsets > ((pps_num_tile_columns_minus1[pps_id] + 1) * (pps_num_tile_rows_minus1[pps_id] + 1) - 1) ) // Tiles
            		or
            	   (pps_entropy_coding_sync_enabled_flag[pps_id] = 1 and num_entry_point_offsets > (PicHeightInCtbsY - 1)) // WPP 
            		or // Tiles and WPP
            	   (pps_tiles_enabled_flag[pps_id] = 1 and pps_entropy_coding_sync_enabled_flag[pps_id] = 1 and num_entry_point_offsets > ((pps_num_tile_columns_minus1[pps_id] + 1) * (PicHeightInCtbsY - 1))) 
            	then
					println("ERROR: num_entry_point_offsets is out of range.");
            	end
            	if num_entry_point_offsets > 0 then
            		load_fifo();
            		vld_ue_name(fifoContent, fifoIdx, res, "offset_len_minus1                    						");
            		offset_len := res[0] + 1;
					if offset_len > 32 then
						println("ERROR: offset_len > 32");
					end

            		foreach int i in 0 .. (num_entry_point_offsets-1) do
            			load_fifo();
						vld_u_name(offset_len, fifoContent, fifoIdx, res, "entry_point_offset_minus1                    ");
						entryOffsetsTab[i] := res[0] + 1;
            		end
            	end
        	end
			num_entry_offsets := (pps_num_tile_columns_minus1[pps_id] + 1) * (pps_num_tile_rows_minus1[pps_id] + 1);

		    if pps_slice_segment_header_extension_present_flag[pps_id] = 1 then
		    	load_fifo();
		        vld_ue_name(fifoContent, fifoIdx, res, "slice_segment_header_extension_length   ");		        
		        slice_segment_header_extension_length := res[0];
		        foreach int i in 0 .. (slice_segment_header_extension_length-1) do
		        	load_fifo();
					vld_u_name(8, fifoContent, fifoIdx, res, "slice_segment_header_extension_data_byte					");
		        end
		    end
            
            first_qp_group := if dependent_slice_segment_flag = 1 then 0 else 1 end;
            if (pps_cu_qp_delta_enabled_flag[pps_id] = 0) then
        		qp_y := slice_qp;
        	end
            sliceData_idx := 1;
            
	        // Tokens Count
	        nbTokensPerSH[13] := nbTokensPerSH[13] + 2; // StrongIntraSmoothing
        end

        /**************************************************************************
         **************************************************************************
         ********        Slice Data                           *********************
         **************************************************************************
         *************************************************************************/
        uint(size= 9) codIRange[1];
        uint(size=16) codIOffset[1];
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX];
        uint(size= 9) ctxTableWPP[NB_MAX_SE][NB_MAX_NUM_CTX];
        uint(size= 8) sliceData_idx;
        uint(size= 8) sliceData_idxSave1;
        uint(size= 8) sliceData_idxSave2;        
		uint(size=32) sliceHeaderOffset := 0;
		
        /**************************************************************************
         * read_SliceData.init
         *************************************************************************/
        //bool          isNotFirstSlice := (first_slice_segment_in_pic_flag = 0);
        uint(size= 8) prev_pps_id;
        uint(size= 1) skip_flag_tab[PICT_WIDTH][2];
        uint(size= 8) intraPredMode[PICT_WIDTH][2];

        uint(size=2) sliceSegmentType := 0;
        bool sliceSegmentSkipStart := false;
        //uint(size=32) picCounter := 0;

        read_SliceData.init: action ==> IsPicSlcLcu:[0], IsPicSlc:[0], MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id], slice_temporal_mvp_enable_flag ,collocated_from_lX , collocated_ref_idx],
        								SaoSe:[slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1)], TilesCoord:[num_entry_offsets],
        								LFAcrossSlcTile:[slice_loop_filter_across_slices_enabled_flag + (pps_loop_filter_across_tile_enabled_flag[pps_id]<<1)],
        								ReorderPics:[no_output_of_prior_pics, pic_output_flag, num_reorder_pics, max_dec_pic_buff, max_latency_pict, currentTID, decoderTID, log2_max_pic_order_cnt_lsb],
        								PictSize:[PictSize] repeat 2, DispCoord:[0, PictSize[0]-1, 0, PictSize[1]-1],
        								BitDepth:[sps_bit_depth_luma[sps_id], sps_bit_depth_chroma[sps_id]], LcuSize:[Log2CtbSize, Log2MinCbSize]
        guard
                sliceData_idx = 1,
                first_slice_segment_in_pic_flag = 1 or prev_pps_id != pps_id
        var
        		uint(size=8) no_output_of_prior_pics :=
        			if nal_unit_type = NAL_CRA_NUT then
        				1  + NEW_CVS
        			elsif isIRAP(nal_unit_type) then
        				no_output_of_prior_pics_flag + NEW_CVS
        			else
        				0
        			end,
        		uint(size=8) max_dec_pic_buff = sps_max_dec_pic_buffering[currentTID],
        		uint(size=8) num_reorder_pics = sps_num_reorder_pics[currentTID],
        		uint(size=8) max_latency_pict = sps_max_latency_pict[currentTID],
        		uint(size=8) log2_max_pic_order_cnt_lsb = sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4
        do
        		//println(pictCounter+" newPict: "+" nal_unit_type "+nal_unit_type+" slice_type "+slice_type+" poc "+poc);
        		//pictCounter := pictCounter + 1;
                //isNotFirstSlice   := true;               
                prev_pps_id := pps_id;
                first_qp_group := 1;

                if num_entry_offsets > 0 then
                        sliceData_idx := 20;
                else
                        sliceData_idx := 21;
                end

                sliceSegmentType := 1;
				// Tokens Count
				nbTokensPerSH[5] := nbTokensPerSH[5] + 1;    // IsPicSlcLcuSH
				nbTokensPerSH[6] := nbTokensPerSH[6] + 1;    // IsPicSlc            
				nbTokensPerSH[19] := nbTokensPerSH[19] + 4;  // MvPredSyntaxElemSH
				nbTokensPerSH[10] := nbTokensPerSH[10] + 1;  // SaoSeSH              
				nbTokensPerSH[1] := nbTokensPerSH[1] + 1;    // TilesCoord                        
				nbTokensPerSH[7] := nbTokensPerSH[7] + 1;    // LFAcrossSlcTile
				nbTokensPerSH[22] := nbTokensPerSH[22] + 8;  // ReorderPics
				nbTokensPerSH[8] := nbTokensPerSH[8] + 2;    // PictSize
				nbTokensPerSH[14] := nbTokensPerSH[14] + 4;  // DispCoord
	            nbTokensPerSH[2] := nbTokensPerSH[2] + 2;    // BitDepth
	            nbTokensPerSH[3] := nbTokensPerSH[3] + 2;    // LcuSize
        end

        read_SliceData.sendInfoSlice: action ==> TilesCoord:[0 ,0 ,PictSize[0] ,PictSize[1]]
        guard
                sliceData_idx = 21
        do
                sliceData_idx := 2;
                
                // Tokens Count
                nbTokensPerSH[1] := nbTokensPerSH[1] + 4; // TilesCoord
        end

        uint countRow := 0;
        uint countCol := 0;

        read_SliceData.sendInfoTilesLoop: action ==> TilesCoord:[x0 ,y0 ,x1 ,y1]
        guard
                sliceData_idx = 20,  cnt_i < num_entry_offsets 
        var
                uint x0 := 0,
                uint y0 := 0,
                uint x1 := PictSize[0],
                uint y1 := PictSize[1]
        do
                //colTileInPix[0] :=0;
                x0 := colTileInPix[countCol];
                x1 := colTileInPix[countCol + 1];
                y0 := rowTileInPix[countRow];
                y1 := rowTileInPix[countRow + 1];
                countCol := countCol + 1;
                if countCol  = pps_num_tile_columns_minus1[pps_id]+1 then
                        countCol := 0;
                        countRow := countRow + 1;
                end
                cnt_i := cnt_i + 1;

                // Tokens Count
                nbTokensPerSH[1] := nbTokensPerSH[1] + 4; // TilesCoord
        end

        read_SliceData.senInfoTilesEnd: action ==>
        guard
                sliceData_idx = 20,  cnt_i = num_entry_offsets 
        do
                countCol := 0;
                countRow := 0;
                cnt_i    := 0;
                sliceData_idx := 2;
        end

        read_SliceData.noInit: action ==> MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id], slice_temporal_mvp_enable_flag]
        guard
                sliceData_idx = 1,
                first_slice_segment_in_pic_flag = 0 and dependent_slice_segment_flag = 1 and prev_pps_id = pps_id
        do
                sliceData_idx := 2;

        		sliceSegmentType := 2;
                // Tokens count
                nbTokensPerSH[19] := nbTokensPerSH[19] + 2; // MvPredSyntaxElemSH
        end
        
        read_SliceData.noInit_isSlc: action ==> MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id],slice_temporal_mvp_enable_flag, collocated_from_lX , collocated_ref_idx],
        										IsPicSlcLcu:[1], IsPicSlc:[1], TilesCoord:[num_entry_offsets], 
        										LFAcrossSlcTile:[slice_loop_filter_across_slices_enabled_flag + (pps_loop_filter_across_tile_enabled_flag[pps_id]<<1)]        										
        guard
                sliceData_idx = 1,
                first_slice_segment_in_pic_flag = 0 and dependent_slice_segment_flag = 0 and prev_pps_id = pps_id
        do
                if num_entry_offsets > 0 then
                        sliceData_idx := 20;
                else
                        sliceData_idx := 21;
                end

        		sliceSegmentType := 3;
				// Tokens Count
				nbTokensPerSH[19] := nbTokensPerSH[19] + 4; // MvPredSyntaxElemSH
				nbTokensPerSH[5] := nbTokensPerSH[5] + 1;   // IsPicSlcLcuSH
				nbTokensPerSH[1] := nbTokensPerSH[1] + 1;   // TilesCoord        
				nbTokensPerSH[7] := nbTokensPerSH[7] + 1;   // LFAcrossSlcTile
				nbTokensPerSH[6] := nbTokensPerSH[6] + 1;   // IsPicSlc
        end

        /**************************************************************************
         * read_SliceData.start
         *************************************************************************/
        uint(size=32) CtbAddrRS;
        uint(size=32) CtbAddrTS;
        uint(size=32) end_of_slice_flag;

        read_SliceData.start : action ==> SliceAddr:[xCtb, yCtb], HeaderControl:[hc], NbTokens:[nbTokensPerSH] repeat 26
        guard
                sliceData_idx = 2
        var
                uint(size=32) CtbSize = 1 << Log2CtbSize,
                int(size=8) hc := 0
        do
                sliceHeaderOffset := bufferReadIdx - (fifoIdx[0]>>3);
                //showBits(8, fifo, res);
                //println("showbits8Start = " + res[0]);
				//println("initTab");
                CtbAddrRS     := slice_segment_address;
                CtbAddrTS     := ctbAddrRStoTS[CtbAddrRS];
                xCtb           := InverseRasterScan( CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 0 ) ;
                yCtb           := InverseRasterScan( CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 1 ) ;
                end_of_slice_flag  := 0;

				sliceData_idx := 3;
				// Reset tokens count.
				resetNbTokensPerCTU();

				// Initialize: 
				nbUnitsProcessed := 0;
				parellelType := 0;
				if(PARSER_INFO[1] > 1) then
					if(pps_tiles_enabled_flag[pps_id] != 0 and num_entry_point_offsets_plus1 > 1) then // Scenario 1: Tiles/WPP parallelization.
						ctbCounter := 0;
						parellelType := 2;
						if(nbUnitsToSkip >= num_entry_point_offsets_plus1) then
							nbUnitsToSkip := nbUnitsToSkip - num_entry_point_offsets_plus1;
							sliceData_idx := 5;	// Go to end of slice and skip whole slice.
							hc := 4;			// Eat slice header, and wait for next header control.
						elsif(nbUnitsToSkip = 0) then
							byPassFlag := false;
							nbUnitsToSkip := 0;	// Nothing to skip. Process first tile in this slice-segment.
							sliceData_idx := 3; // Go to process 1st tile in the slice-segment.
							hc := 0;			// Process slice header and 1st tile data.
						else
							// Skip nbUnitsToSkip and then process in (nbUnitsToSkip+1)th tile in this slice-segment.
							byPassFlag := true;
							hc := 3;			     // Eat slice header as the 1st (N-1) tiles are going to be bypassed.
							byte_alignment(fifoIdx); // Eat 1-bit and align, when skipping the very first tile in the slice-segment. 
						end
					elsif(sliceSegmentType = 1 and pps_entropy_coding_sync_enabled_flag[pps_id] != 0 and num_entry_point_offsets_plus1 > 1) then // Scenario 2: WPP parallelization.
						ctbCounter := 0;
						parellelType := 3;
						if((num_entry_point_offsets_plus1 - nbUnitsToSkip) = 1) then
							bSendWppTopCuInfo := false;
						else
							bSendWppTopCuInfo := true;
						end	
						if(nbUnitsToSkip >= num_entry_point_offsets_plus1) then
							nbUnitsToSkip := nbUnitsToSkip - num_entry_point_offsets_plus1;
							sliceData_idx := 5;	// Go to end of slice and skip whole slice.
							hc := 4;			// Eat slice header, and wait for next header control.
						elsif(nbUnitsToSkip = 0) then
							byPassFlag := false;
							nbUnitsToSkip := 0;	// Nothing to skip. Process first wpp-row in this slice-segment.
							sliceData_idx := 3; // Go to process 1st wpp-row in the slice-segment.
							hc := 0;			// Process slice header and 1st wpp-row data.
							bReceiveWppTopCuInfo := false;
						else
							// Skip nbUnitsToSkip and then process in (nbUnitsToSkip+1)th wpp-row in this slice-segment.
							byPassFlag := true;
							if(PicWidthInCtbsY >= 2) then
								sliceData_idxSave1 := 3;
								sliceData_idx := 8;  // Receive the context data from previous, wpp-row processed by preceding parser unit.							
							end
							hc := 3;			  	 // Eat slice header as the 1st (N-1) wpp-rows are going to be bypassed.
							byte_alignment(fifoIdx); // Eat 1-bit and align, when skipping the very first wpp-row in the slice-segment. 
							codIRange[0] := 510;
							codIOffset[0] := 0;
							bReceiveWppTopCuInfo := true;
						end
					else // Scenario 3: Slice group parallelization. 
						parellelType := 1;
						byPassFlag := false;	  // Turn off unit (tile/wpp-row)-bypass.
						if(sliceSegmentType = 1) then
							ctbCounter := 0;
							if(nbUnitsToSkip > 0) then
								sliceSegmentSkipStart := true;
								nbUnitsToSkip := nbUnitsToSkip - 1;
								hc := 5;			// Eat independent slice-segment header, and wait for next header control from parser processing this independent slice-segment.
								sliceData_idx := 5;	// Skip independent slice-segment.
							else //if(nbUnitsToSkip = 0) then
								sliceSegmentSkipStart := false;
								nbUnitsToSkip := PARSER_INFO[1] - 1; // Mark the number of slices (each may consists of n slice-segments) to skip after all dependent slice-segments are processed. 
								sliceData_idx := 3; // Go to process the independent slice-segment.
								hc := 1;			// Process independent slice-segment header.
							end
						else
							if(sliceSegmentSkipStart) then
								hc := 5;			// Eat dependent slice-segment header, and wait for next header control from parser processing this dependent slice-segment.
								sliceData_idx := 5;	// Skip dependent slice-segment.
							else
								sliceData_idx := 3; // Go to process the dependent slice-segment.
								hc := 1;			// Process dependent slice-segment header.														
							end
						end
					end	
				end
				
				// Tokens Count
				nbTokensPerSH[0] := nbTokensPerSH[0] + 2; // SliceAddr
        end
        /**************************************************************************
         * read_SliceData_gotoCodingTree
         *************************************************************************/
        read_SliceData_gotoCodingTree.start : action ==>
        guard
                sliceData_idx = 3, byPassFlag = false
        do
                sliceData_idx  := 4;
                codingTree_idx := 1;
        end

		uint totalByPass := 0;
        read_SliceData_gotoCodingTree.byPass : action ==>
        guard
                sliceData_idx = 3, byPassFlag = true
        var
        	uint(size=32) byPassStartIdx := sliceHeaderOffset,
        	uint(size=32) byPassEndIdx := 0
        do
				totalByPass := 0;
				cnt_i := 1;

                foreach int k in nbUnitsProcessed .. (nbUnitsProcessed + nbUnitsToSkip - 1) do
                    totalByPass := totalByPass + entryOffsetsTab[k];
                    byPassEndIdx := byPassEndIdx + entryOffsetsTab[k];
                end

                if(countAEB > 0 && byPassEndIdx > 0) then
                	foreach int k in 0 .. (nbUnitsProcessed-1) do
                		byPassStartIdx := byPassStartIdx + entryOffsetsTab[k];
                	end
                	byPassEndIdx := byPassEndIdx + byPassStartIdx;
                    foreach int k in 0 .. (countAEB-1) do
                    	if(byPassStartIdx <= locationAEB[k] && locationAEB[k] <= byPassEndIdx) then
                    		totalByPass := totalByPass - 1;
                    	elsif(locationAEB[k] > byPassEndIdx) then
                    		k := countAEB; // Break the loop.
                    	end
                    end                    
                end

                sliceData_idx  := 4;
                codingTree_idx := 0;
        end

        read_CodingTree.byPassBeforeUnitLoop: action ==>
        guard
                codingTree_idx = 0, cnt_i < totalByPass
        do
                load_fifo();
                fifoIdx[0] := fifoIdx[0] - 8;
                cnt_i := cnt_i + 1;
        end

        read_CodingTree.byPassBeforeUnitEnd: action ==>
        guard
                codingTree_idx = 0, cnt_i = totalByPass
        do
                cnt_i := 0;
                byPassFlag := false;
                codingTree_idx := 1;
				byte_align(fifoIdx);		// Align at end of current unit (tile/WPP-row).
				byte_alignment(fifoIdx);	
                nbUnitsProcessed := nbUnitsProcessed + nbUnitsToSkip; // Processed by other parser units, skipped by this parser unit.
                if parellelType = 3 then
                	CtbAddrTS := PicWidthInCtbsY * nbUnitsProcessed;
                elsif parellelType = 2 then
                	CtbAddrTS := nbCtbTile[nbUnitsProcessed-1];
                end
                CtbAddrRS := ctbAddrTStoRS[CtbAddrTS];
        end

        int ctbCounter := 0;
        read_SliceData.retCodingTree : action ==> HeaderControl:[end_of_unit]
        guard
                sliceData_idx = 4
        var
                uint(size=32) res[1] := [0],
                int(size=64) nbUnitsRemaining := 0,
                uint(size=8) end_of_unit := 0
        do
		        load_fifo();
                get_END_OF_SLICE_FLAG(codIRange, codIOffset, fifoContent, fifoIdx, res);
                end_of_slice_flag := res[0];
                end_of_unit := if(end_of_slice_flag != 0) then 1 else 0 end;
                CtbAddrTS := CtbAddrTS + 1;
                CtbAddrRS := ctbAddrTStoRS[CtbAddrTS];

                if end_of_slice_flag = 0 then                    
                    sliceData_idx := 3;
                    if pps_tiles_enabled_flag[pps_id] != 0 and (TileId[ CtbAddrTS ] != TileId[ CtbAddrTS - 1]) then
                        //println("endOfTile ###################################################");
                    end
                else
                    //println("endOfSlice ################################################### counter = " + counter);
                    sliceData_idx := 5;
                    //curr_Tile := 0;
                    CtbAddrTS := 0;
                    CtbAddrRS := 0;
                    //numByPassBytes := [0: for int i in 0 .. MAX_NUM_TILES - 1];
                    byPassFlag := false;
                end

				// Reset tokens count.
				resetNbTokensPerCTU();
				ctbCounter := ctbCounter + 1;
				if(parellelType = 2 and ctbCounter = nbCtbPerTile[nbUnitsProcessed]) then
	                ctbCounter := 0;
	                end_of_unit := 1;
	                nbUnitsProcessed := nbUnitsProcessed + 1;
                	nbUnitsRemaining :=  num_entry_point_offsets_plus1 - (nbUnitsProcessed + (PARSER_INFO[1] - 1));
                	if(nbUnitsRemaining	> 0) then
                		nbUnitsToSkip := (PARSER_INFO[1] - 1);
                		byPassFlag := true;
                		sliceData_idx := 6;
                	else 
                		nbUnitsToSkip := (PARSER_INFO[1] - 1) - (num_entry_point_offsets_plus1 - nbUnitsProcessed); // Tile-Units To be skipped in the next slice.
	                    CtbAddrTS := 0;
	                    CtbAddrRS := 0;                		
                		byPassFlag := false;
                		sliceData_idx := 5;
                	end
				elsif(parellelType = 3 and (ctbCounter mod PicWidthInCtbsY) = 0) then
	                ctbCounter := 0;
	                end_of_unit := 1;
	                nbUnitsProcessed := nbUnitsProcessed + 1;
                	nbUnitsRemaining :=  num_entry_point_offsets_plus1 - (nbUnitsProcessed + (PARSER_INFO[1] - 1));
                	bReceiveWppTopCuInfo := true;
                	if(nbUnitsRemaining	> 0) then
                		nbUnitsToSkip := (PARSER_INFO[1] - 1);
                		byPassFlag := true;
                		sliceData_idxSave1 := 6;
                		if(PicWidthInCtbsY >=2) then
	                		sliceData_idx := 8;
	                	else
	                		sliceData_idx := 6;
	                	end
                		if(nbUnitsRemaining = 1) then
                			bSendWppTopCuInfo := false;
                		end	
                	else 
                		nbUnitsToSkip := (PARSER_INFO[1] - 1) - (num_entry_point_offsets_plus1 - nbUnitsProcessed); // WPP-row-Units To be skipped in the next slice.
	                    CtbAddrTS := 0;
	                    CtbAddrRS := 0;                		
                		byPassFlag := false;
                		sliceData_idx := 5;
                	end                	
				end

            if pps_entropy_coding_sync_enabled_flag[pps_id] != 0 and 
            (CtbAddrTS mod PicWidthInCtbsY = 2 or (PicWidthInCtbsY = 2 and CtbAddrTS mod PicWidthInCtbsY = 0 )) then
            	//println("saveStates ctbaddrts = " + CtbAddrTS);
                ctxTableWPP := [[ctxTable[i][j]     : for int j in 0 .. NB_MAX_NUM_CTX-1] : for int i in 0 .. NB_MAX_SE-1];
                if(parellelType = 3 and (bSendWppTopCuInfo or nbUnitsRemaining = 1)) then
                	sliceData_idxSave2 := sliceData_idx;
                	sliceData_idx := 7;
                end
            end
        end

        /**************************************************************************
         * read_SliceData_end
         *************************************************************************/
        read_SliceData_end: action ==> 
        guard
               sliceData_idx = 5
		do
			resetNbTokensPerSH();
        end

        /**************************************************************************
         * read_SliceData.gotoNextUnit
         *************************************************************************/
        read_SliceData.gotoNextUnit: action ==> HeaderControl:[2] // 2= no-header for next unit (tile/wpp-row) data.
        guard
                sliceData_idx = 6
		do
				sliceData_idx := 3;
        end

        /**************************************************************************
         * read_SliceData.sendWPPContext
         *************************************************************************/
        read_SliceData.sendWPPContext_loop: action ==> OutWppCtx:[[ctxTableWPP[cnt_i-1][r]: for int r in 0 .. (NB_MAX_NUM_CTX-1)]] repeat NB_MAX_NUM_CTX
        guard
                sliceData_idx = 7, cnt_i < NB_MAX_SE
		do
				cnt_i := cnt_i + 1;
        end

        read_SliceData.sendWPPContext_end: action ==> 
        guard
                sliceData_idx = 7, cnt_i = NB_MAX_SE
		do
				cnt_i := 0;
				sliceData_idx := sliceData_idxSave2;
        end

        /**************************************************************************
         * read_SliceData.receiveWPPContext
         *************************************************************************/
        read_SliceData.receiveWPPContext_loop: action InWppCtx:[ctxRow] repeat NB_MAX_NUM_CTX ==> 
        guard
                sliceData_idx = 8, cnt_i < NB_MAX_SE
		do
				foreach int r in 0 .. (NB_MAX_NUM_CTX-1) do
					ctxTableWPP[cnt_i][r] := ctxRow[r];
				end	
				cnt_i := cnt_i + 1;
        end

        read_SliceData.receiveWPPContext_end: action ==> 
        guard
                sliceData_idx = 8, cnt_i = NB_MAX_SE
		do
				cnt_i := 0;
				sliceData_idx := sliceData_idxSave1;
        end

        /**************************************************************************
         **************************************************************************
         ********        Coding Tree                          *********************
         **************************************************************************
         *************************************************************************/
        uint(size=16) xCtb;
        uint(size=16) yCtb;
        uint(size=16) xCtbShfLog2MinCbSize;
        uint(size= 8) codingTree_idx;
        uint(size= 8) ctStack_idx;
        uint(size=16) ctStack[5][CT_STRUCT_SIZE];
        uint(size=8) first_qp_group;
	    bool ctb_left_flag;
	    bool ctb_up_flag;
	    int ctb_addr_in_slice ;
//	    int tab_slice_address[2048] := [-1 : for int i in 0 .. 2047]; // size to be checked (TODO)
//	    uint(size=8) slice_or_tiles_left_boundary;
//	    uint(size=8) slice_or_tiles_up_boundary;
//	    bool ctb_up_right_flag;
//	    bool ctb_up_left_flag;
        /**************************************************************************
         * read_CodingTree.start
         *************************************************************************/
		read_CodingTree.start : action ==>
        guard
                codingTree_idx = 1
        var
                uint(size=32) res[1],
                uint(size=32) CtbSize = 1 << Log2CtbSize,
                uint CtbAddrRS := ctbAddrTStoRS[CtbAddrTS],
                int tile_left_boundary,
                int tile_up_boundary,
//                int slice_left_boundary,
//                int slice_up_boundary,
                uint indexTS := 0,
                uint indexRS_0 := 0,
                uint indexRS_1 := 0
        do
            load_fifo();
			ctb_addr_in_slice := CtbAddrRS - slice_addr; //println("initcabac");
            if CtbAddrTS != 0 then
            	indexTS := CtbAddrTS - 1;
            end
            if CtbAddrRS != 0 then
            	indexRS_0 := CtbAddrRS - 1;
            end
            if CtbAddrRS >= sps_ctb_width[sps_id] then
            	indexRS_1 := CtbAddrRS - sps_ctb_width[sps_id];
            end
//			tab_slice_address[CtbAddrRS] := slice_addr;
            xCtb := InverseRasterScan(CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 0);
            yCtb := InverseRasterScan(CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 1);
            xCtbShfLog2MinCbSize := xCtb >> Log2MinCbSize;
            if pps_entropy_coding_sync_enabled_flag[pps_id] != 0 then
            	if (xCtb = 0 and (yCtb & (CtbSize - 1)) = 0) then
            		first_qp_group := 1;
            	end
            elsif pps_tiles_enabled_flag[pps_id] != 0 then 
        		if (CtbAddrTS != 0 and TileId[CtbAddrTS] != TileId[indexTS]) then
        			first_qp_group := 1;
        	 	end
            end
            if (pps_tiles_enabled_flag[pps_id] = 1) then
            	tile_left_boundary := if (xCtb > 0 && TileId[CtbAddrTS] != TileId[ctbAddrRStoTS[indexRS_0]]) then
            		1
            	else
            		0
            	end;
            	
            	tile_up_boundary := if (yCtb > 0 && TileId[CtbAddrTS] != TileId[ctbAddrRStoTS[indexRS_1]]) then
            		1
            	else
            		0
            	end;
//            	slice_left_boundary := if (xCtb > 0 && tab_slice_address[CtbAddrRS] != tab_slice_address[indexRS_0]) then
//            		1 
//            	else 
//            		0 
//            	end;
//        		slice_up_boundary   := if (yCtb > 0 && tab_slice_address[CtbAddrRS] != tab_slice_address[indexRS_1])then
//        			1
//        		else
//        			0
//        		end;
            else
            	tile_left_boundary := 0;
            	tile_up_boundary := 0;
//            	slice_left_boundary := if (ctb_addr_in_slice <= 0) then 1 else 0 end;
//        		slice_up_boundary   := if (ctb_addr_in_slice < sps_ctb_width[sps_id]) then 1 else 0 end;
            end
            //slice_or_tiles_left_boundary := slice_left_boundary + (tile_left_boundary << 1);
    		//slice_or_tiles_up_boundary   := slice_up_boundary   + (tile_up_boundary   << 1);
            ctb_left_flag := (xCtb > 0) and (ctb_addr_in_slice > 0) and (tile_left_boundary = 0);
            ctb_up_flag := (yCtb > 0) && (ctb_addr_in_slice >= sps_ctb_width[sps_id]) && tile_up_boundary = 0;
//           ctb_up_right_flag := ((yCtb > 0)                && (ctb_addr_in_slice+1 >= sps_ctb_width[sps_id]) && (TileId[CtbAddrTS] = TileId[ctbAddrRStoTS[CtbAddrRS+1 - sps_ctb_width[sps_id]]]));
//    		ctb_up_left_flag  := ((xCtb > 0) && (yCtb > 0)  && (ctb_addr_in_slice-1 >= sps_ctb_width[sps_id]) && (TileId[CtbAddrTS] = TileId[ctbAddrRStoTS[CtbAddrRS-1 - sps_ctb_width[sps_id]]]));
            
            codingTree_idx := 2;
            if CtbAddrTS = ctbAddrRStoTS[slice_segment_address] then 
            	decodeStart(codIRange, codIOffset, fifoContent, fifoIdx);
            	if (dependent_slice_segment_flag = 0 or
            	(pps_tiles_enabled_flag[pps_id] != 0 and (TileId[CtbAddrTS] != TileId[indexTS]))) then
            		contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag); 
            	end
            	if first_slice_segment_in_pic_flag = 0 and
            	pps_entropy_coding_sync_enabled_flag[pps_id] != 0 then
            		if (CtbAddrTS mod PicWidthInCtbsY) = 0 then
            			if PicWidthInCtbsY = 1 then
            				contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag); 
            			else
            				if dependent_slice_segment_flag != 0 then
            					ctxTable := [ [ ctxTableWPP[i][j] : for int j in 0 .. NB_MAX_NUM_CTX - 1 ] : for int i in 0 .. NB_MAX_SE - 1 ];
            				end
            			end
            		end
            	end
            else
            	if CtbAddrTS = 0 or pps_tiles_enabled_flag[pps_id] != 0 and
            	(TileId[CtbAddrTS] != TileId[indexTS]) then 
            		decodeReInit(codIRange, codIOffset, fifoContent, fifoIdx); 
            		contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag);
            	end
            	if pps_entropy_coding_sync_enabled_flag[pps_id] != 0 then
            		if (CtbAddrTS mod PicWidthInCtbsY) = 0 then
            			get_END_OF_SUB_STREAM_ONE_BIT(codIRange, codIOffset, fifoContent, fifoIdx, res);            			
            			decodeReInit(codIRange, codIOffset, fifoContent, fifoIdx); 
            			if PicWidthInCtbsY = 1 then
            				contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag);
            			else
            				ctxTable := [ [ ctxTableWPP[i][j] : for int j in 0 .. NB_MAX_NUM_CTX - 1 ] : for int i in 0 .. NB_MAX_SE - 1 ];
            			end
            		end
            	end
            end

			if parellelType = 3 and bReceiveWppTopCuInfo then
				codingTree_idx := 5;
			end	
        end
        /**************************************************************************
         * read_CodingTree_gotoSaoParam
         *************************************************************************/
        read_CodingTree_gotoSaoParam : action ==>
        guard
                codingTree_idx = 2,
                slice_sample_adaptive_offset_flag[0] = 1 or slice_sample_adaptive_offset_flag[1] = 1
        do
                codingTree_idx  := 3;
                sao_idx                 := 1;
                sao_rx                  := xCtb >> Log2CtbSize;
                sao_ry                  := yCtb >> Log2CtbSize;
                sao_cIdx                := 0;
        end
        read_CodingTree.noGotoSaoParam : action ==>
        guard
                codingTree_idx = 2,
                slice_sample_adaptive_offset_flag[0] = 0 and slice_sample_adaptive_offset_flag[1] = 0
        do
                codingTree_idx := 3;
        end
        /**************************************************************************
         * read_CodingTree_gotoCodingQuadTree
         *************************************************************************/
        read_CodingTree_gotoCodingQuadTree : action ==>  IsPicSlcLcu:[NEW_LCU]
        guard
                codingTree_idx = 3
        do
                codingTree_idx                          := 4;
                ctStack_idx                             := 0;
                ctStack[0][CT_idx]                      := 1;
                ctStack[0][CT_x0]                       := xCtb;
                ctStack[0][CT_y0]                       := yCtb;
                ctStack[0][CT_log2CbSize]       := Log2CtbSize;
                ctStack[0][CT_ctDepth]          := 0;
                
                // Tokens count
                NbTokensPerCTU[3] := NbTokensPerCTU[3] + 1;

				if parellelType = 3 and bSendWppTopCuInfo then
					codingTree_idx := 6;
				end	
        end
        /**************************************************************************
         * read_CodingTree_end
         *************************************************************************/
        read_CodingTree_end : action ==> NbTokens:[NbTokensPerCTU] repeat 15
        guard
                codingTree_idx = 4
		end
        /**************************************************************************
         * read_CodingTree.receiveTopCuDepth
         *************************************************************************/               
        read_CodingTree.receiveTopCuDepth_loop : action InWppTopCUInfo:[topDepth, topSkip] ==> 
        guard
        	codingTree_idx = 5,  cnt_i < nbMaxCUsPerCTU
        var
        	uint(size=16) idx := xCtbShfLog2MinCbSize + cnt_i
        do
        	cu_top_ctDepth[idx] := topDepth;
        	skip_flag_tab[idx][0] := topSkip & 0x1;
        	cnt_i := cnt_i + 1;
        end	

        read_CodingTree.receiveTopCuDepth_end : action ==> 
        guard
        	codingTree_idx = 5, cnt_i >= nbMaxCUsPerCTU
        do
        	cnt_i := 0;
			codingTree_idx := 2;
        end
        
        /**************************************************************************
         * read_CodingTree.sendTopCuDepth
         *************************************************************************/               
        read_CodingTree.sendTopCuDepth_loop : action ==> OutWppTopCUInfo:[cu_top_ctDepth[idx], skip_flag_tab[idx][0]]
        guard
        	codingTree_idx = 6, cnt_i < nbMaxCUsPerCTU
        var
        	uint(size=16) idx := xCtbShfLog2MinCbSize + cnt_i
        do
        	cnt_i := cnt_i + 1;
        end

        read_CodingTree.sendTopCuDepth_end : action ==> 
        guard
        	codingTree_idx = 6, cnt_i >= nbMaxCUsPerCTU
        do
        	cnt_i := 0;
			codingTree_idx := 4;
        end

        /**************************************************************************
         **************************************************************************
         ********        sao_param                            *********************
         **************************************************************************
         *************************************************************************/
        uint(size= 3) sao_cIdx;
        uint(size=16) sao_rx;
        uint(size=16) sao_ry;
        uint(size= 8) sao_idx;
        /**************************************************************************
         * read_SaoParam.start
         *************************************************************************/
        read_SaoParam.start : action ==> SaoSe:[sao_merge]
        guard
                sao_idx = 1
        var
                 uint(size=1) res[1],
                uint(size= 1) sao_merge_left_flag       := 0,
                uint(size= 1) sao_merge_up_flag         := 0,
                 int(size= 9) sao_merge             := SAO_NO_MERGE
        do
            load_fifo();
			if sao_rx > 0 then
            	if ctb_left_flag then
            		get_SAO_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res);
            		sao_merge_left_flag := res[0];
            		if sao_merge_left_flag = 1 then
            			sao_merge := SAO_MERGE_LEFT;
            		end
            	end
            end
            if sao_ry > 0 and sao_merge_left_flag = 0 then
            	if ctb_up_flag then
            		get_SAO_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res);
            		sao_merge_up_flag := res[0];
            		if sao_merge_up_flag = 1 then
            			sao_merge := SAO_MERGE_UP;
            		end
            	end
            end
            sao_idx := 2;
            if sao_merge_left_flag = 0 and sao_merge_up_flag = 0 then
            	sao_cIdx := 0;
            else
            	sao_cIdx := 3;
            end

            // Tokens count
            NbTokensPerCTU[4] := NbTokensPerCTU[4] + 1;
        end
        /**************************************************************************
         * read_SaoParam.loop
         *************************************************************************/
	    int(size= 9) sao_typeIdx;
	    int(size= 9) sao_eo;
	
	    read_SaoParam.loop1 : action ==> SaoSe:[sao_typeIdx]
	    guard
	        sao_idx  = 2,
	        sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 1
	    var
	         uint(size=32) res[1]
	    do
	        load_fifo();
			if sao_cIdx != 2 then
	            sao_typeIdx := SAO_NOT_APPLIED;
	            get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res);
	            sao_typeIdx := res[0];
	        end
	        if sao_typeIdx != SAO_NOT_APPLIED then
	            sao_idx := 3;
	        else
	            sao_cIdx := sao_cIdx + 1;
	        end

            // Tokens count
            NbTokensPerCTU[4] := NbTokensPerCTU[4] + 1;
	    end
	    
        read_SaoParam.loop2 : action ==> SaoSe:[offset[0],offset[1],offset[2],offset[3],sao_eo]
        guard
	        sao_idx  = 3
		var
			uint(size= 8) shiftTh    = min(if(sao_cIdx = TEXT_LUMA) then sps_bit_depth_luma[sps_id] else sps_bit_depth_chroma[sps_id] end, SAO_MAX_TRUNCATED_BITDEPTH) - 5,
	        uint(size= 8) offsetTh   = (1<<shiftTh)-1,
	         int(size= 9) offset[4] := [0, 0, 0, 0],
	         uint(size=32) res[1]   := [0]
        do
	        foreach int i in 0 .. 3 do
            	load_fifo();
	        	get_SAO_OFFSET_ABS(offsetTh, codIRange, codIOffset, fifoContent, fifoIdx, res);
	        	offset[i] := res[0];
	        end
            load_fifo();
	        if sao_typeIdx = SAO_BAND then
	        	foreach int i in 0 .. 3 do
	        		if offset[i] != 0 then
	        			get_SAO_OFFSET_SIGN(codIRange, codIOffset, fifoContent, fifoIdx, res);
	        			if res[0] != 0 then
	        				offset[i] := -offset[i];
	        			end
	        		end
	        	end
	        	get_SAO_BAND_POSITION(codIRange, codIOffset, fifoContent, fifoIdx, res);
	        	sao_eo := res[0];
	        else // SAO_EDGE
	        	offset[2] := -offset[2];
	        	offset[3] := -offset[3];
	        	if sao_cIdx != 2 then
	        		get_SAO_EO(codIRange, codIOffset, fifoContent, fifoIdx, res);
	        		sao_eo := res[0];
	        	end
	        end
	        sao_cIdx := sao_cIdx + 1;
	        sao_idx := 2;

            // Tokens count
            NbTokensPerCTU[4] := NbTokensPerCTU[4] + 5;	        
        end
        read_SaoParam.nextLoop : action ==>
        guard
	        sao_idx  = 2,
	        sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 0
        do
        	sao_cIdx := sao_cIdx + 1;
        end
	    read_SaoParam_endLoop : action ==>
	    guard
            sao_idx  = 2,
            sao_cIdx = 3
        end
        /**************************************************************************
         **************************************************************************
         ********        Coding quadTree                      *********************
         **************************************************************************
         *************************************************************************/
        uint(size= 1) IsCuQpDeltaCoded;
         int(size=16) CuQpDelta;
         uint(size= 8) ct_log2CbSize;
        /**************************************************************************
         * read_CodingQuadTree.start
         *************************************************************************/
		read_CodingQuadTree.start : action ==>
        guard
                ctStack[ctStack_idx][CT_idx] = 1
        var
            uint(size=1) res[1],
            uint(size=16) ct_x0                     = ctStack[ctStack_idx][CT_x0],
            uint(size=16) ct_y0                     = ctStack[ctStack_idx][CT_y0],
            uint(size= 8) ct_ctDepth        = ctStack[ctStack_idx][CT_ctDepth],
            uint(size= 8) top_ctDepth       := cu_top_ctDepth[ct_x0 >> Log2MinCbSize],
            uint(size= 8) left_ctDepth      := cu_left_ctDepth[ct_y0 >> Log2MinCbSize],
            uint(size= 1) split_cu_flag,
            uint(size= 8) Log2MinCuQpDeltaSize = Log2CtbSize - pps_diff_cu_qp_delta_depth[pps_id],
            uint(size=16) tbX = ( (ct_x0>>Log2MinCbSize) << Log2MinCbSize ) >> Log2CtbSize,
            uint(size=16) tbY = ( (ct_y0>>Log2MinCbSize) << Log2MinCbSize ) >> Log2CtbSize,

            uint(size=16) MinCbAddrZS,
            uint(size=16) m,
            uint(size=16) x0b = ct_x0 & ((1 << Log2CtbSize) - 1),
        	uint(size=16) y0b = ct_y0 & ((1 << Log2CtbSize) - 1)
        do
        	load_fifo();
			qp_block_mask    := (1<<(sps_log2_ctb_size[sps_id] - pps_diff_cu_qp_delta_depth[pps_id])) - 1;
    	    ct_log2CbSize := ctStack[ctStack_idx][CT_log2CbSize];
    	    CtbAddrRS := PicWidthInCtbsY * tbY + tbX;
    	    MinCbAddrZS := ctbAddrRStoTS[CtbAddrRS] << ((Log2CtbSize - Log2MinCbSize) * 2);

    	    if DEBUG_CABAC and DEBUG_TRACE1 then
    	    	//println("read_CodingQuadTree.start (" + ct_x0 + ", " + ct_y0 + ", " + (1<< ct_log2CbSize) + ", " + ctStack[ctStack_idx][CT_ctDepth] + ")");
    	    elsif DEBUG_CABAC then 
    	    	println("read_CodingQuadTree.start");
    	    end
    	    foreach int i in 0 .. Log2CtbSize - Log2MinCbSize - 1 do
    	    	m := 1 << i;
    	    	MinCbAddrZS := MinCbAddrZS + if (m & (ct_x0 >> Log2MinCbSize)) != 0
    	    	then
    	    		m * m
    	    	else
    	    		0
    	    	end + if (m & (ct_y0 >> Log2MinCbSize)) != 0 then
    	    		2 * m * m
    	    	else
    	    		0
    	    	end;
    	    end
    	    if (ctb_left_flag) or (x0b > 0) then
    	    	left_ctDepth := cu_left_ctDepth[ct_y0 >> Log2MinCbSize];
    	    end
    	    if (ctb_up_flag) or (y0b > 0) then
    	    	top_ctDepth := cu_top_ctDepth[ct_x0 >> Log2MinCbSize];
    	    end
    	    if 	ct_x0 + (1 << ct_log2CbSize) <= sps_pic_width_in_luma_samples[sps_id] and 
    	    	ct_y0 + (1 << ct_log2CbSize) <= sps_pic_height_in_luma_samples[sps_id] and
    	    	ct_log2CbSize > Log2MinCbSize then
    	    	get_SPLIT_CODING_UNIT_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx,
    	    	res, ct_ctDepth, (ctb_left_flag) or (x0b > 0), left_ctDepth,
    	    	(ctb_up_flag) or (y0b > 0), top_ctDepth);
    	    	split_cu_flag := res[0];
    	    else
    	    	split_cu_flag := if ct_log2CbSize > Log2MinCbSize then
    	    		1
    	    	else
    	    		0
    	    	end;
    	    end
    	    if ((pps_cu_qp_delta_enabled_flag[pps_id] != 0) and ct_log2CbSize >=
    	    Log2MinCuQpDeltaSize) then
    	    	IsCuQpDeltaCoded := 0;
    	    	CuQpDelta := 0;
    	    end
    	    if split_cu_flag = 1 then
    	    	ctStack[ctStack_idx][CT_x1] := ct_x0 + ((1 << ct_log2CbSize) >> 1);
    	    	ctStack[ctStack_idx][CT_y1] := ct_y0 + ((1 << ct_log2CbSize) >> 1);
    	    	ctStack[ctStack_idx][CT_idx] := 2;
    	    else
    	    	ctStack[ctStack_idx][CT_idx] := 6;
    	    end
        end

        /**************************************************************************
         * read_CodingQuadTree.case1
         *************************************************************************/
        read_CodingQuadTree.case1 : action ==>
        guard
                ctStack[ctStack_idx][CT_idx] = 2
        var
                uint(size= 8) idx =  ctStack_idx
        do
                ctStack[ctStack_idx][CT_idx]        := 3;
                ctStack_idx                         := ctStack_idx + 1;
                ctStack[ctStack_idx][CT_idx]        := 1;
                ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x0];
                ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y0];
                ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
                ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
        end

        /**************************************************************************
         * read_CodingQuadTree.case2
         *************************************************************************/
        read_CodingQuadTree.case2 : action ==>
        guard
                ctStack[ctStack_idx][CT_idx] = 3,
                ctStack[ctStack_idx][CT_x1] < sps_pic_width_in_luma_samples[sps_id]
        var
                uint(size= 8) idx =  ctStack_idx
        do
                ctStack[ctStack_idx][CT_idx]        := 4;
                ctStack_idx                         := ctStack_idx + 1;
                ctStack[ctStack_idx][CT_idx]        := 1;
                ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x1];
                ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y0];
                ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
                ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
        end

        read_CodingQuadTree.noCase2 : action ==> CUInfo:[cuInfo] repeat 5, PartMode:[PART_2Nx2N]
        guard
                ctStack[ctStack_idx][CT_idx] = 3,
                ctStack[ctStack_idx][CT_x1] >= sps_pic_width_in_luma_samples[sps_id]
        var
                uint(size=16) cuInfo[5] = [OTHER,
                        ctStack[ctStack_idx][CT_x1], ctStack[ctStack_idx][CT_y0],
                        1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
                        1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
        do
                ctStack[ctStack_idx][CT_idx]        := 4;
                
                // Tokens count.
                NbTokensPerCTU[0] := NbTokensPerCTU[0] + 5;
                NbTokensPerCTU[2] := NbTokensPerCTU[2] + 1;
        end
        /**************************************************************************
         * read_CodingQuadTree.case3
         *************************************************************************/
        read_CodingQuadTree.case3 : action ==>
        guard
                ctStack[ctStack_idx][CT_idx] = 4,
                ctStack[ctStack_idx][CT_y1] < sps_pic_height_in_luma_samples[sps_id]
        var
                uint(size= 8) idx =  ctStack_idx
        do
                ctStack[ctStack_idx][CT_idx]        := 5;
                ctStack_idx                         := ctStack_idx + 1;
                ctStack[ctStack_idx][CT_idx]        := 1;
                ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x0];
                ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y1];
                ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
                ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
        end
        read_CodingQuadTree.noCase3 : action ==> CUInfo:[cuInfo] repeat 5, PartMode:[PART_2Nx2N]
        guard
                ctStack[ctStack_idx][CT_idx] = 4,
                ctStack[ctStack_idx][CT_y1] >= sps_pic_height_in_luma_samples[sps_id]
        var
                uint(size=16) cuInfo[5] = [OTHER,
                        ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y1],
                        1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
                        1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
        do
                ctStack[ctStack_idx][CT_idx]        := 5;

                // Tokens count.
                NbTokensPerCTU[0] := NbTokensPerCTU[0] + 5;
                NbTokensPerCTU[2] := NbTokensPerCTU[2] + 1;
        end
        /**************************************************************************
         * read_CodingQuadTree.case4
         *************************************************************************/
        read_CodingQuadTree.case4 : action ==>
        guard
                ctStack[ctStack_idx][CT_idx] = 5,
                ctStack[ctStack_idx][CT_x1] < sps_pic_width_in_luma_samples[sps_id],
                ctStack[ctStack_idx][CT_y1] < sps_pic_height_in_luma_samples[sps_id]
        var
                uint(size= 8) idx =  ctStack_idx
        do
                ctStack[ctStack_idx][CT_idx]        := 7;
                ctStack_idx                                                     := ctStack_idx + 1;
                ctStack[ctStack_idx][CT_idx]        := 1;
                ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x1];
                ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y1];
                ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
                ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
        end
        read_CodingQuadTree.noCase4 : action ==> CUInfo:[cuInfo] repeat 5, PartMode:[PART_2Nx2N]
        guard
                ctStack[ctStack_idx][CT_idx] = 5,
                ctStack[ctStack_idx][CT_x1] >= sps_pic_width_in_luma_samples[sps_id] or
                ctStack[ctStack_idx][CT_y1] >= sps_pic_height_in_luma_samples[sps_id]
        var
                uint(size=16) cuInfo[5] = [OTHER,
                        ctStack[ctStack_idx][CT_x1], ctStack[ctStack_idx][CT_y1],
                        1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
                        1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
        do
                ctStack[ctStack_idx][CT_idx]        := 7;
                
                // Tokens count.
                NbTokensPerCTU[0] := NbTokensPerCTU[0] + 5;
                NbTokensPerCTU[2] := NbTokensPerCTU[2] + 1;
        end
        /**************************************************************************
         * read_CodingQuadTree_gotoCodingUnit
         *************************************************************************/
        read_CodingQuadTree_gotoCodingUnit : action ==>
        guard
                ctStack[ctStack_idx][CT_idx] = 6
        do
                ctStack[ctStack_idx][CT_idx]        := 7;
                cu_idx                  := 1;
                cu_x0                   := ctStack[ctStack_idx][CT_x0];
                cu_y0                   := ctStack[ctStack_idx][CT_y0];
                cu_log2CbSize   := ctStack[ctStack_idx][CT_log2CbSize];
                cu_ctDepth              := ctStack[ctStack_idx][CT_ctDepth];
        end
        /**************************************************************************
         * read_CodingQuadTree_end
         *************************************************************************/
        read_CodingQuadTree.noEnd : action ==>
        guard
                ctStack[ctStack_idx][CT_idx] = 7,
                ctStack_idx != 0
        do
                ctStack_idx := ctStack_idx - 1;
        end
        read_CodingQuadTree_end : action ==>
        guard
                ctStack[ctStack_idx][CT_idx] = 7,
                ctStack_idx = 0
        do
//        	tab_slice_address[CtbAddrRS] := -1;
			if (((cu_x0 + (1 << cu_log2CbSize)) & qp_block_mask) = 0 && ((cu_y0 + (1 << cu_log2CbSize)) & qp_block_mask) = 0) then // cu_xo and cu_y0 to be checked TODO
        		qPy_pred := qp_y;
        	end
        end

        /**************************************************************************
         **************************************************************************
         ********        Coding Unit                          *********************
         **************************************************************************
         *************************************************************************/
        uint(size= 8) cu_idx;
        uint(size=16) cu_x0;
        uint(size=16) cu_y0;
        uint(size= 8) cu_log2CbSize;
        uint(size= 8) cu_ctDepth;
        uint(size= 8) predMode;
        uint(size= 8) partMode;
        uint(size= 1) IntraSplitFlag;
        uint(size= 8) MaxTrafoDepth;
        uint(size= 1) cu_transquant_bypass_flag;
        uint(size= 8) cu_top_ctDepth[PICT_WIDTH];
        uint(size= 8) cu_left_ctDepth[PICT_WIDTH];
        uint(size= 1) skip_flag;
        uint(size= 1) merge_flag;
        uint(size=6) intraChrPredModIdx;
        uint(size=6) intraPredModeC[5][5] =
                [[34,  0,  0,  0,  0],
                 [26, 34, 26, 26, 26],
                 [10, 10, 34, 10, 10],
                 [ 1,  1,  1, 34,  1],
                 [0, 26, 10, 1, 0]];

		int qp_block_mask := 0;
        /**************************************************************************
         * read_CodingUnit.start
         *************************************************************************/
        uint(size= 8) cu_nCbS;
        int counterfillSkip := 0;
        read_CodingUnit.start : action ==>
        guard
                cu_idx = 1
        var
                uint(size=1) res[1],
                uint(size= 8) length             		 = (1 << cu_log2CbSize) >> Log2MinCbSize,
                int(size=32) x_cb                        = cu_x0 >> Log2MinCbSize,
		        int(size=32) y_cb                        = cu_y0 >> Log2MinCbSize,
		
		        int(size=32) ct_x0                     	 = ctStack[ctStack_idx][CT_x0],
		        int(size=32) ct_y0                       = ctStack[ctStack_idx][CT_y0],
		        int(size=32) x0b = ct_x0 & ((1 << Log2CtbSize) - 1),
		        int(size=32) y0b = ct_y0 & ((1 << Log2CtbSize) - 1),
		        bool leftFlag,
		        bool upFlag
        do
        	load_fifo();
			qp_block_mask    := (1<<(sps_log2_ctb_size[sps_id] - pps_diff_cu_qp_delta_depth[pps_id])) - 1;
			pcm_flag := 0;
        	leftFlag := ctb_left_flag or (x0b > 0);
        	upFlag := ctb_up_flag or (y0b > 0);
        	skip_flag := 0;
        	merge_flag := 0;
        	intra_pred_mode := [ 1 : for int i in 0 .. 3 ];
        	if DEBUG_CABAC and DEBUG_TRACE1 then
        		println("read_CodingUnit.start (" + cu_x0 + ", " + cu_y0 + ", " +
        		cu_log2CbSize + ")");
        		elsif DEBUG_CABAC then println("read_CodingUnit.start");
        	end
        	predMode := INTRA;
        	if pps_transquant_bypass_enable_flag[pps_id] != 0 then
        		get_CU_TRANSQUANT_BYPASS_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx,
        		res);
        		cu_transquant_bypass_flag := res[0];
        	else
        		cu_transquant_bypass_flag := 0;
        	end
        	if slice_type != I_SLICE then
        		get_SKIP_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
        		skip_flag_tab, x_cb, y_cb, leftFlag, upFlag);
        		skip_flag := res[0];
        		predMode := SKIP;
        		predMode := if skip_flag = 1 then
        			SKIP
        		else
        			INTER
        		end;
        		foreach uint i in 0 .. length - 1 do
        			skip_flag_tab[x_cb + i][0] := skip_flag;
        			skip_flag_tab[y_cb + i][1] := skip_flag;
        		end
        		counterfillSkip := counterfillSkip + 1;
        	end
        	cu_nCbS := (1 << cu_log2CbSize);
        	partMode := PART_2Nx2N;
        	cu_idx := 2;
        	
        	if cu_transquant_bypass_flag != 0 then
        		cu_idx := 33;
        	end
        end
        
        /**************************************************************************
         * read_CodingUnit_gotoPredictionUnit.goto1
         *************************************************************************/
        read_CodingUnit_gotoPredictionUnit.goto1 : action ==> CUInfo:[cuInfo] repeat 5, Cbf:[false],
                 PartMode:[PART_2Nx2N], SplitTransform:[false],
                 TUSize:[1<<cu_log2CbSize, 1, 0, 0, slice_qp, TEXT_LUMA, 0, //luma
                 1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_U, 0, //cb
                 1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_V, 0] //cr
                                                                                                                                
        guard
                cu_idx = 2,
                skip_flag != 0
        var
                uint(size=16) cuInfo[5] = [SKIP,
                ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
                1<<cu_log2CbSize, 1<<cu_log2CbSize]
        do
                cu_idx          := 10;
                pu_idx          := 1;
                pu_PbW          := cu_nCbS;
                pu_PbH          := cu_nCbS;
                intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);
                
                // Tokens count.
                NbTokensPerCTU[0] := NbTokensPerCTU[0] + 5;
                NbTokensPerCTU[9] := NbTokensPerCTU[9] + 1;
                NbTokensPerCTU[2] := NbTokensPerCTU[2] + 1;
                NbTokensPerCTU[5] := NbTokensPerCTU[5] + 1;
                NbTokensPerCTU[6] := NbTokensPerCTU[6] + (7*3);
        end
        /**************************************************************************
         * read_CodingUnit.noGoto1
         *************************************************************************/

        uint(size= 8) intra_pred_mode[4];
        uint(size= 8) intra_pred_mode_c;
        read_CodingUnit_noGoto1 : action ==> PartMode:[partMode]
        guard
                cu_idx = 2,
                skip_flag = 0
        var
            uint(size= 1) prev_intra_luma_pred_flag[4],
            uint(size= 8) intra_chroma_table[4] = [0, 26, 10, 1],
            uint(size=32) res[1],
            //!TODO : Use only one res variable
            uint(size=1) res1bit[1],
            uint(size= 8) Log2MinIPCMCUSize = Log2MinCbSize,
            uint(size= 8) pbOffset,
            uint(size= 8) pbEnd
        do
                load_fifo();
				IntraSplitFlag  := 0;
                if slice_type != I_SLICE then
                        //println("codIRangeget_PRED_MODE_FLAG := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
                        get_PRED_MODE_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res);
                        predMode := res[0];
                end
                if predMode != INTRA or cu_log2CbSize = Log2MinCbSize then
                        //println("codIRangeget_PART_SIZE := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
                        get_PART_SIZE(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res, predMode = INTRA, cu_log2CbSize, Log2MinCbSize, amp_enabled_flag);
                        partMode := res[0];
                        IntraSplitFlag := if ((partMode=PART_NxN) and (predMode=INTRA)) then 1 else 0 end;
                end
                cu_idx := 4;
                if( predMode = INTRA ) then
                        pcm_flag := 0;
                        if  partMode = PART_2Nx2N and sps_pcm_enabled_flag[sps_id] = 1 and
                                cu_log2CbSize >= log2_min_pcm_cb_size[sps_id] and
                                cu_log2CbSize <= log2_max_pcm_cb_size[sps_id] then
                                //println("codIRangePCMFlag := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
                                get_PCM_FLAG(codIRange, codIOffset, fifoContent, fifoIdx, res);
                                pcm_flag := res[0];
                        end
                        if( pcm_flag != 0) then
                                //byte_align(fifoIdx);
                                intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);
                                predMode := IPCM;
                                cu_idx := 3;
                        else
                                pbOffset := if partMode = PART_NxN then cu_nCbS>>1 else cu_nCbS end;
                                pbEnd    := if partMode = PART_NxN then 1 else 0 end;
                                foreach int i in 0 .. pbEnd do
                                        foreach int j in 0 .. pbEnd do
                                                get_PREV_INTRA_LUMA_PRED_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit);
                                                prev_intra_luma_pred_flag[ (i<<1) + j ] := res1bit[0];
                                        end
                                end
                                foreach int i in 0 .. pbEnd do
                                        foreach int j in 0 .. pbEnd do
                                                if prev_intra_luma_pred_flag[ (i<<1) + j ] = 1 then
                                                        get_MPM_IDX(codIRange, codIOffset, fifoContent, fifoIdx, res);
                                                else
                                                        get_REM_INTRA_LUMA_PRED_MODE(codIRange, codIOffset, fifoContent, fifoIdx, res);
                                                end
                                  
                                                luma_intra_pred_mode(cu_x0 + j*pbOffset, cu_y0 + i*pbOffset, pbOffset, prev_intra_luma_pred_flag[ (i<<1) + j ], res[0], res, Log2MinIPCMCUSize-1 ,Log2CtbSize, intraPredMode, ctb_up_flag, ctb_left_flag);
                                                intra_pred_mode[ (i<<1) + j ] := res[0];
                                        end
                                end
                                get_INTRA_CHROMA_PRED_MODE(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res);
                                intraChrPredModIdx := res[0];
                                if res[0] != 4 then
                                if intra_pred_mode[0] = intra_chroma_table[res[0]] then
                                intra_pred_mode_c := 34;
                                else
                                intra_pred_mode_c := intra_chroma_table[res[0]];
                                end
                        else
                                intra_pred_mode_c := intra_pred_mode[0];
                        end
                                cu_idx := 8;
                        end
                else
                        intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);
                end

                // Tokens Count
                NbTokensPerCTU[2] := NbTokensPerCTU[2] + 1;
        end

        sendIntraPredMode.skip: action ==>
        guard
                predMode != INTRA
        end

        sendIntraPredMode.part2Nx2N: action ==> IntraPredMode:[intra_pred_mode[0], predMode_v], CUInfo:[cuInfo] repeat 5
        guard
                partModeToNumPart[partMode] = 1 and predMode = INTRA
        var
                uint(size=16) cuInfo[5] =
                        [predMode, ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
                                1<<cu_log2CbSize, 1<<cu_log2CbSize],
                uint(size=6) predMode_v,
                uint(size=3) idx
        do
                if(intraChrPredModIdx=4) then
                        predMode_v := intra_pred_mode[0];
                else
                        idx :=
                                if(intra_pred_mode[0] = 0) then
                                        0
                                elsif(intra_pred_mode[0] = 26) then
                                        1
                                elsif(intra_pred_mode[0] = 10) then
                                        2
                                elsif(intra_pred_mode[0] = 1) then
                                        3
                                else
                                        4
                                end;
                        predMode_v := intraPredModeC[intraChrPredModIdx][idx];
                end
                
                // Tokens count.
                NbTokensPerCTU[1] := NbTokensPerCTU[1] + 2;
                NbTokensPerCTU[0] := NbTokensPerCTU[0] + 5;
        end

        sendIntraPredMode.partNxN: action ==> IntraPredMode:[intraPredMode] repeat 8, CUInfo:[cuInfo] repeat 20
        guard
                partModeToNumPart[partMode] != 1 and predMode = INTRA
        var
                uint(size=7) CUSize = (1<<(cu_log2CbSize-1)),
                uint(size=16) cuInfo[20] =
                        [predMode, ctStack[ctStack_idx][CT_x0]       , ctStack[ctStack_idx][CT_y0]       , CUSize, CUSize,
                         predMode, ctStack[ctStack_idx][CT_x0]+CUSize, ctStack[ctStack_idx][CT_y0]       , CUSize, CUSize,
                         predMode, ctStack[ctStack_idx][CT_x0]       , ctStack[ctStack_idx][CT_y0]+CUSize, CUSize, CUSize,
                         predMode, ctStack[ctStack_idx][CT_x0]+CUSize, ctStack[ctStack_idx][CT_y0]+CUSize, CUSize, CUSize],
                uint(size=6) intraPredMode[8],
                uint(size=3) idx
        do
                foreach uint i in 0 .. 3
                do
                        intraPredMode[2*i] := intra_pred_mode[i];

                        if(intraChrPredModIdx=4) then
                                intraPredMode[2*i+1] := intra_pred_mode[0];
                        else
                                idx :=
                                        if(intra_pred_mode[0] = 0) then
                                                0
                                        elsif(intra_pred_mode[0] = 26) then
                                                1
                                        elsif(intra_pred_mode[0] = 10) then
                                                2
                                        elsif(intra_pred_mode[0] = 1) then
                                                3
                                        else
                                                4
                                        end;
                                intraPredMode[2*i+1] := intraPredModeC[intraChrPredModIdx][idx];
                        end
                end
                
                // Tokens count.
                NbTokensPerCTU[1] := NbTokensPerCTU[1] + 8;
                NbTokensPerCTU[0] := NbTokensPerCTU[0] + 20;
        end

        /**************************************************************************
         * read_CodingUnit_gotoPCMSample
         *************************************************************************/
        read_CodingUnit_gotoPCMSample : action ==> CUInfo:[cuInfo] repeat 5, Cbf:[false], SplitTransform:[false],
        								LFBypassCUInfo:[lfBypassCUInfo] repeat 5 
        guard
                cu_idx = 3
        var
                uint(size=16) cuInfo[5] = [IPCM,
                ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
                1<<cu_log2CbSize, 1<<cu_log2CbSize],
                uint(size=16) lfBypassCUInfo[5] = [if(pcm_loop_filter_disable_flag[sps_id] != 0 || cu_transquant_bypass_flag != 0) then 1 else 0 end,
                ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
                1<<cu_log2CbSize, 1<<cu_log2CbSize]
        do
                // Tokens count.
                NbTokensPerCTU[0] := NbTokensPerCTU[0] + 5;
                NbTokensPerCTU[9] := NbTokensPerCTU[9] + 1;
                NbTokensPerCTU[5] := NbTokensPerCTU[5] + 1;
                NbTokensPerCTU[14] := NbTokensPerCTU[14] + 5;
                
                cu_idx := 8;
        end
        
        read_CodingUnit.sendLFBypassCUInfo: action ==> LFBypassCUInfo:[lfBypassCUInfo] repeat 5 
        guard
                cu_idx = 33
        var
                uint(size=16) lfBypassCUInfo[5] = [if(pcm_loop_filter_disable_flag[sps_id] != 0 || cu_transquant_bypass_flag != 0) then 1 else 0 end,
                ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
                1<<cu_log2CbSize, 1<<cu_log2CbSize]
        do
                // Tokens count.
                NbTokensPerCTU[14] := NbTokensPerCTU[14] + 5;
                
                cu_idx := 2;
        end        
        /**************************************************************************
         * read_CodingUnit_gotoPredictionUnit.goto2
         *************************************************************************/
        read_CodingUnit_gotoPredictionUnit.goto2 : action ==> CUInfo:[predMode, x0, y0, pu_PbW, pu_PbH]
        guard
                cu_idx = 4 or cu_idx = 5 or
                cu_idx = 6 or cu_idx = 7
        var
                uint(size= 8) nCbS_2   = cu_nCbS >> 1,
                uint(size= 8) nCbS_4   = cu_nCbS >> 2,
                uint(size= 8) nCbS_3_4 = cu_nCbS - nCbS_4,
                int x0 := ctStack[ctStack_idx][CT_x0],
                int y0 := ctStack[ctStack_idx][CT_y0]
        do
                pu_idx := 1;
                pu_PbW := cu_nCbS;
                pu_PbH := cu_nCbS;
                if partMode = PART_2Nx2N then
                        //prediction_unit( x0, y0, nCbS, nCbS )
                        cu_idx    := 8;
                elsif partMode = PART_2NxN then
                        pu_PbH := nCbS_2;
                        if cu_idx = 4 then
                                //prediction_unit( x0, y0, nCbS, nCbS / 2 )
                                cu_idx := 5;
                        else
                                //prediction_unit( x0, y0 + ( nCbS / 2 ), nCbS, nCbS / 2 )
                                cu_idx := 8;
                                y0 := y0  + nCbS_2;
                        end
                elsif partMode = PART_Nx2N then
                        pu_PbW := nCbS_2;
                        if cu_idx = 4 then
                                //prediction_unit( x0, y0, nCbS / 2, nCbS )
                                cu_idx := 5;
                        else
                                //prediction_unit( x0 + ( nCbS / 2 ), y0, nCbS / 2, nCbS )
                                cu_idx := 8;
                                x0 := x0 + nCbS_2;
                        end
                elsif partMode = PART_2NxnU then
                        pu_PbH := nCbS_4;
                        if cu_idx = 4 then
                                //prediction_unit( x0, y0, nCbS, nCbS / 4 )
                                cu_idx := 5;
                        else
                                //prediction_unit( x0, y0 + ( nCbS / 4 ), nCbS, nCbS *3 / 4 )
                                pu_PbH := nCbS_3_4;
                                cu_idx := 8;
                                y0 := y0  + nCbS_4;
                        end
                elsif partMode = PART_2NxnD then
                        if cu_idx = 4 then
                                //prediction_unit( x0, y0, nCbS, nCbS *3 / 4 )
                                pu_PbH := nCbS_3_4;
                                cu_idx := 5;
                        else
                                //prediction_unit( x0, y0 + ( nCbS * 3 / 4 ), nCbS, nCbS / 4 )
                                pu_PbH := nCbS_4;
                                cu_idx := 8;
                                y0 := y0  + nCbS_3_4;
                        end
                elsif partMode = PART_nLx2N then
                        if cu_idx = 4 then
                                //prediction_unit( x0, y0, nCbS /4, nCbS )
                                pu_PbW := nCbS_4;
                                cu_idx := 5;
                        else
                                //prediction_unit( x0 + ( nCbS / 4 ), y0, nCbS *3 / 4, nCbS)
                                pu_PbW := nCbS_3_4;
                                x0 := x0  + nCbS_4;
                                cu_idx := 8;
                        end
                elsif partMode = PART_nRx2N then
                        if cu_idx = 4 then
                                //prediction_unit( x0, y0, nCbS *3 / 4, nCbS )
                                pu_PbW := nCbS_3_4;
                                cu_idx := 5;
                        else
                                //prediction_unit( x0 + ( nCbS * 3 / 4 ), y0, nCbS / 4, nCbS )
                                pu_PbW := nCbS_4;
                                x0 := x0  + nCbS_3_4;
                                cu_idx := 8;
                        end
                else /* PART_NxN */
                        pu_PbW := nCbS_2;
                        pu_PbH := nCbS_2;
                        if cu_idx = 4 then
                                //prediction_unit( x0, y0, nCbS / 2, nCbS / 2)
                                cu_idx := 5;
                        elsif cu_idx = 5 then
                                //prediction_unit( x0 + ( nCbS / 2 ), y0, nCbS / 2, nCbS / 2 )
                                x0 := x0  + nCbS_2;
                                cu_idx := 6;
                        elsif cu_idx = 6 then
                                //prediction_unit( x0, y0 + ( nCbS / 2 ), nCbS / 2, nCbS / 2 )
                                y0 := y0  + nCbS_2;
                                cu_idx := 7;
                        else
                                //prediction_unit( x0 + ( nCbS / 2 ), y0 + ( nCbS / 2 ), nCbS / 2, nCbS / 2 )
                                x0 := x0  + nCbS_2;
                                y0 := y0  + nCbS_2;
                                cu_idx := 8;
                        end
                end
                
                // Tokens count.
                NbTokensPerCTU[0] := NbTokensPerCTU[0] + 5;
        end
        /**************************************************************************
         * read_CodingUnit.endFunction
         *************************************************************************/
        read_CodingUnit.endFunction : action ==>
        guard
                cu_idx = 8
        var
                uint(size=1) res[1] := [1]
        do
                cu_idx := 10;
                if pcm_flag = 0 then
                	if (predMode != INTRA and not(partMode = PART_2Nx2N and merge_flag = 1)) then
                	    load_fifo();
                		get_NO_RESIDUAL_SYNTAX_FLAG(codIRange, codIOffset, ctxTable,
                		fifoContent, fifoIdx, res); //no_residual_data_flag
                	end
                	if res[0] != 0 then
                		MaxTrafoDepth := if predMode = INTRA then
                			sps_max_transform_hierarchy_depth_intra[sps_id] +
                			IntraSplitFlag
                		else
                			sps_max_transform_hierarchy_depth_inter[sps_id]
                		end;
                		cu_idx := 9; //transform_tree( x0, y0, x0, y0, x0, y0, log2CbSize, log2CbSize, log2CbSize, 0, 0 )
                		elsif predMode != INTRA then // ### not conform to openhevc !
                		cu_idx := 11;
                	end
                end
                
        end

        read_CodingUnit.endFunctionSend : action ==> SplitTransform:[false], TUSize:[1<<cu_log2CbSize, 1, 0, 0, slice_qp, TEXT_LUMA, 0, //luma
                  1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_U, 0,     //cb
                  1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_V, 0], //cr
                  Cbf:[false]
        guard
            cu_idx = 11
        do
        	cu_idx  := 10;

        	// Tokens count
        	NbTokensPerCTU[5] := NbTokensPerCTU[5] + 1;
        	NbTokensPerCTU[6] := NbTokensPerCTU[6] + (7*3);
        	NbTokensPerCTU[9] := NbTokensPerCTU[9] + 1;
        end

        /**************************************************************************
         * read_CodingUnit_gotoTransformTree
         *************************************************************************/
        read_CodingUnit_gotoTransformTree : action ==>
        guard
                cu_idx = 9
        do
                cu_idx                                  := 10;
                ttStack_idx                            	:=  0;
                ttStack[0][TT_idx]                    	:=  1;
                ttStack[0][TT_x0]                      	:=  cu_x0;
                ttStack[0][TT_y0]                    	:=  cu_y0;
                ttStack[0][TT_xBase]                    :=  cu_x0;
                ttStack[0][TT_yBase]                    :=  cu_y0;
                ttStack[0][TT_log2TrafoSize]   			:=  cu_log2CbSize;
                ttStack[0][TT_trafoDepth]               :=  0;
                ttStack[0][TT_blkIdx]                   :=  0;
        end
        /**************************************************************************
         * read_CodingUnit_end
         *************************************************************************/
        procedure set_qPy()
        var
        	int ctb_size_mask        := (1 << Log2CtbSize) - 1,
		    int MinCuQpDeltaSizeMask := (1 << (Log2CtbSize - pps_diff_cu_qp_delta_depth[pps_id])) - 1,
		    int xQgBase              := cu_x0 - (cu_x0 & MinCuQpDeltaSizeMask),
		    int yQgBase              := cu_y0 - (cu_y0 & MinCuQpDeltaSizeMask),
		    int x_cb                 := xQgBase >> Log2MinCbSize,
		    int y_cb                 := yQgBase >> Log2MinCbSize,
		    int availableA           := if ((cu_x0   & ctb_size_mask) != 0 and (xQgBase & ctb_size_mask) != 0) then 1 else 0 end,
		    int availableB           := if (cu_y0   & ctb_size_mask) != 0 and (yQgBase & ctb_size_mask) != 0 then 1 else 0 end,
            int qPy_local 			 := 0,
            int qPy_a 				 := 0,
			int qPy_b 				 := 0,
			int local_qPy_pred		 := 0
        begin
        	if first_qp_group != 0 or (xQgBase = 0 and yQgBase = 0) then
        		first_qp_group := if IsCuQpDeltaCoded != 0 then
        			0
        		else
        			1
        		end;
        		local_qPy_pred := slice_qp;
        	else
        		local_qPy_pred := qPy_pred;
        	end
    		
        	if (availableA = 0) then
        		qPy_a := local_qPy_pred;
        	else
        		qPy_a := qp_y_tab[(x_cb - 1) + y_cb * min_cb_width];
        		
        	end
        	
        	if (availableB = 0) then
        		qPy_b := local_qPy_pred;
        	else
        		qPy_b := qp_y_tab[x_cb + (y_cb - 1) * min_cb_width];
        	end
        	qPy_local := (qPy_a + qPy_b + 1) >> 1;
        	if CuQpDelta != 0 then
        		qp_y := ((qPy_local + CuQpDelta + 52 + 2 * qp_bd_offset_luma) mod
        		(52 + qp_bd_offset_luma)) - qp_bd_offset_luma;
        	else
        		qp_y := qPy_local;
        	end
        end
        
        int qPy_pred			 := 0;
        uint(size= 8) length;
        
        read_CodingUnit_end : action ==> Qp:[length, qp_y]
        guard
                 cu_idx = 10
        var
            uint(size=16) ct_x_cb = cu_x0 >> Log2MinCbSize,
        	uint(size=16) ct_y_cb = cu_y0 >> Log2MinCbSize,
			int x := 0
		do
			length := (1 << cu_log2CbSize) >> Log2MinCbSize;
	        if (pps_cu_qp_delta_enabled_flag[pps_id] != 0 and IsCuQpDeltaCoded = 0) then
	        	set_qPy();
	       	end
	       	x := ct_y_cb * min_cb_width + ct_x_cb;
        	foreach int y in 0 .. length - 1 do
        		qp_y_tab[x + (y * min_cb_width) + length - 1] := qp_y;
        	end
        	x := x + ((length - 1) * min_cb_width);
        	foreach int i in 0 .. length - 1 do
        		qp_y_tab[x + i] := qp_y;
        	end
        	
        	if (((cu_x0 + (1 << cu_log2CbSize)) & qp_block_mask) = 0 && ((cu_y0 + (1 << cu_log2CbSize)) & qp_block_mask) = 0) then // cu_xo and cu_y0 to be checked TODO
        		qPy_pred := qp_y;
        	end
	        foreach uint i in 0 .. length - 1 do
	        	cu_top_ctDepth[ct_x_cb + i] := cu_ctDepth;
	        	cu_left_ctDepth[ct_y_cb + i] := cu_ctDepth;
	        end

	        // Tokens count
	        NbTokensPerCTU[11] := NbTokensPerCTU[11] + 2;
        end

        /**************************************************************************
         **************************************************************************
         ********        Prediction Unit                      *********************
         **************************************************************************
         *************************************************************************/
        uint(size= 8) pu_idx;
        uint(size= 8) pu_PbW;
        uint(size= 8) pu_PbH;
        uint(size= 1) pcm_flag;
        uint(size= 2) inter_pred_idc;
         int(size=16) mergeIdx;
         int(size=16) mvp_lx[2];
         int(size=16) ref_idx_lx[2];
         int(size=16) mvd[4];

        /**************************************************************************
         * read_PredictionUnit.start
         *************************************************************************/
        read_PredictionUnit.start : action ==>  
        guard
                pu_idx = 1
        var
                uint(size=32) res[1],
                uint(size=1) res1bit[1]
        do
            load_fifo();
			inter_pred_idc := PRED_L0;
            mergeIdx := -1;
            mvp_lx := [ -1, -1 ];
            ref_idx_lx := [ -1, -1 ];
            mvd := [ 0, 0, 0, 0 ];
            mvd_x := 0;
            mvd_y := 0;
            if (skip_flag = 1) then
            	if (MaxNumMergeCand > 1) then
            		get_MERGE_IDX(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
            		MaxNumMergeCand);
            		mergeIdx := res[0];
            	else
            		mergeIdx := 0;
            	end
            	pu_idx := 7;
            else

            /* MODE_INTER */
            get_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit);
            merge_flag := res1bit[0];
            if merge_flag = 1 then
            	if MaxNumMergeCand > 1 then
            		get_MERGE_IDX(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
            		MaxNumMergeCand);
            		mergeIdx := res[0];
            	else
            		mergeIdx := 0;
            	end
            	pu_idx := 7;
            else
            	if (slice_type = B_SLICE) then
            		get_INTER_PRED_IDC(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx,
            		res, partMode, pu_PbW, pu_PbH, cu_ctDepth);
            		inter_pred_idc := res[0];
            	end
            	if (inter_pred_idc != PRED_L1) then
            		ref_idx_lx[0] := 0;
            		if (num_ref_idx_l0_active > 1) then
            			get_REF_IDX_LX(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
            			num_ref_idx_l0_active - 1);
            			ref_idx_lx[0] := res[0];
            		end // goto mvd_coding
            		pu_idx := 3;
            	else
            		pu_idx := 4;
            	end
            end end
        end
        
        /**************************************************************************
         * read_PredictionUnit.retMVDcoding_goto1
         *************************************************************************/
        read_PredictionUnit.retMVDcoding_goto1 : action ==>
        guard
                pu_idx = 4
        var
                uint(size=32) res[1],
                uint(size=1) res1bit[1]
        do
                load_fifo();
				mvd[0]  := mvd_x;
                mvd[1]  := mvd_y;
                mvd_x   := 0;
                mvd_y   := 0;
                if( inter_pred_idc != PRED_L1 ) then
                        get_MVP_LX_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit);
                        mvp_lx[0] := res1bit[0];
                end
                pu_idx := 7;
                if( inter_pred_idc != PRED_L0 ) then
                        ref_idx_lx[1] := 0;
                        if( num_ref_idx_l1_active > 1 ) then
                                get_REF_IDX_LX(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res, num_ref_idx_l1_active-1);
                                ref_idx_lx[1] := res[0];
                        end
                        if( mvd_l1_zero_flag = 1 and inter_pred_idc = BI_PRED ) then
                                //mvd_l1[ x0 ][ y0 ][ 0 ] = 0
                                //mvd_l1[ x0 ][ y0 ][ 1 ] = 0
                                pu_idx := 6;
                        else
                                pu_idx := 5;
                        end
                end
        end
        /**************************************************************************
         * read_PredictionUnit_gotoMVDCoding
         *************************************************************************/
        read_PredictionUnit_gotoMVDCoding : action ==>
        guard
                pu_idx = 3 or pu_idx = 5
        do
                pu_idx := pu_idx + 1;
        end
        /**************************************************************************
         * read_PredictionUnit.retMVDcoding_goto2
         *************************************************************************/
        read_PredictionUnit.retMVDcoding_goto2 : action ==>
        guard
                pu_idx = 6
        var
                uint(size=1) res[1]
        do
                load_fifo();
				mvd[2] := mvd_x;
                mvd[3] := mvd_y;
                get_MVP_LX_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res);
                mvp_lx[1] := res[0];
                pu_idx := 7;
        end
        /**************************************************************************
         * read_PredictionUnit_end
         *************************************************************************/
        read_PredictionUnit_end.mergeIdx_Eq_min1 : action ==> MvPredSyntaxElem:[mergeIdx,
                mvp_lx[0]     , mvp_lx[1],
                ref_idx_lx[0] , ref_idx_lx[1],
                mvd[0], mvd[1], mvd[2], mvd[3]]
        guard
                pu_idx = 7, mergeIdx = -1
        do
        	// Tokens count
        	NbTokensPerCTU[8] := NbTokensPerCTU[8] + 9;
        end
        read_PredictionUnit_end.mergeIdx_notEq_min1 : action ==> MvPredSyntaxElem:[mergeIdx,
                mvd[0], mvd[1], mvd[2], mvd[3]]
        guard
                pu_idx = 7, mergeIdx != -1
        do
        	// Tokens count
        	NbTokensPerCTU[8] := NbTokensPerCTU[8] + 5;
        end
        /**************************************************************************
         **************************************************************************
         ********        MVD Coding                           *********************
         **************************************************************************
         *************************************************************************/
         int(size=32) mvd_x;
         int(size=32) mvd_y;
         uint(size= 1) abs_mvd_greater1_flag_1;
         uint(size= 1) abs_mvd_greater0_flag_1;


        read_MVDCoding : action ==>
        var
                uint(size=32) res[1],
                //!TODO : Use only one res variable
                uint(size=1) res1bit[1],
                uint(size= 1) abs_mvd_greater0_flag_0 := 0,
                uint(size= 1) abs_mvd_greater1_flag_0 := 0,
                 int(size=16) abs_mvd_minus2_0 := 0,
                uint(size= 1) mvd_sign_flag_0  := 0,
                int(size=16) abs_mvd_minus2_1 := 0,
                uint(size= 1) mvd_sign_flag_1  := 0
        do
                load_fifo();
				get_ABS_MVD_GREATER0_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit);
                abs_mvd_greater0_flag_0 := res1bit[0];
                get_ABS_MVD_GREATER0_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit);
                abs_mvd_greater0_flag_1 := res1bit[0];
                if abs_mvd_greater0_flag_0 = 1 then
                        get_ABS_MVD_GREATER1_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit);
                        abs_mvd_greater1_flag_0 := res1bit[0];
                end
                if abs_mvd_greater0_flag_1 = 1 then
                        get_ABS_MVD_GREATER1_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit);
                        abs_mvd_greater1_flag_1 := res1bit[0];
                end
                if abs_mvd_greater0_flag_0 = 1 then
                        abs_mvd_minus2_0 := -1;
                        if abs_mvd_greater1_flag_0 = 1 then
                                get_ABS_MVD_MINUS2(codIRange, codIOffset, fifoContent, fifoIdx, res);
                                abs_mvd_minus2_0 := res[0];
                        end
                        get_MVD_SIGN_FLAG(codIRange, codIOffset, fifoContent, fifoIdx, res);
                        mvd_sign_flag_0 := res[0];
                end
                mvd_x := abs_mvd_greater0_flag_0 * ( abs_mvd_minus2_0 + 2 ) * ( 1 - (mvd_sign_flag_0 << 1) );
                
                if abs_mvd_greater0_flag_1 = 1 then
				        load_fifo();
                        abs_mvd_minus2_1 := -1;
                        if abs_mvd_greater1_flag_1 = 1 then
                                get_ABS_MVD_MINUS2(codIRange, codIOffset, fifoContent, fifoIdx, res);
                                abs_mvd_minus2_1 := res[0];
                        end
                        get_MVD_SIGN_FLAG(codIRange, codIOffset, fifoContent, fifoIdx, res);
                        mvd_sign_flag_1 := res[0];
                end
                mvd_y := abs_mvd_greater0_flag_1 * ( abs_mvd_minus2_1 + 2 ) * ( 1 - (mvd_sign_flag_1 << 1) );
        end

        /**************************************************************************
         **************************************************************************
         ********        PCM Sample                           *********************
         **************************************************************************
         *************************************************************************/
   		uint(size=16) pcm_cbSize_luma;
   		uint(size=16) pcm_cbSize_chroma;		
   		uint(size=8) pcm_shift_luma;
   		uint(size=8) pcm_shift_chroma;

        read_PCMSample_start : action ==> PcmSize:[1<<cu_log2CbSize]
        do
            byte_align(fifoIdx);
	   		pcm_cbSize_luma := 1 << (cu_log2CbSize << 1);
	   		pcm_cbSize_chroma := (1 << (cu_log2CbSize << 1)) >> 1;
	   		pcm_shift_luma := sps_bit_depth_luma[sps_id] - pcm_bit_depth_luma[sps_id];
	   		pcm_shift_chroma := sps_bit_depth_chroma[sps_id] - pcm_bit_depth_chroma[sps_id];

    		//pcm_skip_length := (pcm_cbSize_luma * pcm_bit_depth_luma[sps_id] + pcm_cbSize_chroma * pcm_bit_depth_chroma[sps_id] + 7) >> 3;
    		cnt_i := 0;

        	// Tokens Count
        	NbTokensPerCTU[12] := NbTokensPerCTU[12] + 1;
       end

       read_PCMSample_loop_luma : action ==> PcmBlk:[pcm_sample]
       guard cnt_i < pcm_cbSize_luma
       var
       		uint(size=32) res[1],
       		uint(size=8) pcm_sample
       do
       		load_fifo();
	        vld_u_name(pcm_bit_depth_luma[sps_id], fifoContent, fifoIdx, res, "pcm_sample_luma[x][y]                      ");
	        pcm_sample := res[0] << pcm_shift_luma;
	        cnt_i := cnt_i + 1;
	        
        	// Tokens Count
        	NbTokensPerCTU[13] := NbTokensPerCTU[13] + 1;
       end
       
       read_PCMSample_end_luma : action ==> PcmSize:[(1<<cu_log2CbSize)>>1, (1<<cu_log2CbSize)>>1]
       guard
       		cnt_i = pcm_cbSize_luma
       do
       		cnt_i := 0;
       		
        	// Tokens Count
        	NbTokensPerCTU[12] := NbTokensPerCTU[12] + 2;
       end

       read_PCMSample_loop_chroma : action ==> PcmBlk:[pcm_sample]
       guard cnt_i < pcm_cbSize_chroma
       var
       		uint(size=32) res[1],
       		uint(size=8) pcm_sample
       do
       		load_fifo();
	        vld_u_name(pcm_bit_depth_chroma[sps_id], fifoContent, fifoIdx, res, "pcm_sample_chroma[x][y]                  ");
	        pcm_sample := res[0] << pcm_shift_chroma;
	        cnt_i := cnt_i + 1;
	        
        	// Tokens Count
        	NbTokensPerCTU[13] := NbTokensPerCTU[13] + 1;
       end       
       
       read_PCMSample_end_chroma : action ==>
       guard
       		cnt_i = pcm_cbSize_chroma
       do
       		cnt_i := 0;
            decodeReInit(codIRange, codIOffset, fifoContent, fifoIdx);
        end

        /**************************************************************************
         **************************************************************************
         ********        Transform Tree                       *********************
         **************************************************************************
         *************************************************************************/

        uint(size= 8) ttStack_idx;
        uint(size=16) ttStack[10][TT_STRUCT_SIZE];
        uint(size= 1) cbf_cb[MAX_TU_SIZE][MAX_TU_SIZE][4];
        uint(size= 1) cbf_cr[MAX_TU_SIZE][MAX_TU_SIZE][4];
        uint(size= 1) cbf_luma;
        uint(size= 8) cur_intra_pred_mode;
        uint(size= 1) split_transform_flag;
        uint(size=16) cbf_xBase;
        uint(size=16) cbf_yBase;                

        /**************************************************************************
         * read_TransformTree.start
         *************************************************************************/
        read_TransformTree.start : action ==>
        guard
                ttStack[ttStack_idx][TT_idx] = 1
        var
                uint(size=16) x0                                = ttStack[ttStack_idx][TT_x0],
                uint(size=16) y0                                = ttStack[ttStack_idx][TT_y0],
                uint(size=16) xBase                             = ttStack[ttStack_idx][TT_xBase],
                uint(size=16) yBase                             = ttStack[ttStack_idx][TT_yBase],
                uint(size= 8) log2TrafoSize         = ttStack[ttStack_idx][TT_log2TrafoSize],
                uint(size= 8) trafoDepth                = ttStack[ttStack_idx][TT_trafoDepth],
                uint(size=16) cbf_x0                    = x0 & ((1<<log2TrafoSize)-1),
                uint(size=16) cbf_y0                    = y0 & ((1<<log2TrafoSize)-1),
                uint(size=1) res[1] := [0],
                uint(size= 1) IntraSplitFlag   = if predMode = INTRA and partMode = PART_NxN then 1 else 0 end,
                uint(size= 1) InterSplitFlag   = if sps_max_transform_hierarchy_depth_inter[sps_id] = 0 and predMode = INTER and partMode != PART_2Nx2N and trafoDepth = 0 then 1 else 0 end
        do
    		load_fifo();
			cbf_xBase := xBase & ((1 << log2TrafoSize) - 1);
    		cbf_yBase := yBase & ((1 << log2TrafoSize) - 1);
    		if DEBUG_CABAC and DEBUG_TRACE1 then
    			println("read_TransformTree.start(" + x0 + ", " + y0 + ", " + xBase
    			+ ", " + yBase + ", " + log2TrafoSize + ", " + trafoDepth + ", " +
    			ttStack[ttStack_idx][TT_blkIdx] + ")");
    			elsif DEBUG_CABAC then println("read_TransformTree.start");
    		end
    		if IntraSplitFlag = 1 then
    			if trafoDepth = 1 then
    				cur_intra_pred_mode :=
    				intra_pred_mode[ttStack[ttStack_idx][TT_blkIdx]];
    			end
    		else
    			cur_intra_pred_mode := intra_pred_mode[0];
    		end
    		split_transform_flag := 0;
    		if (log2TrafoSize <= Log2MaxTrafoSize and log2TrafoSize >
    		Log2MinTrafoSize and trafoDepth < MaxTrafoDepth and
    		not(IntraSplitFlag = 1 and trafoDepth = 0)) then
    			get_SPLIT_TRANSFORM_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx,
    			res, log2TrafoSize);
    			split_transform_flag := res[0];
    			elsif log2TrafoSize > Log2MaxTrafoSize or (IntraSplitFlag = 1 and
    			trafoDepth = 0) or InterSplitFlag = 1 then split_transform_flag :=
    			1;
    		end
    		cbf_cb[cbf_x0][cbf_y0][trafoDepth] := 0;
    		cbf_cr[cbf_x0][cbf_y0][trafoDepth] := 0;
    		if trafoDepth = 0 or log2TrafoSize > 2 then
    			if trafoDepth = 0 then
    				get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
    				trafoDepth);
    				cbf_cb[cbf_x0][cbf_y0][trafoDepth] := res[0];
    				get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
    				trafoDepth);
    				cbf_cr[cbf_x0][cbf_y0][trafoDepth] := res[0];
    			else
    				if cbf_cb[cbf_xBase][cbf_yBase][trafoDepth - 1] = 1 then
    					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
    					trafoDepth);
    					cbf_cb[cbf_x0][cbf_y0][trafoDepth] := res[0];
    				end
    				if cbf_cr[cbf_xBase][cbf_yBase][trafoDepth - 1] = 1 then
    					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
    					trafoDepth);
    					cbf_cr[cbf_x0][cbf_y0][trafoDepth] := res[0];
    				end
    			end
    		end
    		if trafoDepth > 0 and log2TrafoSize = 2 then
    			cbf_cb[cbf_x0][cbf_y0][trafoDepth] :=
    			cbf_cb[cbf_xBase][cbf_yBase][trafoDepth - 1];
    			cbf_cr[cbf_x0][cbf_y0][trafoDepth] :=
    			cbf_cr[cbf_xBase][cbf_yBase][trafoDepth - 1];
    		end
    		if split_transform_flag = 1 then
    			ttStack[ttStack_idx][TT_x1] := x0 + ((1 << log2TrafoSize) >> 1);
    			ttStack[ttStack_idx][TT_y1] := y0 + ((1 << log2TrafoSize) >> 1);
    			ttStack[ttStack_idx][TT_idx] := 3;
    		else
    			cbf_luma := 1;
    			if predMode = INTRA or trafoDepth != 0 or
    			cbf_cb[cbf_x0][cbf_y0][trafoDepth] = 1 or
    			cbf_cr[cbf_x0][cbf_y0][trafoDepth] = 1 then
    				get_CBF_LUMA(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res,
    				trafoDepth);
    				cbf_luma := res[0];
    			end
    			ttStack[ttStack_idx][TT_idx] := 2;
    		end
    		if not(partMode = PART_NxN and ttStack[ttStack_idx][TT_trafoDepth] =
    		0) then
    			ttStack[ttStack_idx][TT_idx] := 10;
    		end
        end

        read_TransformTree.start_nonPartNxN : action ==> SplitTransform:[(split_transform_flag != 0)]
        guard
                ttStack[ttStack_idx][TT_idx] = 10
        do
			ttStack[ttStack_idx][TT_idx] := 2 + split_transform_flag;
        	
        	// Tokens Count
        	NbTokensPerCTU[5] := NbTokensPerCTU[5] + 1;
        end
        /**************************************************************************
         * read_TransformTree_gotoTransformUnit
         *************************************************************************/
        read_TransformTree_gotoTransformUnit : action ==> Cbf:[cbf_luma = 1]
        guard
                ttStack[ttStack_idx][TT_idx] = 2
        do
                ttStack[ttStack_idx][TT_idx]    := 7;
                tu_idx                                                  := 1;
                tu_x0                                                   := ttStack[ttStack_idx][TT_x0];
                tu_y0                                                   := ttStack[ttStack_idx][TT_y0];
                tu_xBase                                                := ttStack[ttStack_idx][TT_xBase];
                tu_yBase                                                := ttStack[ttStack_idx][TT_yBase];
                tu_log2TrafoSize                                		:= ttStack[ttStack_idx][TT_log2TrafoSize];
                tu_trafoDepth                                   		:= ttStack[ttStack_idx][TT_trafoDepth];
                tu_blkIdx                                               := ttStack[ttStack_idx][TT_blkIdx];

                // Tokens count
                NbTokensPerCTU[9] := NbTokensPerCTU[9] + 1;
        end
        /**************************************************************************
         * read_TransformTree.gotoTransformTree
         *************************************************************************/
        read_TransformTree.gotoTransformTree : action ==>
        guard
                ttStack[ttStack_idx][TT_idx] = 3 or ttStack[ttStack_idx][TT_idx] = 4 or
                ttStack[ttStack_idx][TT_idx] = 5 or ttStack[ttStack_idx][TT_idx] = 6
        var
                uint(size= 8) idx = ttStack_idx
        do
                ttStack[ttStack_idx][TT_idx]                            := ttStack[ttStack_idx][TT_idx] + 1;
                ttStack_idx                                                             := ttStack_idx + 1;
                ttStack[ttStack_idx][TT_idx]                            := 1;
                ttStack[ttStack_idx][TT_x0]                             := ttStack[idx][TT_x0];
                ttStack[ttStack_idx][TT_y0]                             := ttStack[idx][TT_y0];
                ttStack[ttStack_idx][TT_xBase]                          := ttStack[idx][TT_x0];
                ttStack[ttStack_idx][TT_yBase]                          := ttStack[idx][TT_y0];
                ttStack[ttStack_idx][TT_log2TrafoSize]          		:= ttStack[idx][TT_log2TrafoSize] - 1;
                ttStack[ttStack_idx][TT_trafoDepth]                     := ttStack[idx][TT_trafoDepth] + 1;
                if ttStack[idx][TT_idx] = 4 then
                        ttStack[ttStack_idx][TT_blkIdx]                 := 0;
                elsif ttStack[idx][TT_idx] = 5 then
                        ttStack[ttStack_idx][TT_x0]                     := ttStack[idx][TT_x1];
                        ttStack[ttStack_idx][TT_blkIdx]                 := 1;
                elsif ttStack[idx][TT_idx] = 6 then
                        ttStack[ttStack_idx][TT_y0]                     := ttStack[idx][TT_y1];
                        ttStack[ttStack_idx][TT_blkIdx]                 := 2;
                else
                        ttStack[ttStack_idx][TT_x0]                     := ttStack[idx][TT_x1];
                        ttStack[ttStack_idx][TT_y0]                     := ttStack[idx][TT_y1];
                        ttStack[ttStack_idx][TT_blkIdx]                 := 3;
                end
        end
        /**************************************************************************
         * read_TransformTree_end
         *************************************************************************/
        read_TransformTree_end : action ==>
        guard
                ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx = 0
        end
        read_TransformTree.endCall : action ==>
        guard
                ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx != 0
        do
                ttStack_idx := ttStack_idx - 1;
        end

        /**************************************************************************
         **************************************************************************
         ********        Transform Unit                       *********************
         **************************************************************************
         *************************************************************************/
        uint(size= 8) tu_idx;
        uint(size=16) tu_x0;
        uint(size=16) tu_y0;
        uint(size=16) tu_xBase;
        uint(size=16) tu_yBase;
        uint(size= 8) tu_trafoDepth;
        uint(size= 8) tu_blkIdx;
        uint(size= 8) tu_log2TrafoSize;
         int(size= 8) qp_y_tab[MAX_PICT_WIDTH_IN_CU * MAX_PICT_HEIGHT_IN_CU];
         
        /**************************************************************************
         * read_TransformUnit.start
         *************************************************************************/
        read_TransformUnit.start : action ==> 
        guard
                tu_idx = 1
        var
        		uint(size=32) res[1]	 := [0],
                uint(size=16) cbf_x0   	 = cu_x0 & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_y0   	 = cu_y0 & ((1<<tu_log2TrafoSize)-1)			
        do
				if DEBUG_CABAC and DEBUG_TRACE1 then
                        println("read_TransformUnit.start("+tu_x0+", "+tu_y0+", "+tu_xBase+", "+tu_yBase+", "+
                                        tu_log2TrafoSize+", "+tu_log2TrafoSize+", "+tu_trafoDepth+", "+tu_blkIdx+")");
                elsif DEBUG_CABAC then
                        println("read_TransformUnit.start");
                end
                if cbf_luma != 0 or cbf_cb[cbf_x0][cbf_y0][tu_trafoDepth] != 0 or
                cbf_cr[cbf_x0][cbf_y0][tu_trafoDepth] != 0 then
                	//println("case 1");
                	if pps_cu_qp_delta_enabled_flag[pps_id] != 0 and IsCuQpDeltaCoded = 0 then
                	    load_fifo();
                		//println("case 2");
                		get_CU_QP_DELTA_ABS(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res);
                		CuQpDelta := res[0];
                		if CuQpDelta != 0 then
                			get_CU_QP_DELTA_SIGN_FLAG(codIRange, codIOffset, fifoContent, fifoIdx, res);
                			//println("case 3");
                			if res[0] = 1 then
                				CuQpDelta := -CuQpDelta;
                				//println("case 4");
                			end
                		end
                		IsCuQpDeltaCoded := 1;
						set_qPy();
						//println("qp_y read_TransformUnit = "+ qp_y);
                	end
                end
                //println("tu_x0 = " + tu_x0 + "   tu_y0 = " + tu_y0 + "   cux = " + cu_x0 + "   cuy = " + cu_y0);
                tu_idx                          := 8; // skipResidualCoding
                rc_x0                           := tu_x0;
                rc_y0                           := tu_y0;
                rc_log2TrafoSize        		:= tu_log2TrafoSize;
                rc_scanIdx                      := getScanIdx(predMode, tu_log2TrafoSize, cur_intra_pred_mode);
                rc_cIdx                         := TEXT_LUMA;
                rc_cBitDepth 					:= sps_bit_depth_luma[sps_id];                
                if cbf_luma = 1 then
                        tu_idx                  := 2;
                end
        end
        /**************************************************************************
         * read_TransformUnit.retLuma
         *************************************************************************/
        read_TransformUnit.retLuma : action ==>
        guard
                tu_idx = 3
        var
                uint(size=16) cbf_x0                    = tu_x0 & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_y0                    = tu_y0 & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_xBase                 = tu_xBase & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_yBase                 = tu_yBase & ((1<<tu_log2TrafoSize)-1)
        do
                tu_idx                          := 5;
                rc_log2TrafoSize        		:= tu_log2TrafoSize;
                rc_scanIdx                      := getScanIdx(predMode, rc_log2TrafoSize, intra_pred_mode_c);
                rc_cIdx                         := TEXT_CHROMA_U;
                rc_cBitDepth 					:= sps_bit_depth_chroma[sps_id];
                if tu_log2TrafoSize > 2 then
                        tu_idx                          := 10;  // skipResidualCoding
                        rc_x0                           := tu_x0;
                        rc_y0                           := tu_y0;
                        rc_log2TrafoSize        		:= tu_log2TrafoSize - 1;
                        if cbf_cb[ cbf_x0 ][ cbf_y0 ][ tu_trafoDepth ] = 1 then
                                tu_idx                  := 4;
                        end
                elsif tu_blkIdx = 3 then
                        tu_idx                  := 10;  // skipResidualCoding
                        rc_x0                   := tu_xBase;
                        rc_y0                   := tu_yBase;
                        if cbf_cb[ cbf_xBase ][ cbf_yBase ][ tu_trafoDepth ] = 1 then
                                tu_idx          := 4;
                        end
                end
        end
        /**************************************************************************
         * read_TransformUnit.retCb
         *************************************************************************/
        read_TransformUnit.retCb : action ==>
        guard
                tu_idx = 5
        var
                uint(size=16) cbf_x0                    = tu_x0 & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_y0                    = tu_y0 & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_xBase                 = tu_xBase & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_yBase                 = tu_yBase & ((1<<tu_log2TrafoSize)-1)
        do
                tu_idx   		:= 7;
                rc_cIdx  		:= TEXT_CHROMA_V;
                rc_cBitDepth	:= sps_bit_depth_chroma[sps_id];
                if tu_log2TrafoSize > 2 then
                        tu_idx                          := 12;  // skipResidualCoding
                        rc_log2TrafoSize        := tu_log2TrafoSize - 1;
                        if cbf_cr[ cbf_x0 ][ cbf_y0 ][ tu_trafoDepth ] = 1 then
                                tu_idx                  := 6;
                        end
                elsif tu_blkIdx = 3 then
                        tu_idx   := 12;  // skipResidualCoding
                        if cbf_cr[ cbf_xBase ][ cbf_yBase ][ tu_trafoDepth ] = 1 then
                                tu_idx                  := 6;
                        end
                end
        end
        /**************************************************************************
         * read_TransformUnit_gotoResidualCoding
         *************************************************************************/
        read_TransformUnit_gotoResidualCoding : action ==>
        guard
                tu_idx = 2 or tu_idx = 4 or tu_idx = 6
        do
                tu_idx := tu_idx + 1;
        end
        /**************************************************************************
         * read_TransformUnit.skipResidualCoding
         *************************************************************************/
        read_TransformUnit.skipResidualCoding : action ==> TUSize:[1<<rc_log2TrafoSize, 2, 0, 0, slice_qp, rc_cIdx, 0]
        guard
                tu_idx = 8 or tu_idx = 10 or tu_idx = 12
        do 		
        		
                tu_idx := tu_idx - 5;
                qp := qp_y + qp_bd_offset_luma;
                if rc_cIdx = 0 then
//                	println("SkipMode" + "   size = " + (1<<rc_log2TrafoSize) + "   QP = " + qp_y + "   qp = " + qp);
//                	QPCounter := QPCounter +  (1<<rc_log2TrafoSize) *(1<<rc_log2TrafoSize) / 16;
//                	println("qpCounter = " + QPCounter);
                else
//                	println("skipModeChroma size = " + (1<<rc_log2TrafoSize) + "QP = " + qp_y);
                end
                
                // Tokens Count
                NbTokensPerCTU[6] := NbTokensPerCTU[6] + 7;
        end
        
        /**************************************************************************
         * read_TransformUnit_end
         *************************************************************************/
        read_TransformUnit_end : action ==>
        guard
                tu_idx = 7
        do
                if DEBUG_CABAC then
                        println("read_TransformUnit_end");
                end
        end

        /**************************************************************************
         **************************************************************************
         ********        Residual Coding                      *********************
         **************************************************************************
         *************************************************************************/
        uint(size=16) rc_x0;
        uint(size=16) rc_y0;
        uint(size= 8) rc_log2TrafoSize;
        uint(size= 8) rc_scanIdx;
        uint(size= 8) rc_cIdx;
        uint(size= 8) rc_cBitDepth;
        //
        uint(size= 8) ScanOrder[4][3][(BLW_WIDTH_MAX/4)*(BLW_HEIGHT_MAX/4)][2];
        uint(size= 8) significant_coeff_flag_idx[16];
        uint(size= 8) nb_significant_coeff_flag;
        uint(size= 1) coded_sub_block_flag[8][8];
        uint(size= 8) LastSignificantCoeffX;
        uint(size= 8) LastSignificantCoeffY;


        /**************************************************************************
         * read_ResidualCoding.start
         *************************************************************************/
        uint(size= 8) rc_lastScanPos;
         int(size= 8) rc_lastSubBlock;
         int(size= 8) rc_i;
         int add := 0;
         int scale;
         int dc_scale := 0;
         uint(size=8) scale_matrix [64];
         uint(size= 8) shift := 0;
         int(size= 8) qp_y := 0;
         int(size=16) qp;
         uint(size= 8) qp_c[58] = [
        	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
        	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        	20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
			29, 30, 31, 32, 33, 33, 34, 34, 35, 35,
			36, 36, 37, 37, 38, 39, 40, 41, 42, 43,
        	44, 45, 46, 47, 48, 49, 50, 51];
		
        read_ResidualCoding.start : action ==> TUSize:[sz, 0, isDST, transform_skip_flag, slice_qp, rc_cIdx,
                            pps_chroma_qp_offset[pps_id][rc_cIdx] + slice_chroma_qp_offset[rc_cIdx]]
        var
			uint(size=32) res[1],
			uint(size=1) res1bit[1],
			int sz = 1 << rc_log2TrafoSize,
			uint(size=1) transform_skip_flag,
			int matrix_id,
			int qp_offset,
			int(size=16) qp_i,
			 
			uint(size=16) num_coeff := 0,
			int x_cg_last_sig, 
			int y_cg_last_sig,
			int last_x_c,
			int last_y_c,
			uint(size=1) isDST = if (predMode = INTRA and rc_cIdx = TEXT_LUMA and sz = 4) then 1 else 0 end
        do
		    load_fifo();
            if DEBUG_CABAC and DEBUG_TRACE1 then
                    println("read_ResidualCoding.start "+if rc_cIdx = TEXT_LUMA then "cbY" elsif rc_cIdx = TEXT_CHROMA_U then "cbU" else "cbV" end+"("+rc_x0+", "+rc_y0+", "+rc_log2TrafoSize+", "+rc_scanIdx+", "+rc_cIdx+")");
            elsif DEBUG_CABAC then
                    println("read_ResidualCoding.start "+if rc_cIdx = TEXT_LUMA then "cbY" elsif rc_cIdx = TEXT_CHROMA_U then "cbU" else "cbV" end);
            end

	         if cu_transquant_bypass_flag = 0 then
	            if rc_cIdx = 0 then
	        		qp := qp_y + qp_bd_offset_luma;
	    		else
                    qp_offset := pps_chroma_qp_offset[pps_id][rc_cIdx] + slice_chroma_qp_offset[rc_cIdx];
	        		qp_i := clip_i32(qp_y + qp_offset, - qp_bd_offset_chroma, 57);
	        		if(qp_i < 0) then
	        			qp := qp_i + qp_bd_offset_chroma;
	        		else
	            		qp := qp_c[qp_i] + qp_bd_offset_chroma;
	            	end	
	        	end
	        	
				shift := sps_bit_depth_minus5[sps_id][rc_cIdx] + rc_log2TrafoSize;
	            add := 1 << (shift - 1);
	            scale := levelScaleArray[qp];
	            dc_scale := 16;
	            
	            if sps_scaling_list_enabled_flag[sps_id] = 1 then
	       			matrix_id := if predMode != INTRA then 1 else 0 end;
	        		if rc_log2TrafoSize != 5 then
	            		matrix_id := 3 * matrix_id + rc_cIdx;
	                end
	                if pps_scaling_list_data_present_flag[pps_id] = 1 then
	                    set_scale_matrix(scale_matrix, pps_sl, 0, pps_id * 4 * 6 * 64 + (rc_log2TrafoSize - 2) * 6 * 64 + matrix_id * 64, 64, pps_id, rc_log2TrafoSize - 2, matrix_id);
	                	if rc_log2TrafoSize >= 4 then
	                    	dc_scale := pps_sl_dc[pps_id][rc_log2TrafoSize - 4][matrix_id];
	                	end
	            	else
	            	    set_scale_matrix(scale_matrix, sps_sl, 0, sps_id * 4 * 6 * 64 + (rc_log2TrafoSize - 2) * 6 * 64 + matrix_id * 64, 64, sps_id, rc_log2TrafoSize - 2, matrix_id);
	                	if rc_log2TrafoSize >= 4 then
	                    	dc_scale := sps_sl_dc[sps_id][rc_log2TrafoSize - 4][matrix_id];
	                	end
	            	end
	    		end
	        else
	        	shift        := 0;
	        	add        	 := 0;
	        	scale        := 0;
	        	dc_scale     := 0;
	        end
	        
            reset_coded_sub_block_flag(coded_sub_block_flag, 0, 8 * 8);
            
            if pps_transform_skip_enabled_flag[pps_id] = 1 and cu_transquant_bypass_flag = 0 and
                    rc_log2TrafoSize = 2 then
                    get_TRANSFORM_SKIP_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit, rc_cIdx);
                    transform_skip_flag := res1bit[0];
            else
                    transform_skip_flag := 0;
            end

            get_LAST_SIGNIFICANT_COEFF_XY_PREFIX();
            if LastSignificantCoeffX > 3 then
            	get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, fifoContent, fifoIdx, res, LastSignificantCoeffX);
            	LastSignificantCoeffX := (1 << ((LastSignificantCoeffX >> 1) - 1)) *
                                         (2  +  (LastSignificantCoeffX & 1 )) + res[0];
            end
            if LastSignificantCoeffY > 3 then
            	get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, fifoContent, fifoIdx, res, LastSignificantCoeffY);
            	LastSignificantCoeffY := (1 << ((LastSignificantCoeffY >> 1) - 1)) *
                                         (2  +  (LastSignificantCoeffY & 1 )) + res[0];
            end


            if rc_scanIdx = SCAN_VER then
                    res[0] := LastSignificantCoeffX;
                    LastSignificantCoeffX := LastSignificantCoeffY;
                    LastSignificantCoeffY := res[0];
            end
 
			x_cg_last_sig := LastSignificantCoeffX >> 2;
            y_cg_last_sig := LastSignificantCoeffY >> 2;

            if rc_scanIdx = 0 then
              last_x_c := LastSignificantCoeffX & 3;
              last_y_c := LastSignificantCoeffY & 3;

              num_coeff := diag_scanYxY_inv[DIAG_SCAN_4X4][last_y_c][last_x_c];
              num_coeff := (num_coeff + (diag_scanYxY_inv[(rc_log2TrafoSize - 3) & 3][y_cg_last_sig][x_cg_last_sig] << 4));        
            elsif rc_scanIdx = 1 then
              num_coeff := horiz_scan8x8_inv[LastSignificantCoeffY][LastSignificantCoeffX];
        
            elsif rc_scanIdx = 2 then
              num_coeff := horiz_scan8x8_inv[LastSignificantCoeffX][LastSignificantCoeffY];
            end
      
            num_coeff := num_coeff + 1;
            rc_lastSubBlock := (num_coeff - 1) >> 4;
            rc_lastScanPos := num_coeff - (rc_lastSubBlock << 4) - 1;
        
            rc_i := rc_lastSubBlock;
            if rc_cIdx = 0 then
//	            println("read_ResidualCoding" + "   size = " + sz + "   QP_y = " + qp_y + "   QP = " + qp);
//	            QPCounter := QPCounter +  (1<<rc_log2TrafoSize) *(1<<rc_log2TrafoSize) / 16;
//	            println("qpCounter = " + QPCounter);
	        end
	        
	        // Tokens count
	        NbTokensPerCTU[6] := NbTokensPerCTU[6] + 7;
        end
        
        uint(size=16) rc_xS;
        uint(size=16) rc_yS;
         int(size= 8) m_end;
		int(size=64) transCoeffLevel := 0;         
        
        uint(size= 8) rc_ctxSet[1];
        uint(size= 8) rc_greater1Ctx[1];
        uint(size= 8) rc_firstSigScanPos;
         int(size= 8) rc_firstGreater1ScanPos;
        uint(size= 8) coeff_abs_level_greater1_flag[16];
        uint(size= 8) coeff_abs_level_greater2_flag;
        uint(size=16) coeff_sign_flag;
        uint(size= 1) rc_signHidden;
        uint(size= 8) rc_sumAbsLevel;
        uint(size= 8) rc_cLastRiceParam;
        
        procedure applyDequant(uint(size=16) xC, uint(size=16) yC)
        var
			int pos,
			int scale_m
        begin
			if cu_transquant_bypass_flag = 0 then
			    if sps_scaling_list_enabled_flag[sps_id] = 0 then
			        transCoeffLevel := clip_i32(( ( transCoeffLevel * 16 * scale + add )) >> shift, -32768, 32767 );
			    else
			        if yC != 0 or xC != 0 or (rc_log2TrafoSize < 4) then
			            if rc_log2TrafoSize = 3 then
			                pos := (yC << 3) + xC;
			            elsif rc_log2TrafoSize = 4 then
			                pos := ((yC >> 1) << 3) + (xC >> 1);
			            elsif rc_log2TrafoSize = 5 then
			                pos := ((yC >> 2) << 3) + (xC >> 2);
			            else
			                pos := (yC << 2) + xC;
			            end
			            scale_m := scale_matrix[pos];
			        else
			            scale_m := dc_scale;
			        end
			        transCoeffLevel := clip_i32(( ( transCoeffLevel * scale_m * scale + add )) >> shift, -32768, 32767 );
			    end
			end
        end
        
        /**************************************************************************
         * read_ResidualCoding()
         *************************************************************************/
        procedure read_residualCoding(int(size= 16) tabTransCoeffLevel[32*32+1])
        var
                uint(size=1) res[1],
                uint(size= 8) n,
                uint(size=16) xC,
                uint(size=16) yC,
                uint(size= 1) inferSigCoeffFlag,
                
                 //!TODO : Use only one res var
                 uint(size=1) res1bit[1] := [0],
                 int(size= 8) lastSigScanPos  := -1,
                uint(size= 8) numGreater1Flag :=  0,
                uint(size= 9) ctxIdxInc[1],
                
                uint(size=32) resCoeff[1] 		:= [0],
                bool subAbsLevelFlag
        begin
                while (rc_i >= 0)
                do
                    //  read_ResidualCoding.for_numLastSubset.start >>>>
                    load_fifo();
			        rc_xS := ScanOrder[rc_log2TrafoSize-2][ rc_scanIdx ][ rc_i ][ 0 ];
                    rc_yS := ScanOrder[rc_log2TrafoSize-2][ rc_scanIdx ][ rc_i ][ 1 ];
                    inferSigCoeffFlag := 0;
        	        if rc_i < rc_lastSubBlock and rc_i > 0 then
                       get_CODED_SUB_BLOCK_FLAG( codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res, coded_sub_block_flag, rc_xS, rc_yS, rc_cIdx, rc_log2TrafoSize);
                       coded_sub_block_flag[ rc_xS ][ rc_yS ] := res[0];
                       inferSigCoeffFlag := 1;
        	        else
                       if (rc_xS = LastSignificantCoeffX>>2 and rc_yS = LastSignificantCoeffY>>2) or (rc_xS = 0 and rc_yS = 0) then
                           coded_sub_block_flag[ rc_xS ][ rc_yS ] := 1;
                       end
        	        end

                    if coded_sub_block_flag[ rc_xS ][ rc_yS ] = 1 then
        	            m_end := 15;
                        nb_significant_coeff_flag := 0;
                        if rc_i = rc_lastSubBlock then
            	            m_end                         := rc_lastScanPos - 1;
                            significant_coeff_flag_idx[0] := rc_lastScanPos;
                            nb_significant_coeff_flag     := 1;
        	            end
        	        
        	            foreach int m in 0 .. m_end do
                            n  := m_end - m;
                            xC := ( rc_xS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 0 ];
                            yC := ( rc_yS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 1 ];
                            if ( n > 0 or inferSigCoeffFlag = 0 ) then
                                get_SIGNIFICANT_COEFF_FLAG( codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res, coded_sub_block_flag, xC, yC, rc_cIdx, rc_log2TrafoSize, rc_scanIdx);
                                if res[0] = 1 then
                                    significant_coeff_flag_idx[nb_significant_coeff_flag] := n;
            			            nb_significant_coeff_flag := nb_significant_coeff_flag + 1;
            			            inferSigCoeffFlag := 0;
       				            end
            	            else
	                            if (xC = LastSignificantCoeffX and yC = LastSignificantCoeffY) or
	                               (( (xC&3) = 0 and (yC&3) = 0) and inferSigCoeffFlag = 1) then
	                                significant_coeff_flag_idx[nb_significant_coeff_flag] := n;
	                                nb_significant_coeff_flag := nb_significant_coeff_flag + 1;
	                            end
            	            end
       		            end
       		        
                        m_end := nb_significant_coeff_flag - 1;
                        // read_ResidualCoding.for_numLastSubset.start <<<<
            
                        if m_end >= 0 then
                        
                            load_fifo();
                    
                            // read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG >>>>
                            res[0] := 0;
				            rc_firstSigScanPos := 16;
                            rc_firstGreater1ScanPos := -1;
                            lastSigScanPos  := -1;
                            numGreater1Flag :=  0;
                            foreach int m in 0 .. (if m_end > 7 then 7 else m_end end) do
                                n  := significant_coeff_flag_idx[m];
                        	    context_93315(rc_cIdx, rc_i, numGreater1Flag = 0,
                        	        rc_i = rc_lastSubBlock, rc_ctxSet, rc_greater1Ctx,
                        	        ctxIdxInc);
                        	    get_COEFF_ABS_LEVEL_GREATER1_FLAG(codIRange,
                        	       codIOffset, ctxTable, fifoContent, fifoIdx, res1bit, ctxIdxInc[0]);
                        	    if res1bit[0] = 1 then
                        		    rc_greater1Ctx[0] := 0;
                        		    if (rc_firstGreater1ScanPos = -1) then
                        		       rc_firstGreater1ScanPos := n;
                        	        end
                        		elsif rc_greater1Ctx[0] > 0 and rc_greater1Ctx[0] <
                        		   3 then rc_greater1Ctx[0] := rc_greater1Ctx[0] + 1;
                        	    end
                        	    
                        	    coeff_abs_level_greater1_flag[m] := res1bit[0];
                        	    numGreater1Flag := numGreater1Flag + 1;
                            end
                            lastSigScanPos := significant_coeff_flag_idx[0];
                            rc_firstSigScanPos := significant_coeff_flag_idx[m_end];

                            rc_signHidden := if lastSigScanPos - rc_firstSigScanPos > 3 and cu_transquant_bypass_flag = 0 then 1 else 0 end;
                            if rc_firstGreater1ScanPos != -1 then
                                get_COEFF_ABS_LEVEL_GREATER2_FLAG(codIRange, codIOffset, ctxTable, fifoContent, fifoIdx, res1bit, rc_cIdx, rc_ctxSet[0]);
                                coeff_abs_level_greater2_flag := res1bit[0];
                            end
                            
                            if (pps_sign_data_hiding_flag[pps_id] != 0 and rc_signHidden != 0) then
                                nb_significant_coeff_flag := nb_significant_coeff_flag - 1;
                            end
                            get_COEFF_SIGN_FLAG(codIRange, codIOffset, fifoContent, fifoIdx, resCoeff, nb_significant_coeff_flag);
                            coeff_sign_flag := resCoeff[0] << (16 - nb_significant_coeff_flag);
                            
                            rc_sumAbsLevel          := 0;
                            rc_cLastRiceParam       := 0;
                            // read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG <<<<
                            
                            subAbsLevelFlag := pps_sign_data_hiding_flag[pps_id] = 1 and rc_signHidden = 1;
                            
                            foreach int m in 0 .. (if m_end > 7 then 7 else m_end end)
                            do
                                // read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL >>>>
                                n := significant_coeff_flag_idx[m];
				                xC := ( rc_xS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 0 ];
                                yC := ( rc_yS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 1 ];
                                transCoeffLevel := coeff_abs_level_greater1_flag[ m ] + 1 + if n = rc_firstGreater1ScanPos then coeff_abs_level_greater2_flag else 0 end;
                                if transCoeffLevel = (
                		            if n = rc_firstGreater1ScanPos then
                			            3
                		            else
                			            2
                		            end
                                ) then
                                    load_fifo();
                                    get_COEFF_ABS_LEVEL(codIRange, codIOffset, fifoContent, fifoIdx, resCoeff, rc_cLastRiceParam);
                                    transCoeffLevel := transCoeffLevel + resCoeff[0];
                                    if transCoeffLevel > (3 << rc_cLastRiceParam ) then
                                    	rc_cLastRiceParam := min(rc_cLastRiceParam + 1, 4);
                                    end
                                end
                                
                                if subAbsLevelFlag then
                                    rc_sumAbsLevel := rc_sumAbsLevel + transCoeffLevel;
                                    if n = rc_firstSigScanPos and ( rc_sumAbsLevel & 1 ) = 1 then
                                        transCoeffLevel := - transCoeffLevel;
                                    end
                                end
                                
                                if (coeff_sign_flag >> 15) = 1 then
                                    transCoeffLevel := - transCoeffLevel;
                                end
                                coeff_sign_flag := coeff_sign_flag << 1;

                                applyDequant(xC, yC);
                                tabTransCoeffLevel[xC + (yC << rc_log2TrafoSize)] := transCoeffLevel;
                                // read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL <<<<
                           end
                           
                           if m_end > 7 then
                                foreach int m in 8 .. m_end
                                do
                                    // read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL >>>>
                                    n := significant_coeff_flag_idx[m];
				                    xC := ( rc_xS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 0 ];
                                    yC := ( rc_yS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 1 ];
                                    load_fifo();
                                    get_COEFF_ABS_LEVEL(codIRange, codIOffset, fifoContent, fifoIdx, resCoeff, rc_cLastRiceParam);
                                    transCoeffLevel := 1 + resCoeff[0];
                                    if transCoeffLevel > (3 << rc_cLastRiceParam ) then
                                    	rc_cLastRiceParam := min(rc_cLastRiceParam + 1, 4);
                                    end

                                    if subAbsLevelFlag then
                                        rc_sumAbsLevel := rc_sumAbsLevel + transCoeffLevel;
                                        if n = rc_firstSigScanPos and ( rc_sumAbsLevel & 1 ) = 1 then
                                            transCoeffLevel := - transCoeffLevel;
                                        end
                                    end
                                
                                    if (coeff_sign_flag >> 15) = 1 then
                                        transCoeffLevel := - transCoeffLevel;
                                    end
                                    coeff_sign_flag := coeff_sign_flag << 1;

                                    applyDequant(xC, yC);
                                    tabTransCoeffLevel[xC + (yC << rc_log2TrafoSize)] := transCoeffLevel;
                                    // read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL <<<<
                                end
                           end
                      end
                 end
                 rc_i := rc_i - 1;
            end
            tabTransCoeffLevel[1<<(rc_log2TrafoSize<<1)] := rc_cBitDepth;
            //println((1<<(rc_log2TrafoSize<<1))+" "+rc_cIdx+" "+rc_cBitDepth);
        end
        
        /**************************************************************************
         * reset_coded_sub_block_flag()
         *************************************************************************/
        @optimize_c(condition="SSE_ENABLE", name="resetCbfFlags")
        procedure reset_coded_sub_block_flag(uint(size= 1) coded_sub_block_flag[8][8], int value, int arraySize)
        begin
            foreach int i in 0 .. 7
            do
                foreach int j in 0 .. 7
                do
                    coded_sub_block_flag[i][j] := 0;
                end
            end
        end
        
        /**************************************************************************
         * set_scale_matrix()
         *************************************************************************/
        @optimize_c(condition="SSE_ENABLE", name="setScaleMatrix")
        procedure set_scale_matrix(uint(size= 8) scale_matrix[64], uint(size= 8) ps_sl[15][4][6][64], int iOffsetOut, int iOffsetIn, int count, uint(size=10) ps_id, uint(size= 8) log2TrafoSizeMinus2, int matrix_id)
        begin
            foreach int i in 0 .. 63 do
	           scale_matrix[i] := ps_sl[ps_id][log2TrafoSizeMinus2][matrix_id][i];
	        end
	    end
        
        /**************************************************************************
         * reset_Coeffs()
         *************************************************************************/
        @optimize_c(condition="SSE_ENABLE", name="memset_16_orcc")
        procedure resetCoeffsX4(int(size=16) tabTransCoeffLevel[4*4+1], int value, int arraySize)
        begin
            foreach int i in 0 .. 4 * 4 - 1
            do
                tabTransCoeffLevel[i] := 0;
            end
        end
        
        @optimize_c(condition="SSE_ENABLE", name="memset_16_orcc")
        procedure resetCoeffsX8(int(size=16) tabTransCoeffLevel[8*8+1], int value, int arraySize)
        begin
            foreach int i in 0 .. 8 * 8 - 1
            do
                tabTransCoeffLevel[i] := 0;
            end
        end
        
        @optimize_c(condition="SSE_ENABLE", name="memset_16_orcc")
        procedure resetCoeffsX16(int(size=16) tabTransCoeffLevel[16*16+1], int value, int arraySize)
        begin
            foreach int i in 0 .. 16 * 16 - 1
            do
                tabTransCoeffLevel[i] := 0;
            end
        end
        
        @optimize_c(condition="SSE_ENABLE", name="memset_16_orcc")
        procedure resetCoeffsX32(int(size=16) tabTransCoeffLevel[32*32+1], int value, int arraySize)
        begin
            foreach int i in 0 .. 32 * 32 - 1
            do
                tabTransCoeffLevel[i] := 0;
            end
        end        
        
        /**************************************************************************
         * read_ResidualCoding_end
         *************************************************************************/
         
        read_ResidualCoding_end.xIT4 : action ==>
                                                Coeff:[tabTransCoeffLevel] repeat 4 * 4 + 1
        guard
                rc_log2TrafoSize = 2
        var
                int(size=16) tabTransCoeffLevel[4 * 4 + 1] 
        do
                if DEBUG_CABAC then
                        println("read_ResidualCoding_end.xIT4");
                end
                
                resetCoeffsX4(tabTransCoeffLevel, 0, 4 * 4);
                read_residualCoding(tabTransCoeffLevel);
                
                // Tokens Count
                NbTokensPerCTU[7] := NbTokensPerCTU[7] + 4 * 4 + 1;
        end

        read_ResidualCoding_end.xIT8 : action ==>
                                                Coeff:[tabTransCoeffLevel] repeat 8 * 8 + 1
        guard
                rc_log2TrafoSize = 3
        var
                int(size=16) tabTransCoeffLevel[8 * 8 + 1] 
        do
                if DEBUG_CABAC then
                        println("read_ResidualCoding_end.xIT8");
                end
                
                resetCoeffsX8(tabTransCoeffLevel, 0, 8 * 8);
                read_residualCoding(tabTransCoeffLevel);
                
                // Tokens Count
                NbTokensPerCTU[7] := NbTokensPerCTU[7] + 8 * 8 + 1;
        end

        read_ResidualCoding_end.xIT16 : action ==>
                                                Coeff:[tabTransCoeffLevel] repeat 16 * 16 + 1
        guard
                rc_log2TrafoSize = 4
        var
                int(size=16) tabTransCoeffLevel[16 * 16 + 1] 
        do
                if DEBUG_CABAC then
                        println("read_ResidualCoding_end.xIT16");
                end
                
                resetCoeffsX16(tabTransCoeffLevel, 0, 16 * 16);
                read_residualCoding(tabTransCoeffLevel);
                
                // Tokens Count
                NbTokensPerCTU[7] := NbTokensPerCTU[7] + 16 * 16 + 1;
        end

        read_ResidualCoding_end.xIT32 : action ==>
                                                Coeff:[tabTransCoeffLevel] repeat 32 * 32 + 1
        guard
                rc_log2TrafoSize = 5
        var
                int(size=16) tabTransCoeffLevel[32 * 32 + 1] 
        do
                if DEBUG_CABAC then
                        println("read_ResidualCoding_end.xIT32");
                end
                
                resetCoeffsX32(tabTransCoeffLevel, 0, 32 * 32);
                read_residualCoding(tabTransCoeffLevel);
                
                // Tokens Count
                NbTokensPerCTU[7] := NbTokensPerCTU[7] + 32 * 32 + 1;                
        end


        /**************************************************************************
         **************************************************************************
         ********        undefined                            *********************
         **************************************************************************
         *************************************************************************/

        
        /**************************************************************************
         **************************************************************************
         ********        schedule                             *********************
         **************************************************************************
         *************************************************************************/
        schedule fsm start_code:
                // search start code
                start_code                                      ( start_code.init                               ) --> read_nal_init;
                start_code                                      ( start_code.done                               ) --> read_nal;
                // read NALU from FIFO
                read_nal_init                                   ( read_nal_init.launch                          ) --> read_nal_init;
                read_nal_init                                   ( read_nal.done                                 ) --> read_Nal_unit_header;
                read_nal                                        ( read_nal.launch                               ) --> read_nal;
                read_nal                                        ( read_nal.done                                 ) --> read_Nal_unit_header;
                // read Nal Unit header
                read_Nal_unit_header                            ( read_nal_unit_header                          ) --> find_header;
                find_header                                     ( look_for.VPS_header                           ) --> read_VPS_Header;
                find_header                                     ( look_for.SEI_header                           ) --> read_SEI_Header;
                find_header                                     ( look_for.SPS_header                           ) --> read_SPS_Header;
                find_header                                     ( look_for.PPS_header                           ) --> read_PPS_Header;
                find_header                                     ( look_for.Slice_header                         ) --> read_SliceHeader;
                // read VPS header
                read_VPS_Header                                 ( read_VPS_Header                               ) --> start_code;
                // read SEI header
                read_SEI_Header                                 ( read_SEI_Header                               ) --> read_SEI_Header;
                read_SEI_Header                                 ( read_SEI_Header_done                          ) --> start_code;
                // read SPS header
                read_SPS_Header                                 ( read_SPS_Header                               ) --> start_code;
                // read PPS header
                read_PPS_Header                                 ( read_PPS_Header                               ) --> start_code;
                read_PPS_Header                                 ( skipCurrentNal.isTrue                         ) --> start_code;
                // read_SliceHeader
                read_SliceHeader                                ( skipCurrentNal.isTrue                         ) --> start_code;
                read_SliceHeader                                ( read_SliceHeader                              ) --> read_SliceHeader;
                read_SliceHeader                                ( weighted_start                                ) --> weightedLuma0;
                read_SliceHeader                                ( read_SliceHeader_done                         ) --> read_SliceData;
                //weightedPred
                weightedLuma0									( weighted_luma_l0								) --> weightedLuma0;
                weightedLuma0									( weighted_end_luma_l0							) --> weightedChroma0;
                weightedChroma0									( weighted_chroma_l0							) --> weightedChroma0;
                weightedChroma0									( weighted_end_chroma_l0 						) --> weightedDeltaLuma0;
                weightedDeltaLuma0								( weighted_deltaLuma_l0_skip_loop				) --> weightedDeltaLuma0;
                weightedDeltaLuma0								( weighted_deltaLuma_l0_skip_loop_done			) --> weightedLuma1;
                weightedDeltaLuma0								( weighted_deltaLuma_l0__skip_all				) --> read_SliceHeader;
                weightedDeltaLuma0								( weighted_deltaLuma_l0_send			        ) --> weightedDeltaChroma0;
                weightedDeltaLuma0								( weighted_deltaLuma_l0_skip					) --> weightedDeltaChroma0;
                weightedDeltaChroma0							( weighted_deltaChroma_l0_skip					) --> weightedDeltaLuma0;
                weightedDeltaChroma0							( weighted_deltaChroma_l0_send					) --> weightedChroma0Offset;
                weightedChroma0Offset							( weighted_deltaChroma_offset_l0_send			) --> weightedDeltaLuma0;
                
                weightedLuma1									( weighted_luma_l1								) --> weightedLuma1;	
                weightedLuma1									( weighted_end_luma_l1							) --> weightedChroma1;
                weightedChroma1									( weighted_chroma_l1							) --> weightedChroma1;
                weightedChroma1									( weighted_chroma_l1_skip						) --> weightedDeltaLuma1;
                weightedChroma1									( weighted_end_chroma_l1						) --> weightedDeltaLuma1;
                weightedDeltaLuma1								( weighted_deltaLuma_l1_skip_loop				) --> weightedDeltaLuma1;
                weightedDeltaLuma1								( weighted_deltaLuma_l1_skip_loop_done			) --> read_SliceHeader;
                weightedDeltaLuma1								( weighted_deltaLuma_l1_send					) --> weightedDeltaChroma1;
                weightedDeltaLuma1								( weighted_deltaLuma_l1_skip					) --> weightedDeltaChroma1;
                weightedDeltaChroma1							( weighted_deltaChroma_l1_skip					) --> weightedDeltaLuma1;
                weightedDeltaChroma1							( weighted_deltaChroma_l1_send					) --> weightedChroma1Offset;
                weightedChroma1Offset							( weighted_deltaChroma_offset_l1_send			) --> weightedDeltaLuma1;
                // read_SliceData
                read_SliceData                                  ( read_SliceData                                ) --> read_SliceData;
                read_SliceData                                  ( read_SliceData_gotoCodingTree            		) --> read_CodingTree;
                read_SliceData                                  ( read_SliceData_end                            ) --> start_code;
                // read_CodingTree
                read_CodingTree                                 ( read_CodingTree                               ) --> read_CodingTree;
                read_CodingTree                                 ( read_CodingTree_gotoSaoParam             		) --> read_SaoParam;
                read_CodingTree                                 ( read_CodingTree_gotoCodingQuadTree			) --> read_CodingQuadTree;
                read_CodingTree                                 ( read_CodingTree_end                           ) --> read_SliceData;
                // read_SaoParam
                read_SaoParam                                   ( read_SaoParam  	                            ) --> read_SaoParam;
                read_SaoParam                                   ( read_SaoParam_endLoop      	                ) --> read_CodingTree;
                // read_CodingQuadTree
                read_CodingQuadTree                             ( read_CodingQuadTree                           ) --> read_CodingQuadTree;
                read_CodingQuadTree                             ( read_CodingQuadTree_gotoCodingUnit        	) --> read_CodingUnit;
                read_CodingQuadTree                             ( read_CodingQuadTree_end       	            ) --> read_CodingTree;
                // read_CodingUint
                read_CodingUnit                                 ( read_CodingUnit                  				) --> read_CodingUnit;
                read_CodingUnit                                 ( read_CodingUnit_noGoto1           			) --> send_IntraPredMode;
                read_CodingUnit                                 ( read_CodingUnit_gotoPCMSample             	) --> read_PCMSample;
                read_CodingUnit                                 ( read_CodingUnit_gotoPredictionUnit			) --> read_PredictionUnit;
                read_CodingUnit                                 ( read_CodingUnit_gotoTransformTree 			) --> read_TransformTree;
                read_CodingUnit                                 ( read_CodingUnit_end                           ) --> read_CodingQuadTree;

                send_IntraPredMode             				    ( sendIntraPredMode                  			) --> read_CodingUnit;
                // read_PredictionUnit
                read_PredictionUnit                             ( read_PredictionUnit                           ) --> read_PredictionUnit;
                read_PredictionUnit                             ( read_PredictionUnit_gotoMVDCoding 			) --> read_MVDCoding;
                read_PredictionUnit                             ( read_PredictionUnit_end                  	 	) --> read_CodingUnit;
                // read_MVDCoding
                read_MVDCoding                                  ( read_MVDCoding                                ) --> read_PredictionUnit;
                // read_PCMSample
                read_PCMSample                              	( read_PCMSample_start                          ) --> read_PCMSampleLuma;//read_PredictionUnit;
                read_PCMSampleLuma								( read_PCMSample_loop_luma						) --> read_PCMSampleLuma;
                read_PCMSampleLuma								( read_PCMSample_end_luma						) --> read_PCMSampleChroma;
				read_PCMSampleChroma							( read_PCMSample_loop_chroma					) --> read_PCMSampleChroma;
                read_PCMSampleChroma							( read_PCMSample_end_chroma						) --> read_CodingUnit;
                // read_TransformTree
                read_TransformTree                              ( read_TransformTree                            ) --> read_TransformTree;
                read_TransformTree                              ( read_TransformTree_gotoTransformUnit			) --> read_TransformUnit;
                read_TransformTree                              ( read_TransformTree_end                    	) --> read_CodingUnit;
                // read_TransformUnit
                read_TransformUnit                              ( read_TransformUnit                            ) --> read_TransformUnit;
                read_TransformUnit                              ( read_TransformUnit_gotoResidualCoding			) --> read_ResidualCoding;
                read_TransformUnit                              ( read_TransformUnit_end                    	) --> read_TransformTree;
                // read_ResidualCoding
                read_ResidualCoding                             ( read_ResidualCoding.start             		) --> read_ResidualCodingEnd;
                
                read_ResidualCodingEnd                          ( read_ResidualCoding_end.xIT4			        ) --> read_TransformUnit;
                read_ResidualCodingEnd                          ( read_ResidualCoding_end.xIT8			        ) --> read_TransformUnit;
                read_ResidualCodingEnd                          ( read_ResidualCoding_end.xIT16			        ) --> read_TransformUnit;
                read_ResidualCodingEnd                          ( read_ResidualCoding_end.xIT32			        ) --> read_TransformUnit;

                find_header                                     ( look_for_other_header             			) --> start_code;
        end

        /**************************************************************************
         * priority
         *************************************************************************/
        priority
                look_for        												> look_for_other_header;
                skipCurrentNal.isTrue                                           > weighted_start;
                skipCurrentNal.isTrue                                           > read_SliceHeader;
                skipCurrentNal.isTrue                                           > read_SliceHeader_done;
                skipCurrentNal.isTrue                                           > read_PPS_Header;
                weighted_end_luma_l0 											> weighted_luma_l0;
                weighted_end_chroma_l0 											> weighted_chroma_l0;
                weighted_deltaLuma_l0_skip_loop_done							> weighted_deltaLuma_l0_skip_loop;
                weighted_end_luma_l1 											> weighted_luma_l1;
                weighted_end_chroma_l1 											> weighted_chroma_l1;
                weighted_deltaLuma_l1_skip_loop_done							> weighted_deltaLuma_l1_skip_loop;
        end
end
