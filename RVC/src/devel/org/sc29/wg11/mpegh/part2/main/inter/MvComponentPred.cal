/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * This actor generates the components needed for the inter prediction
 * (mv and refIdx).
 *
 * 
 * @input ColocInfo : Informations concerning the colocation picture.
 * 
 * @input CuAddr : Address in pixel of all Cu sent.
 * 
 * @input CuMode : Mode (Intra, Inter or Skip mode) of all Cu sent.
 * 
 * @input CuSize : Size of all Cu sent.
 * 
 * @input PartMode : Giving the partitioning mode of the current Cu.
 * 
 * @input Poc : Picture Order Count of the current slice.
 * 
 * @input RefList : Reference Lists (L0 and L1) of the current slice.
 * 
 * @input RpsPoc : Poc present in the Reference Picture Set of the current slice.
 * 
 * @input SliceType : Slice type (I, P or B) of the current slice.
 * 
 * @input SyntaxElem : Syntax elements decoded by the parser.
 * 
 * 
 * @output IsBiPredOrLx : Indicates when the current Cu is using Bi-prediction.
 * 
 * @output IsReadOrNewSlc : Indicates if samples are asked from the current Rps
 *		or if there is a new picture.
 * 
 * @output Mv : movement vectors of the current Cu.
 * 
 * @output PocRef : Poc used for the prediction of the current Cu.
 * 
 * @output PredCuSize : Size of the largest side of the current Cu.
 * 
 * @output RefIdx : Reference indexes of the lists (L0 and L1) of the current
 *		slice.
 *
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */

package devel.org.sc29.wg11.mpegh.part2.main.inter;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor MvComponentPred()
	uint(size=16) CUInfo,
	uint(size=8)  LcuSizeMax,
	uint(size=4)  PartMode,
	uint(size=16) PicSize,
	int (size=16) Poc,
	int (size=16) RefList,
	int (size=16) RpsPoc,
	uint(size=16) SliceAddr,
	uint(size=2)  SliceType,
	int (size=16) SyntaxElem,
	uint(size=16) TilesCoord
		==>
	uint(size=2)  IsBiPredOrLx,
	uint(size=1)  IsReadOrNewSlice,
	int (size=32) Mv,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize,
	uint(size=3)  RefIdx
		:

 	bool DEBUG_CUInfo	    = false;
 	bool DEBUG_PartMode	    = false;
 	bool DEBUG_PicSize	    = false;
 	bool DEBUG_RefList		= false;
 	bool DEBUG_RpsPoc		= false;
 	bool DEBUG_SyntaxElem	= false;
 	bool DEBUG_Mv			= false;
	/* Constants representing all the neighbour required during for predicting
	 * the different components
	 */
	int LEFT_BOTTOM = 0;
	int LEFT = 1;
	int ABOVE_RIGHT = 2;
	int ABOVE = 3;
	int ABOVE_LEFT = 4;
	int RIGHT_BOTTOM = 5;
	int CENTER = 6;

	/* Specification of l0CandIdx and l1CandIdx */
	uint(size=2) combIdxToLXCandIdx[16][2] =
		[[0,1], [1,0], [0,2], [2,0], [1,2], [2,1],
	 [0,3], [3,0], [1,3], [3,1], [2,3], [3,2]];

	uint(size=16) L  = - 1;
	uint(size=16) R  =   1;
	uint(size=16) U  = - PICT_WIDTH_POW_2 / 64;
	uint(size=16) D  =   PICT_WIDTH_POW_2 / 64;
	uint(size=16) UL = - PICT_WIDTH_POW_2 / 64 - 1;
	uint(size=16) UR = - PICT_WIDTH_POW_2 / 64 + 1;
	uint(size=16) DL =   PICT_WIDTH_POW_2 / 64 - 1;
	uint(size=16) DR =   PICT_WIDTH_POW_2 / 64 + 1;

  int(size= 16) neighbLcuAddr[18][18] =
  [
  	[UL, U, U, U, U, U, U, U, U, U, U, U, U, U, U, U, U, UR],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[ L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  R],
  	[DL, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, DR]
  ];


  uint(size= 16) neighbBlkAddr[18][18] =
  [
    [255, 170, 171, 174, 175, 186, 187, 190, 191, 234, 235, 238, 239, 250, 251, 254, 255, 170],
    [ 85,   0,   1,   4,   5,  16,  17,  20,  21,  64,  65,  68,  69,  80,  81,  84,  85,   0],
    [ 87,   2,   3,   6,   7,  18,  19,  22,  23,  66,  67,  70,  71,  82,  83,  86,  87,   2],
    [ 93,   8,   9,  12,  13,  24,  25,  28,  29,  72,  73,  76,  77,  88,  89,  92,  93,   8],
    [ 95,  10,  11,  14,  15,  26,  27,  30,  31,  74,  75,  78,  79,  90,  91,  94,  95,  10],
    [117,  32,  33,  36,  37,  48,  49,  52,  53,  96,  97, 100, 101, 112, 113, 116, 117,  32],
    [119,  34,  35,  38,  39,  50,  51,  54,  55,  98,  99, 102, 103, 114, 115, 118, 119,  34],
    [125,  40,  41,  44,  45,  56,  57,  60,  61, 104, 105, 108, 109, 120, 121, 124, 125,  40],
    [127,  42,  43,  46,  47,  58,  59,  62,  63, 106, 107, 110, 111, 122, 123, 126, 127,  42],
    [213, 128, 129, 132, 133, 144, 145, 148, 149, 192, 193, 196, 197, 208, 209, 212, 213, 128],
    [215, 130, 131, 134, 135, 146, 147, 150, 151, 194, 195, 198, 199, 210, 211, 214, 215, 130],
    [221, 136, 137, 140, 141, 152, 153, 156, 157, 200, 201, 204, 205, 216, 217, 220, 221, 136],
    [223, 138, 139, 142, 143, 154, 155, 158, 159, 202, 203, 206, 207, 218, 219, 222, 223, 138],
    [245, 160, 161, 164, 165, 176, 177, 180, 181, 224, 225, 228, 229, 240, 241, 244, 245, 160],
    [247, 162, 163, 166, 167, 178, 179, 182, 183, 226, 227, 230, 231, 242, 243, 246, 247, 162],
    [253, 168, 169, 172, 173, 184, 185, 188, 189, 232, 233, 236, 237, 248, 249, 252, 253, 168],
    [255, 170, 171, 174, 175, 186, 187, 190, 191, 234, 235, 238, 239, 250, 251, 254, 255, 170],
    [ 85,   0,   1,   4,   5,  16,  17,  20,  21,  64,  65,  68,  69,  80,  81,  84,  85,   0]
  ];
  
  
	uint(size=4)  cuPartMode;
	int           mergeIdx;
	int           mvpIdx[2];
	int           colPoc;
	int           colRefIdx;
	uint(size=1)  colocFromL0;
	uint(size=3)  numPart;
	uint(size=3)  numPartDecoded;
	uint(size=2)  listIdx;
	uint(size=3)  listSize;
	uint(size=3)  sizeIdx;
	int (size=16) maxPoc;
	int           picSizeInPart[2];
	bool          useLN;
	bool          isBSlice;
	int           partAddr[2];
	int           partAddr1stPu[2];
	int           cuAddr[2];
	uint(size=5)  cuMode;
	int           mvPred[5][2][2];
	int(size=16)  mvVal[2][2];
	int           refIdxPred[5][2];
	int(size=16)  pocRef[17];
	uint(size=16) numSlcPerPict[17];
	int(size=16)  pocRefList[17][MAX_NUM_SLICES][2][16];
	uint(size=16) slcAddrRef[17][MAX_NUM_SLICES][2];
	int(size=4)   refIdxRef[17][PICT_WIDTH_POW_2 * PICT_HEIGHT_POW_2 / 4096][256][2];
	int(size=16)  mvRef[17][PICT_WIDTH_POW_2 * PICT_HEIGHT_POW_2 / 4096][256][2][2];
	int           neighbLocation[2];
	int           neighbLocIdx[2];
	int           nPSH;
	int           nPSW;
	bool          isRef[17];
	bool          isStillRef[17];
	int (size=4)  currIdx;
	uint(size=16) slcIdx;
	int (size=16) colSlcIdx;
	bool          predFlag;
	int (size=8)  paralMergeLvl;
	int numCandidate;
	uint sizeOfList;
	uint nbList;
	uint(size=5) minSizeRefListX;
	int(size=16) pocRefListX[2][16];
	uint(size=2) isBiPredOrLx;
	uint(size=7) predCuSize;
	uint(size=7) puSize[2];
	uint(size=7) cuSize[2];
	bool          enTmpMvp;
	uint(size=16) slcAddr[2];
	bool          dependSlc;
	bool          newPict;
	int(size=16)  iLoop;
	uint(size=16) numTiles;
	uint(size=16) tilesBeg[MAX_NUM_TILES][2];
	uint(size=16) tilesEnd[MAX_NUM_TILES][2];
	int (size=16) puTilesBeg[2];
	int (size=16) puTilesEnd[2];
	uint(size=8)  lcuSizeMaxInPart;
	uint(size=8)  maskLcuSzMax;
	uint(size=16) lcuAddr;
	uint(size=16) puAddrInLcu;
	uint(size=16) puAbsAddrInLcu[2];
	uint(size=16) puAbsAddrInLcu1stPu[2];
	
	function isInter(int xN, int yN, int neighbLcuAddr, int neighbBlkAddr) --> bool
	:
		if(xN>=0)then
			if(dependSlc || not (yN < slcAddr[1] || (yN < slcAddr[1] + lcuSizeMaxInPart &&
			   xN < slcAddr[0]))) then
				if(xN >= puTilesBeg[0] && xN < puTilesEnd[0] &&
				   yN >= puTilesBeg[1] && yN < puTilesEnd[1]) then
					refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][0] != -1 ||
					refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][1] != -1
				else
					false
				end
			else
				false
			end
		else
			false
		end
	end

	function getIsAvailable() --> bool
	var
		int neighbLcuAddr = neighbLocIdx[0],
		int neighbBlkAddr = neighbLocIdx[1]
	:
		if(neighbLcuAddr >= 0) then
			refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][0] != -1 ||
			refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][1] != -1
		else
			false
		end
	end

	function checkSameComp(int orig[2], int neighb[2]) --> bool
	var
		int lcuAddrOrig = orig[0],
		int blkAddrOrig = orig[1],
		int lcuAddrNeighb = neighb[0],
		int blkAddrNeighb = neighb[1],
		int refIdxCurrCu[2] = [refIdxRef[currIdx][lcuAddrOrig]
			[blkAddrOrig][i]:for int i in 0 .. 1],
		int refIdxNeighb[2] = [refIdxRef[currIdx][lcuAddrNeighb]
			[blkAddrNeighb][i]: for int i in 0 .. 1],
		int mvCurrCu[2][2] = [[mvRef[currIdx][lcuAddrOrig]
			[blkAddrOrig][i][j]:for int j in 0 .. 1]:for int i in 0 .. 1],
		int mvNeighb[2][2] = [[mvRef[currIdx][lcuAddrNeighb][blkAddrNeighb]
			[i][j]: for int j in 0 .. 1]:for int i in 0 .. 1]
	:
		not(refIdxCurrCu[0] = refIdxNeighb[0] && refIdxCurrCu[1] =
			refIdxNeighb[1]) or
		not ((refIdxCurrCu[0] = -1 ||(mvCurrCu[0][0] =
			mvNeighb[0][0] && mvCurrCu[0][1] = mvNeighb[0][1])) &&
			(refIdxCurrCu[1] = -1 || (mvCurrCu[1][0] =
				mvNeighb[1][0] && mvCurrCu[1][1] = mvNeighb[1][1])))
	end

	/* Indicates if the Cu Orig and Neighb located in the current picture have the same reference indexes and movement vectors. */
	function hasNotSameMvComp(int orig[2], int neighb[2]) --> bool
	:
		if(neighb[0] >= 0) then

			if(orig[0] < 0) then

				false
			else
				checkSameComp(orig, neighb)
			end
		else
			true
		end
	end

	procedure searchColSlcAddr(int(size=32) partAddr[2])
	var
		int(size=32) pocSlcAddr[2]
	begin
		colSlcIdx := -1;
		foreach int i in 0 .. numSlcPerPict[colRefIdx] - 1
		do
			pocSlcAddr := [slcAddrRef[colRefIdx][i][j]: for int j in 0 .. 1];
			if(partAddr[1] >= pocSlcAddr[1] + lcuSizeMaxInPart ||
					(partAddr[1] >= pocSlcAddr[1] && partAddr[0] >= pocSlcAddr[0])) then
				if(colSlcIdx != -1) then
					if(pocSlcAddr[1] > slcAddrRef[colRefIdx][colSlcIdx][1] ||
					   pocSlcAddr[1] = slcAddrRef[colRefIdx][colSlcIdx][1] &&
					   pocSlcAddr[0] > slcAddrRef[colRefIdx][colSlcIdx][0]) then
						colSlcIdx := i;
					end
				else
					colSlcIdx := i;
				end
			end
		end
	end

	/** Saving information for the next predictions **/
	//@optimize_c(condition="SSE_ENABLE", name="saveRefIdx_orcc")
	procedure saveRefIdx(int refIdxToSave[2], 
		uint(size=8) cuSize[2], uint(size=4) cuPartMode, uint(size=3) numPartDecoded,
		int(size=8)  refIdxRef[17][PICT_WIDTH_POW_2 * PICT_HEIGHT_POW_2 / 4096][256][2],
		int(size=4) currIdx, uint(size=16) lcuAddr, uint(size=16) puAddrInLcu)
	var
		uint(size=16) nbBlkInPu
	begin
		nbBlkInPu := cuSize[0] * cuSize[1] / 16;
		if(cuPartMode != PART_2NxnD && cuPartMode != PART_2NxnU && cuPartMode != PART_nLx2N && cuPartMode != PART_nRx2N && cuPartMode != PART_Nx2N) then
			foreach int i in 0 .. nbBlkInPu - 1
			do
				refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
					[refIdxToSave[j]:for int j in 0 .. 1];
			end
		else if(cuPartMode = PART_Nx2N) then
			nbBlkInPu := (cuSize[0] * cuSize[1] / 16) / 2;
			foreach int i in 0 .. nbBlkInPu - 1
			do
				refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
					[refIdxToSave[j]:for int j in 0 .. 1];
				refIdxRef[currIdx][lcuAddr][2 * nbBlkInPu + puAddrInLcu + i] :=
					[refIdxToSave[j]:for int j in 0 .. 1];
			end
		else if(cuPartMode = PART_2NxnD) then
			if(numPartDecoded = 1) then
				nbBlkInPu := (predCuSize * predCuSize / 16)/8;
				foreach int i in 0 .. 5 * nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]:for int j in 0 .. 1];
				end
				foreach int i in 6 * nbBlkInPu .. 7 * nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]:for int j in 0 .. 1];
				end
			else
				foreach int i in 0 .. nbBlkInPu/2 - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
				foreach int i in nbBlkInPu .. nbBlkInPu + nbBlkInPu/2 - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
			end
		else if(cuPartMode = PART_2NxnU) then
			if(numPartDecoded = 1) then
				foreach int i in 0 .. nbBlkInPu/2 - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
			else
				nbBlkInPu := (predCuSize * predCuSize / 16)/8;
				foreach int i in 0 .. nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
				foreach int i in 2 * nbBlkInPu .. 7 * nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
			end
		else if(cuPartMode = PART_nRx2N) then
			nbBlkInPu := (predCuSize * predCuSize / 16)/16;
			if(numPartDecoded = 1) then
				foreach int i in 0 .. 5 * nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
				foreach int i in 6 * nbBlkInPu .. 7 * nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
			else
				foreach int i in 0 .. nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][0 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][2 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][10 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
			end
		else
			nbBlkInPu := (predCuSize * predCuSize / 16)/16;
			if(numPartDecoded = 1) then
				foreach int i in 0 .. nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][2 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][10 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
			else
				foreach int i in 0 .. nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
				foreach int i in 2 * nbBlkInPu .. 7 * nbBlkInPu - 1
				do
					refIdxRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
					refIdxRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[refIdxToSave[j]: for int j in 0 .. 1];
				end
			end
		end end end end end
	end

	//@optimize_c(condition="SSE_ENABLE", name="saveMvComponent_orcc")
	procedure saveMvComponent(int(size=16) mvToSave[2][2], 
		uint(size=8) cuSize[2], uint(size=4) cuPartMode, uint(size=3) numPartDecoded,
		int(size=16)  mvRef[17][PICT_WIDTH_POW_2 * PICT_HEIGHT_POW_2 / 4096][256][2][2],
		int(size=4) currIdx, uint(size=16) lcuAddr, uint(size=16) puAddrInLcu)
	var
		uint(size=16) nbBlkInPu
	begin
		nbBlkInPu := cuSize[0] * cuSize[1] / 16;
		if(cuPartMode != PART_2NxnD && cuPartMode != PART_2NxnU && cuPartMode != PART_nLx2N && cuPartMode != PART_nRx2N && cuPartMode != PART_Nx2N) then
			foreach int i in 0 .. nbBlkInPu - 1
			do
				mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
					[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
			end
		else if(cuPartMode = PART_Nx2N) then
			nbBlkInPu := (cuSize[0] * cuSize[1] / 16) / 2;
			foreach int i in 0 .. nbBlkInPu - 1
			do
				mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
					[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				mvRef[currIdx][lcuAddr][2 * nbBlkInPu + puAddrInLcu + i] :=
					[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
			end
		else if(cuPartMode = PART_2NxnD) then
			if(numPartDecoded = 1) then
				nbBlkInPu := (predCuSize * predCuSize / 16)/8;
				foreach int i in 0 .. 5 * nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
				foreach int i in 6 * nbBlkInPu .. 7 * nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
			else
				foreach int i in 0 .. nbBlkInPu/2 - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
				foreach int i in nbBlkInPu .. nbBlkInPu + nbBlkInPu/2 - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
			end
		else if(cuPartMode = PART_2NxnU) then
			if(numPartDecoded = 1) then
				foreach int i in 0 .. nbBlkInPu/2 - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
			else
				nbBlkInPu := (predCuSize * predCuSize / 16)/8;
				foreach int i in 0 .. nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
				foreach int i in 2 * nbBlkInPu .. 7 * nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
			end
		else if(cuPartMode = PART_nRx2N) then
			nbBlkInPu := (predCuSize * predCuSize / 16)/16;
			if(numPartDecoded = 1) then
				foreach int i in 0 .. 5 * nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
				foreach int i in 6 * nbBlkInPu .. 7 * nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
			else
				foreach int i in 0 .. nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][0 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][2 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][10 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
			end
		else
			nbBlkInPu := (predCuSize * predCuSize / 16)/16;
			if(numPartDecoded = 1) then
				foreach int i in 0 .. nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][2 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][10 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
			else
				foreach int i in 0 .. nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
				foreach int i in 2 * nbBlkInPu .. 7 * nbBlkInPu - 1
				do
					mvRef[currIdx][lcuAddr][puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
					mvRef[currIdx][lcuAddr][8 * nbBlkInPu + puAddrInLcu + i] :=
						[[mvToSave[k][j]:for int j in 0 .. 1]:for int k in 0 .. 1];
				end
			end
		end end end end end
	end

	/* Computes the location of the neighbour. The result will be in the vector
	 * neighbLocation
	 */
	procedure getNeighbAddr(int location, bool depSlcOrCol, bool isColNeighb)
	var
		int bitMod = 3,
		int isNotInPict
	begin
		if(location = LEFT) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] + nPSH - 1;
			neighbLocIdx[0] := lcuAddr + neighbLcuAddr[puAbsAddrInLcu[1] + 1 + nPSH - 1][puAbsAddrInLcu[0] + 1 - 1];
			neighbLocIdx[1] := neighbBlkAddr[puAbsAddrInLcu[1] + 1 + nPSH - 1][puAbsAddrInLcu[0] + 1 - 1];
			
		else if(location = ABOVE) then
			neighbLocation[0] := partAddr[0] + nPSW - 1;
			neighbLocation[1] := partAddr[1] - 1;
			neighbLocIdx[0] := lcuAddr + neighbLcuAddr[puAbsAddrInLcu[1] + 1 - 1][puAbsAddrInLcu[0] + 1 + nPSW - 1];
			neighbLocIdx[1] := neighbBlkAddr[puAbsAddrInLcu[1] + 1 - 1][puAbsAddrInLcu[0] + 1 + nPSW - 1];
		else if(location = ABOVE_RIGHT) then
			neighbLocation[0] := partAddr[0] + nPSW;
			neighbLocation[1] := partAddr[1] - 1;
			neighbLocIdx[0] := lcuAddr + neighbLcuAddr[puAbsAddrInLcu[1] + 1 - 1][puAbsAddrInLcu[0] + 1 + nPSW];
			neighbLocIdx[1] := neighbBlkAddr[puAbsAddrInLcu[1] + 1 - 1][puAbsAddrInLcu[0] + 1 + nPSW];
		else if(location = LEFT_BOTTOM) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] + nPSH;
			neighbLocIdx[0] := lcuAddr + neighbLcuAddr[puAbsAddrInLcu[1] + 1 + nPSH][puAbsAddrInLcu[0] + 1 - 1];
			neighbLocIdx[1] := neighbBlkAddr[puAbsAddrInLcu[1] + 1 + nPSH][puAbsAddrInLcu[0] + 1 - 1];
		else if(location = ABOVE_LEFT) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] - 1;
			neighbLocIdx[0] := lcuAddr + neighbLcuAddr[puAbsAddrInLcu[1] + 1 - 1][puAbsAddrInLcu[0] + 1 - 1];
			neighbLocIdx[1] := neighbBlkAddr[puAbsAddrInLcu[1] + 1 - 1][puAbsAddrInLcu[0] + 1 - 1];
		else if(location = RIGHT_BOTTOM) then
			neighbLocation[0] := partAddr[0] + nPSW;
			neighbLocation[1] := partAddr[1] + nPSH;
			if(neighbLocation[0] >= picSizeInPart[0] ||
				neighbLocation[1] >= picSizeInPart[1]) then
				neighbLocation[0] := -1;
				neighbLocIdx[0] := -1;
			else
				if((neighbLocation[1] & maskLcuSzMax) = 0 ||
					(neighbLocation[1]>>4 != partAddr[1]>>4)) then
					neighbLocation[0] := -1;
					neighbLocIdx[0] := -1;
				end
				neighbLocation[0] := neighbLocation[0] & ~bitMod;
				neighbLocation[1] := neighbLocation[1] & ~bitMod;
				neighbLocIdx[0] := lcuAddr + neighbLcuAddr[((puAbsAddrInLcu[1] + nPSH) & ~bitMod) + 1][((puAbsAddrInLcu[0] + nPSW) & ~bitMod) + 1];
				neighbLocIdx[1] := neighbBlkAddr[((puAbsAddrInLcu[1] + nPSH) & ~bitMod) + 1][((puAbsAddrInLcu[0] + nPSW) & ~bitMod) + 1];
			end
		else
			neighbLocation[0] := partAddr[0] + nPSW/2;
			neighbLocation[1] := partAddr[1] + nPSH/2;
			if(neighbLocation[1] >> 4 != partAddr[1] >> 4) then
				neighbLocation[1] := -1;
			end
			neighbLocation[0] := neighbLocation[0] & ~bitMod;
			neighbLocation[1] := neighbLocation[1] & ~bitMod;
			neighbLocIdx[0] := lcuAddr + neighbLcuAddr[((puAbsAddrInLcu[1] + nPSH/2)& ~bitMod) + 1][((puAbsAddrInLcu[0] + nPSW/2)& ~bitMod) + 1];
			neighbLocIdx[1] := neighbBlkAddr[((puAbsAddrInLcu[1] + nPSH/2)& ~bitMod) + 1][((puAbsAddrInLcu[0] + nPSW/2)& ~bitMod) + 1];
		end end end end end end

		/* if the neighbour is not in the picture then neighbLocation[0] := -1; */
		isNotInPict := (neighbLocation[0] >> 31) << 31;
		isNotInPict := isNotInPict | ((picSizeInPart[0] - neighbLocation[0] - 1) >> 31) << 31;
		isNotInPict := isNotInPict | (neighbLocation[1] >> 31) << 31;
		isNotInPict := isNotInPict | ((picSizeInPart[1] - neighbLocation[1] - 1) >> 31) << 31;
		neighbLocation[0] := neighbLocation[0] | isNotInPict;
		neighbLocIdx[0] := neighbLocIdx[0] | isNotInPict;
		

		if(not depSlcOrCol && (neighbLocation[1] < slcAddr[1] ||
			(neighbLocation[1]< slcAddr[1] + lcuSizeMaxInPart &&
				neighbLocation[0] < slcAddr[0]))) then
			neighbLocation[0] := -1;
			neighbLocIdx[0] := -1;
		end
		if(not isColNeighb and (neighbLocation[0] < puTilesBeg[0] or
			neighbLocation[0] >= puTilesEnd[0] or neighbLocation[1] < puTilesBeg[1] or
			neighbLocation[1] >= puTilesEnd[1])) then
			neighbLocation[0] := -1;
			neighbLocIdx[0] := -1;
		end
	end

	/* method used for getting the neighbour. This method is used when mergeIdx
	 * value is absent (in this decoder it corresponds to mergeidx = -1)
	 */
	procedure getNonMergedNeighbourMv(uint listX)
	var
		int neighbLcuAddr = neighbLocIdx[0],
		int neighbBlkAddr = neighbLocIdx[1],
		bool sameComponent := false,
		int refIdx1,
		int refIdx2,
		int currMv[2],
		int i := 0
	begin
		predFlag := false;
		if(neighbLcuAddr >= 0) then
			if(refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][listX] =
				refIdxRef[currIdx][lcuAddr][puAddrInLcu][listX]) then
				getNeighbourMvNonMergedNonScaled(listX);
			else
				refIdx1 := refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][listX^1];
				refIdx2 := refIdxRef[currIdx][lcuAddr][puAddrInLcu][listX];
				if(refIdx1!=-1 && refIdx2 != -1) then
					if(pocRefListX[listX^1][refIdx1] =
						pocRefListX[listX][refIdx2]) then
						predFlag := true;
						mvPred[numCandidate][listX] := [mvRef[currIdx][neighbLcuAddr][neighbBlkAddr]
							[listX^1][j]:for int j in 0 .. 1];
						numCandidate := numCandidate + 1;
				end end
			end
			if(predFlag) then
				currMv := [mvPred[numCandidate-1][listX][j]:
					for int j in 0 .. 1];
				while(i<numCandidate-1 && not sameComponent)
				do
					if(mvPred[i][listX][0] = currMv[0] &&
						mvPred[i][listX][1] = currMv[1]) then
						numCandidate := numCandidate - 1;
						sameComponent := true;
					end
					i:=i+1;
				end
			end
		end
	end

	procedure getNeighbourMv_MergeIdx_isNotEqToMin1()
	var
		int xN = neighbLocation[0],
		int yN = neighbLocation[1],
		int neighbLcuAddr = neighbLocIdx[0],
		int neighbBlkAddr = neighbLocIdx[1]
	begin
		predFlag := false;
		if((partAddr[0] >> paralMergeLvl) != (xN >> paralMergeLvl) ||
		                  (partAddr[1] >> paralMergeLvl) != (yN >> paralMergeLvl)) then
			if(neighbLcuAddr >= 0) then
				predFlag := refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][0] != -1 ||
					refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][1] != -1 ;
				if(predFlag) then
					mvPred[numCandidate] :=
						[[mvRef[currIdx][neighbLcuAddr][neighbBlkAddr][list][i]:
							for int i in 0 .. 1]:for int list in 0 .. 1];
					refIdxPred[numCandidate] := [refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr]
						[list]:for int list in 0 .. 1];
					numCandidate := numCandidate + 1;
				end
			end
		end
	end

	procedure getNeighbourMvNonMergedNonScaled(uint listX)
	var
		int neighbLcuAddr = neighbLocIdx[0],
		int neighbBlkAddr = neighbLocIdx[1],
		bool sameComponent := false,
		uint listAvail
	begin
		predFlag := false;
		if(neighbLcuAddr >= 0) then
			predFlag := refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][0] != -1 ||
				refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][1] != -1 ;
			if(predFlag) then
				foreach int i in 0 .. numCandidate-1
				do
					sameComponent := sameComponent ||
						(mvPred[i][0][0] = mvRef[currIdx][neighbLcuAddr][neighbBlkAddr][0][0] &&
						 mvPred[i][0][1] = mvRef[currIdx][neighbLcuAddr][neighbBlkAddr][0][1] &&
						 mvPred[i][1][0] = mvRef[currIdx][neighbLcuAddr][neighbBlkAddr][1][0] &&
						 mvPred[i][1][1] = mvRef[currIdx][neighbLcuAddr][neighbBlkAddr][1][1]);
				end
				if(not sameComponent) then
					listAvail :=
						if(refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][listX] != -1) then
							listX
						else
							listX^1
						end;
					mvPred[numCandidate][listX] := [mvRef[currIdx][neighbLcuAddr][neighbBlkAddr]
						[listAvail][i]:for int i in 0 .. 1];
					refIdxPred[numCandidate][listX] := refIdxRef[currIdx]
						[neighbLcuAddr][neighbBlkAddr][listAvail];
					numCandidate := numCandidate + 1;
				end
			end
		end
	end

	procedure getNeighbourMvNonMergedScaled(uint listX)
	var
		int neighbLcuAddr = neighbLocIdx[0],
		int neighbBlkAddr = neighbLocIdx[1],
		uint listAvail
	begin
		predFlag := false;
		if(neighbLcuAddr >= 0) then
			predFlag := refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][0] != -1 ||
				refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][1] != -1 ;
			if(predFlag) then
				listAvail :=
					if(refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][listX] != -1) then
						listX
					else
						listX^1
					end;
				mvPred[numCandidate][listX] := [mvRef[currIdx][neighbLcuAddr][neighbBlkAddr]
					[listAvail][i]:for int i in 0 .. 1];
				refIdxPred[numCandidate][listX] := refIdxRef[currIdx]
					[neighbLcuAddr][neighbBlkAddr][listAvail];
				numCandidate := numCandidate + 1;
			end
		end
	end

	procedure getNonMergedScaledMv(uint listX)
	var
		int neighbLcuAddr := neighbLocIdx[0],
		int neighbBlkAddr := neighbLocIdx[1],
		int listAvail,
		int currMv[2],
		int refIdxRefCurrPic,
		int i := 0,
		bool sameComponent:= false,
		int mvParam[2]
	begin
		predFlag := false;
		if(neighbLcuAddr >= 0) then
			if(refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][0] != -1 ||
				refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][1] != -1) then
				listAvail :=
					if(refIdxRef[currIdx][neighbLcuAddr][neighbBlkAddr][listX] != -1) then
						listX
					else
						listX^1
					end;
				getNeighbourMvNonMergedScaled(listX);
				refIdxRefCurrPic := refIdxRef[currIdx][lcuAddr][puAddrInLcu]
					[listX];
				if(refIdxRefCurrPic = -1) then
					refIdxRefCurrPic := 0;
				end
				mvParam := [mvPred[numCandidate-1][listX][j]:for int j in 0 .. 1];
				mvScaling(mvParam, refIdxRefCurrPic, listAvail, listX, currIdx,
					pocRefListX, false);
				mvPred[numCandidate-1][listX] :=
					[mvParam[j]:for int j in 0 .. 1];
				
				currMv :=
					[mvPred[numCandidate-1][listX][j]: for int j in 0 .. 1];
				while(i<numCandidate-1 && not sameComponent)
				do
					if(mvPred[i][listX][0] = currMv[0] &&
						mvPred[i][listX][1] = currMv[1]) then
						numCandidate := numCandidate - 1;
						sameComponent := true;
					end
					i:=i+1;
				end
			end
		end
	end

	/* Scaling the movement vector acording to the Cu from the neighbour part
	 * and the current Cu
	 */
	procedure mvScaling(int mv[2], int refIdxRefCurrPic, uint listAvail,
		uint listX, uint pictIdx, int(size=16) refList[2][16], bool isColPict)
	var
		int neighbLcuAddr = neighbLocIdx[0],
		int neighbBlkAddr = neighbLocIdx[1],
		int idxColRef = refIdxRef[pictIdx][neighbLcuAddr][neighbBlkAddr][listAvail],
		int pocRefCol = if(not isColPict) then refList[listAvail][idxColRef] else
			pocRefList[colRefIdx][colSlcIdx][listAvail][idxColRef] end,
		int pocRefCurrPic = pocRefList[currIdx][slcIdx][listX][refIdxRefCurrPic],
		int deltaColPic,
		int deltaCurrPic,
		int td,
		int tb,
		int tx,
		int distScaleFactor,
		int newMv
	begin
		deltaColPic := pocRef[pictIdx] - pocRefCol;
		deltaCurrPic := pocRef[currIdx] - pocRefCurrPic;
		if(deltaColPic != deltaCurrPic) then
			td := clip_i32(deltaColPic, -127, 128);
			tb := clip_i32(deltaCurrPic, -127, 128);
			tx := (16384 + abs(td/2))/td;
			distScaleFactor := clip_i32((tb*tx+32)>>6, -4096, 4095);
			foreach int i in 0 .. 1
			do
				newMv := distScaleFactor*mv[i];
				if(newMv>= 0) then
					newMv := (newMv + 127)>>8;
				else
					newMv := -((-newMv + 127)>>8);
				end
				mv[i] := newMv;
			end
		end
	end

	/* Derivation process for temporal motion vector prediction part1 */
	procedure getColCandidate(bool isMerged, uint listX)
	begin
		if(isMerged) then
			listX := 0;
		end
		getNeighbAddr(RIGHT_BOTTOM, true, true);
		getColNeighbourMv(isMerged, listX);
		if(not predFlag) then
			getNeighbAddr(CENTER, true, true);
			getColNeighbourMv(isMerged, listX);
		end
	end

	/* Derivation process for temporal motion vector prediction part2 */
	procedure getColNeighbourMv(bool isMerged, uint listX)
	var
		int neighbLcuAddr = neighbLocIdx[0],
		int neighbBlkAddr = neighbLocIdx[1],
		int mv[2][2],
		int refIdxRefCurrPic,
		int refIdxRefCurrPicL1,
		int listAvail[2],
		int mvScal[2]
	begin
		predFlag := false;
		if(neighbLcuAddr >= 0) then
			predFlag := refIdxRef[colRefIdx][neighbLcuAddr][neighbBlkAddr][0] != -1 ||
				refIdxRef[colRefIdx][neighbLcuAddr][neighbBlkAddr][1] != -1;
			if(predFlag) then
				mv := [[mvRef[colRefIdx][neighbLcuAddr][neighbBlkAddr][i][j]:for int j in 0 .. 1]:
					for int i in 0 .. 1];
				if(isMerged) then
					refIdxRefCurrPic := 0;
					refIdxRefCurrPicL1 := 0;
					if(refIdxRef[colRefIdx][neighbLcuAddr][neighbBlkAddr][1] = -1) then
						mv[1][0] := mv[0][0];
						mv[1][1] := mv[0][1];
						listAvail := [0, 0];
					else if(refIdxRef[colRefIdx][neighbLcuAddr][neighbBlkAddr][0] = -1) then
						mv[0][0] := mv[1][0];
						mv[0][1] := mv[1][1];
						listAvail := [1, 1];
					else
						if(useLN) then
							if(colocFromL0 = 0)then
								mv[1][0] := mv[0][0];
								mv[1][1] := mv[0][1];
								listAvail := [0, 0];
							else
								mv[0][0] := mv[1][0];
								mv[0][1] := mv[1][1];
								listAvail := [1, 1];
							end
						else
							listAvail := [0, 1];
						end
					end end
					searchColSlcAddr(neighbLocation);
					mvScal := [mv[0][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPic,   listAvail[0], 0, 
						colRefIdx, pocRefListX, true);
					mv[0] := [mvScal[i]:for int i in 0 .. 1];
					mvScal := [mv[1][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPicL1, listAvail[1], 1,
						colRefIdx, pocRefListX, true);
					mv[1] := [mvScal[i]:for int i in 0 .. 1];
					refIdxPred[numCandidate][0] := refIdxRefCurrPic;
					refIdxPred[numCandidate][1] := refIdxRefCurrPicL1;
					mvPred[numCandidate] := [[mv[i][j]:for int j in 0 .. 1]:
						for int i in 0 .. 1];
				else
					listAvail[0] :=
						if(refIdxRef[colRefIdx][neighbLcuAddr][neighbBlkAddr][listX] != -1) then
							listX
						else
							listX^1
						end;
					if(refIdxRef[colRefIdx][neighbLcuAddr][neighbBlkAddr][0] != -1 &&
						refIdxRef[colRefIdx][neighbLcuAddr][neighbBlkAddr][1] != -1 && useLN) then
						listAvail[0] := colocFromL0;
					end
					refIdxRefCurrPic :=
						if(isInter(partAddr[0],partAddr[1], lcuAddr, puAddrInLcu)) then
							refIdxRef[currIdx][lcuAddr][puAddrInLcu][listX]
						else
							0
						end;
					if(refIdxRefCurrPic = -1) then
						refIdxRefCurrPic := 0;
					end
					searchColSlcAddr(neighbLocation);
					mvScal := [mv[listAvail[0]][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPic, listAvail[0], listX,
						colRefIdx, pocRefListX, true);
					mv[listAvail[0]] := [mvScal[i]:for int i in 0 .. 1];
					mvPred[numCandidate][listX] := [mv[listAvail[0]][i]:
						for int i in 0 .. 1];
					refIdxPred[numCandidate][listX] := refIdxRefCurrPic;
				end
				numCandidate := numCandidate + 1;
			end
		end
	end

	/* Derivation process for combined bi-predictive merging candidates */
	procedure biPredMergeCand(uint maxNumCandidate)
	var
		int combIdxMax = numCandidate * (numCandidate-1),
		int combIdx := 0,
		uint l0CandIdx,
		uint l1CandIdx,
		int  refIdxL0Cand,
		int  refIdxL1Cand,
		uint mvL0Cand[2],
		uint mvL1Cand[2]
	begin
		while(combIdx != combIdxMax && numCandidate != maxNumCandidate)
		do
			l0CandIdx := combIdxToLXCandIdx[combIdx][0];	
			l1CandIdx := combIdxToLXCandIdx[combIdx][1];
			refIdxL0Cand := refIdxPred[l0CandIdx][0];
			refIdxL1Cand := refIdxPred[l1CandIdx][1];
			mvL0Cand := [mvPred[l0CandIdx][0][i]:for int i in 0 .. 1];
			mvL1Cand := [mvPred[l1CandIdx][1][i]:for int i in 0 .. 1];
			if(refIdxL0Cand!=-1 && refIdxL1Cand!= -1) then
				if(pocRefListX[0][refIdxL0Cand] !=
					pocRefListX[1][refIdxL1Cand] ||
					mvL0Cand[0] != mvL1Cand[0] || mvL0Cand[1] != mvL1Cand[1])
					then
					mvPred[numCandidate][0] := [mvL0Cand[i]:
						for int i in 0 .. 1];
					mvPred[numCandidate][1] := [mvL1Cand[i]:
						for int i in 0 .. 1];
					refIdxPred[numCandidate][0] := refIdxL0Cand;
					refIdxPred[numCandidate][1] := refIdxL1Cand;
					numCandidate := numCandidate + 1;
				end
			end
			combIdx := combIdx + 1;
		end
	end

	/* Getting information from new Slice, finding some place for the refence
	 * tables, and initializing the reference tables
	 */
	isNewPicOrSlice: action PartMode:[partMode], SliceAddr:[sliceAddress] repeat 2,
		SyntaxElem:[paralMergeLevel, tmvpFlag] ==>
	guard
		partMode = PART_MODE_SLICE_DEP || partMode = PART_MODE_SLICE_INDEP ||
		partMode = PART_MODE_PICT
	do
		slcAddr   := [sliceAddress[0]/4, sliceAddress[1]/4];
		dependSlc := partMode = PART_MODE_SLICE_DEP;
		newPict   := partMode = PART_MODE_PICT;
		enTmpMvp  := tmvpFlag != 0;
		paralMergeLvl := paralMergeLevel - 2;
		if DEBUG_PartMode then
			println("partMode = "+partMode);
		end
		nbList := 0;
		if(partMode = PART_MODE_PICT) then
			slcIdx := 0;
		elsif(partMode = PART_MODE_SLICE_INDEP) then
			slcIdx := slcIdx + 1;
			slcAddrRef[currIdx][slcIdx] := [slcAddr[i]: for int i in 0 .. 1];
			numSlcPerPict[currIdx] := numSlcPerPict[currIdx] + 1;
		end
	end

	getTilesCoord.launch: action TilesCoord:[tilesCoord] repeat 4 ==>
	guard
		iLoop < numTiles
	do
		tilesBeg[iLoop] := [tilesCoord[0]/4, tilesCoord[1]/4];
		tilesEnd[iLoop] := [tilesCoord[2]/4, tilesCoord[3]/4];
		iLoop := iLoop + 1;
	end

	getTilesCoord.done: action ==>
	guard
		iLoop = numTiles
	end

	checkDepSlc.isTrue: action ==>
	guard
		dependSlc
	end

	checkDepSlc.isFalse: action SyntaxElem:[colFromLX, colRefIdxVal],
		LcuSizeMax:[log2_lcuSz], PicSize:[picSize] repeat 2, Poc:[poc],
		SliceType:[sliceType], TilesCoord:[valNumTiles] ==> IsReadOrNewSlice:[0]
	guard
		not dependSlc
	var
		uint(size=16) lcuIdxOff
	do
		isBSlice := sliceType = B_SLICE;
		listIdx := 0;
		maxPoc := MIN_INT16;
		foreach int i in 0 .. 16
		do
			isStillRef[i] := false;
		end

		if(newPict) then
			currIdx := -1;
			foreach int i in 0 .. 16
			do
				if((currIdx = -1 and not isRef[i]) ||
					(isRef[i] and pocRef[i]=poc)) then
					currIdx  := i;
				end
			end
			numSlcPerPict[currIdx] := 1;
			slcAddrRef[currIdx][0] := [slcAddr[i]: for int i in 0 .. 1];

			lcuIdxOff := 0;
			foreach int y in 0 .. (picSize[1] + 63) / 64 - 1
			do
				foreach int x in 0 .. (picSize[0] + 63) / 64 - 1
				do
					foreach int j in 0 .. 255
					do
						refIdxRef[currIdx][lcuIdxOff + x][j] := [-1, -1];
					end
				end
				lcuIdxOff := lcuIdxOff + PICT_WIDTH_POW_2 / 64;
			end
		end

		isRef[currIdx] := true;
		pocRef[currIdx] := poc;
		colRefIdx := colRefIdxVal & 15;
		if(isBSlice)then
			colFromLX := 1-colFromLX;
		else
			colFromLX := 0;
		end
		colocFromL0 := colFromLX^1;
		if DEBUG_PicSize then
			println("picSize = "+picSize[0] + " " + picSize[1]);
		end
		picSizeInPart[0] := picSize[0]/4;
		picSizeInPart[1] := picSize[1]/4;

		numTiles := valNumTiles;
		iLoop := 0;

		lcuSizeMaxInPart := (1 << log2_lcuSz) / 4;
		maskLcuSzMax     := lcuSizeMaxInPart - 1;
	end

	getPartMode: action PartMode:[partMode] ==>
	guard
		partMode != PART_MODE_SLICE_DEP && partMode != PART_MODE_SLICE_INDEP &&
		partMode != PART_MODE_PICT
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
		cuPartMode := partMode;
		if DEBUG_PartMode then
			println("partMode = "+partMode);
		end
	end

	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		predCuSize := max(cuInfo[3], cuInfo[4]);
		puSize := [cuInfo[3], cuInfo[4]];
		cuSize := [cuInfo[3], cuInfo[4]];
		partAddr[0] := cuInfo[1]/4;
		partAddr[1] := cuInfo[2]/4;
		cuAddr := [cuInfo[1], cuInfo[2]];
		nPSW := cuInfo[3]/4;
		nPSH := cuInfo[4]/4;

		lcuAddr := (cuInfo[1] / 64) + (cuInfo[2] / 64) * (PICT_WIDTH_POW_2 / 64);
		puAbsAddrInLcu := [(cuInfo[1] & 63) / 4, (cuInfo[2] & 63) / 4];
		puAddrInLcu := absCoordInBlkToZScan(puAbsAddrInLcu);
		if(numPartDecoded = 0) then
			partAddr1stPu := partAddr;
			puAbsAddrInLcu1stPu := puAbsAddrInLcu;
		end

		numPartDecoded := numPartDecoded + 1;
		if DEBUG_CUInfo then
			println("CUInfo = "+cuInfo[0] + " " + cuInfo[1] + " "+ cuInfo[2] + " " + cuInfo[3] + " " + cuInfo[4]);
		end
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	getCuMode.isNotInter: action ==>
	guard
		not(cuMode = INTER || cuMode = SKIP)
	end

	getCuMode.isInter: action SyntaxElem:[mergeIndex] ==>
	guard
		cuMode = INTER || cuMode = SKIP
	do
		foreach int tileIdx in 0 .. numTiles - 1
		do
			if(partAddr[0] >= tilesBeg[tileIdx][0] && partAddr[0] < tilesEnd[tileIdx][0] &&
			   partAddr[1] >= tilesBeg[tileIdx][1] && partAddr[1] < tilesEnd[tileIdx][1]) then
			   	puTilesBeg := [tilesBeg[tileIdx][0], tilesBeg[tileIdx][1]];
			   	puTilesEnd := [tilesEnd[tileIdx][0], tilesEnd[tileIdx][1]];
			 end
		end
		mergeIdx := mergeIndex;
		if DEBUG_SyntaxElem then
			println("mergeIdx = "+mergeIdx);	
		end
	end

	/* Derivation process for motion vectors for merge mode */
	checkMergeIdx.isNotEqToMin1: action ==>
	guard
		mergeIdx != -1
	var
		int numNeighbSelect := 0,
		bool tryGetNeighbour,
		int locationUp[2],
		int locationLeft[2],
		int locationUpBis[2],
		int locationLeftBis[2],
		int refIdxVal := 0,
		int partIdx = numPartDecoded-1,
		bool isAvailableA1 := false,
		bool isAvailableB1 := false,
		uint(size=8) nPSHInit = nPSH,
		uint(size=8) nPSWInit = nPSW,
		uint(size=4) cuPartModeInit = cuPartMode,
		int          partAddrInit[2] = partAddr
	do
		if(paralMergeLvl > 0 && cuPartMode != PART_2Nx2N && predCuSize <= 8) then
			nPSW := max(nPSW, nPSH);
			nPSH := nPSW;
			cuPartMode := PART_2Nx2N;
			partAddr := partAddr1stPu;
			puAbsAddrInLcu := puAbsAddrInLcu1stPu;
		end
		numCandidate := 0;
		getNeighbAddr(ABOVE, dependSlc, false);
		locationUp := neighbLocation;
		locationUpBis := neighbLocIdx;
		getNeighbAddr(LEFT, dependSlc, false);
		locationLeft := neighbLocation;
		locationLeftBis := neighbLocIdx;

		//A1
		if(not (cuPartMode = PART_Nx2N || cuPartMode = PART_nLx2N ||
			cuPartMode = PART_nRx2N) || partIdx!=1) then
			isAvailableA1 := getIsAvailable() and
				((locationLeft[0] >> paralMergeLvl) != (partAddr[0] >> paralMergeLvl) ||
			     (locationLeft[1] >> paralMergeLvl) != (partAddr[1] >> paralMergeLvl));
			getNeighbourMv_MergeIdx_isNotEqToMin1();
			numNeighbSelect := castBoolToInt(predFlag);
		end

		if(numCandidate <= mergeIdx)then
			//B1
			if( not(cuPartMode = PART_2NxN || cuPartMode = PART_2NxnU ||
				cuPartMode = PART_2NxnD) || partIdx != 1) then
	
				tryGetNeighbour := not isAvailableA1 || hasNotSameMvComp(locationUpBis, locationLeftBis);
				neighbLocation := locationUp;
				neighbLocIdx := locationUpBis;
				isAvailableB1 := getIsAvailable() and
					((locationUp[0] >> paralMergeLvl) != (partAddr[0] >> paralMergeLvl) ||
				     (locationUp[1] >> paralMergeLvl) != (partAddr[1] >> paralMergeLvl));
				if(tryGetNeighbour) then
					getNeighbourMv_MergeIdx_isNotEqToMin1();
					numNeighbSelect := numNeighbSelect +
						castBoolToInt(predFlag);
				end
			end
		if(numCandidate <= mergeIdx)then
			//B0
			getNeighbAddr(ABOVE_RIGHT, dependSlc, false);
			tryGetNeighbour := not isAvailableB1 || hasNotSameMvComp(neighbLocIdx, locationUpBis);
			if(tryGetNeighbour) then
				getNeighbourMv_MergeIdx_isNotEqToMin1();
				numNeighbSelect := numNeighbSelect +
					castBoolToInt(predFlag);
			end
		if(numCandidate <= mergeIdx)then
			//A0
			getNeighbAddr(LEFT_BOTTOM, dependSlc, false);
			tryGetNeighbour := not isAvailableA1 || hasNotSameMvComp(neighbLocIdx, locationLeftBis);
			if(tryGetNeighbour) then
				getNeighbourMv_MergeIdx_isNotEqToMin1();
				numNeighbSelect := numNeighbSelect +
					castBoolToInt(predFlag);
			end
		if(numCandidate <= mergeIdx)then
			if(numNeighbSelect<4) then
				getNeighbAddr(ABOVE_LEFT, dependSlc, false);
				tryGetNeighbour := not isAvailableB1 || hasNotSameMvComp(neighbLocIdx, locationUpBis);
				tryGetNeighbour := tryGetNeighbour &&
					(not isAvailableA1 || hasNotSameMvComp(neighbLocIdx, locationLeftBis));
				if(tryGetNeighbour) then
					getNeighbourMv_MergeIdx_isNotEqToMin1();
				end
			end
		if(numCandidate <= mergeIdx)then
			if enTmpMvp then
				getColCandidate(true, 0);
			end
		if(numCandidate <= mergeIdx)then
	 		if(isBSlice) then
				biPredMergeCand(5);
			end
		if(numCandidate <= mergeIdx)then
			foreach int i in numCandidate .. 4
			do
				mvPred[i] := [[0,0],[0,0]];
				refIdxPred[i] := [refIdxVal, refIdxVal];
				if(refIdxVal = minSizeRefListX-1) then
					refIdxVal := 0;
				else
					refIdxVal := refIdxVal + 1;
				end
			end
		end end end end end end end
		nPSH := nPSHInit;
		nPSW := nPSWInit;
		cuPartMode := cuPartModeInit;
		partAddr := partAddrInit;
	end

	checkMergeIdx.isEqToMin1: action SyntaxElem:[se] repeat 4 ==>
	guard
		mergeIdx = -1
	var
		int refIdx[2] = [se[2],se[3]],
		int numNeighbSelect,
		int(size=32) neighbIdxLB[2],
		int(size=32) neighbIdxL[2]
	do
		if DEBUG_SyntaxElem then
			println("mvp_l0 = "+se[0]+" : mvp_l1 = "+se[1]);
			println("refIdx_l0 = "+se[2]+" : refIdx_l1 = "+se[3]);
		end
		saveRefIdx(refIdx, cuSize, cuPartMode, numPartDecoded, refIdxRef,
			currIdx, lcuAddr, puAddrInLcu);
		mvpIdx := [se[0], se[1]];
		foreach int list in 0 .. 1
		do
			numCandidate := 0;

			//Left neighbours
			getNeighbAddr(LEFT_BOTTOM, dependSlc, false); // A0
			neighbIdxLB := neighbLocIdx;
			getNonMergedNeighbourMv(list);

			getNeighbAddr(LEFT, dependSlc, false); // A1
			neighbIdxL := neighbLocIdx;
			if(not predFlag) then
				getNonMergedNeighbourMv(list);
			end
			if(not predFlag) then
				getNeighbAddr(LEFT_BOTTOM, dependSlc, false); // A0'
				getNonMergedScaledMv(list);
			end
			if(not predFlag) then
				getNeighbAddr(LEFT, dependSlc, false); // A1'
				getNonMergedScaledMv(list);
			end
			numNeighbSelect := castBoolToInt(predFlag);

			if(numCandidate <= mvpIdx[list])then
				//Above neighbours
				getNeighbAddr(ABOVE_RIGHT, dependSlc, false); // B0
				getNonMergedNeighbourMv(list);
				if(not predFlag) then
					getNeighbAddr(ABOVE, dependSlc, false); // B1
					getNonMergedNeighbourMv(list);
				end
				if(not predFlag) then
					getNeighbAddr(ABOVE_LEFT, dependSlc, false); // B2
					getNonMergedNeighbourMv(list);
				end
				numNeighbSelect := numNeighbSelect +
					castBoolToInt(predFlag);
			if(numCandidate <= mvpIdx[list])then
				if(numNeighbSelect != 2) then
					predFlag := isInter(partAddr[0] - 1, partAddr[1] + nPSH, neighbIdxLB[0], neighbIdxLB[1]) ||
						isInter(partAddr[0] - 1, partAddr[1] + nPSH - 1, neighbIdxL[0], neighbIdxL[1]);
				else
					predFlag := true;
				end
				if(not predFlag) then
					getNeighbAddr(ABOVE_RIGHT, dependSlc, false); // B0'
					getNonMergedScaledMv(list);
				end
				if(not predFlag) then
					getNeighbAddr(ABOVE, dependSlc, false); // B1'
					getNonMergedScaledMv(list);
				end
				if(not predFlag) then
					getNeighbAddr(ABOVE_LEFT, dependSlc, false); // B2'
					getNonMergedScaledMv(list);
				end
			if(numCandidate <= mvpIdx[list])then
				if enTmpMvp then
					getColCandidate(false, list);
				end
			if(numCandidate <= mvpIdx[list])then
				foreach int i in numCandidate .. 4
				do
					mvPred[i][list][0] := 0;
					mvPred[i][list][1] := 0;
				end
			end end end end
		end
	end

	getMvd: action SyntaxElem:[mvd] repeat 4 ==> IsBiPredOrLx:[isBiPredOrLx],
		IsReadOrNewSlice:[1], Mv:[mvToSend] repeat 2,
		RefIdx:[refIdxToSend], PocRef:[pocToSend], PredCuSize:[puSize] repeat 2
	var
		int idxMvInfo,
		int refIdx[2],
		int(size=32) mvToSend[2],
		int refIdxToSend,
		int(size=16) pocToSend
	do
		if DEBUG_SyntaxElem then
			println("mvd_0_x = "+mvd[0]+" : mvd_0_y = "+mvd[1]);
			println("mvd_1_x = "+mvd[2]+" : mvd_1_y = "+mvd[3]);
		end
		foreach int i in 0 .. 1
		do
			idxMvInfo :=
				if(mergeIdx >= 0) then
					mergeIdx
				else
					mvpIdx[i]
				end;
			if idxMvInfo > -1 and idxMvInfo < 5 then
				if(mvPred[idxMvInfo][i][0] >  32767) then mvPred[idxMvInfo][i][0] :=  32767; end
				if(mvPred[idxMvInfo][i][0] < -32768) then mvPred[idxMvInfo][i][0] := -32768; end
				if(mvPred[idxMvInfo][i][1] >  32767) then mvPred[idxMvInfo][i][1] :=  32767; end
				if(mvPred[idxMvInfo][i][1] < -32768) then mvPred[idxMvInfo][i][1] := -32768; end
				mvVal[i][0] := mvPred[idxMvInfo][i][0] + mvd[2*i];
				mvVal[i][1] := mvPred[idxMvInfo][i][1] + mvd[2*i + 1];
				refIdx[i] := refIdxPred[idxMvInfo][i];
			end
		end
		if(mergeIdx = -1) then
			refIdx := [refIdxRef[currIdx][lcuAddr][puAddrInLcu][i]:
				for int i in 0 .. 1];
		end
		if(not isBSlice || refIdx[0]!=-1 && refIdx[1] !=-1 &&
			predCuSize = 8 && (cuSize[0] < 8 || cuSize[1]<8)) then
			refIdx[1] := -1;
			mvVal[1][0] := 0;
			mvVal[1][1] := 0;
		end
		if(refIdx[0] = -1) then
			mvVal[0][0] := 0;
			mvVal[0][1] := 0;
		end
		if(refIdx[1] = -1) then
			mvVal[1][0] := 0;
			mvVal[1][1] := 0;
		end

		if(mergeIdx != -1) then
			saveRefIdx(refIdx, cuSize, cuPartMode, numPartDecoded, refIdxRef,
				currIdx, lcuAddr, puAddrInLcu);
		end
		saveMvComponent(mvVal, cuSize, cuPartMode, numPartDecoded, mvRef,
			currIdx, lcuAddr, puAddrInLcu);

		if(refIdx[0] != -1 && refIdx[1] != -1) then
			isBiPredOrLx := BI_PRED;
		else if(refIdx[0] != -1) then
			isBiPredOrLx := PRED_L0;
		else
			isBiPredOrLx := PRED_L1;
		end end

		if(refIdx[0]!=-1) then
			refIdxToSend := refIdx[0];
			pocToSend := pocRefListX[0][refIdx[0]];
			mvToSend := [mvVal[0][i] + (cuAddr[i]<<2): for int i in 0 ..1];
		else
			refIdxToSend := refIdx[1];
			pocToSend    := pocRefListX[1][refIdx[1]];
			mvToSend     := [mvVal[1][i] + (cuAddr[i]<<2): for int i in 0 ..1];
		end
		if DEBUG_Mv then
			println("mv = "+mvToSend[0]+", "+mvToSend[1]);
		end
	end

	getRps.launch: action RpsPoc:[numPic]==>
	guard
		nbList < 5
	do
		sizeOfList := numPic;
		if DEBUG_RpsPoc then
			println("RefPocSize["+nbList+"] = "+sizeOfList);
		end
	end

	getRps.done: action ==>
	guard
		nbList = 5
	do
		foreach int i in 0 .. 16
		do
			isRef[i] := isRef[i] and isStillRef[i];
		end
		isRef[currIdx] := true;
		minSizeRefListX := 31;
	end

	getRpsPoc.launch: action RpsPoc:[pocVal] ==>
	guard
		sizeOfList > 0
	do
		sizeOfList := sizeOfList - 1;
		if DEBUG_RpsPoc then
			println("RefPoc = "+pocVal);
		end
		foreach int i in 0 .. 16
		do
			if(pocRef[i] = pocVal)then
				isStillRef[i] := true;
			end
		end
	end

	getRpsPoc.done: action ==>
	guard
		sizeOfList = 0
	do
		nbList := nbList + 1;
	end

	getSizeRefList.launch: action RefList:[sizeList] ==>
	guard
		listIdx < 2
	do
		listSize := sizeList;
		minSizeRefListX := min(sizeList, minSizeRefListX);
		sizeIdx := 0;
		if DEBUG_RefList then
			println("numRefIdxLxAct["+listIdx+"] = "+listSize);
		end		
	end

	getSizeRefList.done: action ==>
	guard
		listIdx = 2
	do
		useLN := (maxPoc>pocRef[currIdx]) || not isBSlice;
		
		colPoc := pocRefListX[colocFromL0^1][colRefIdx];
		colRefIdx := 0;
		foreach int i in 0 .. 16
		do
			if(isRef[i] && pocRef[i] = colPoc) then
				colRefIdx := i;
			end
		end
	end

	getRefList.launch: action RefList:[refPoc] ==>
	guard
		sizeIdx < listSize
	do
		if DEBUG_RefList then
			println("RefList["+listIdx+"]["+sizeIdx+"] = "+refPoc);
		end
		maxPoc := max(maxPoc, refPoc);
		pocRefListX[listIdx][sizeIdx] := refPoc;
		pocRefList[currIdx][slcIdx][listIdx][sizeIdx] := refPoc;
		sizeIdx := sizeIdx + 1;
	end

	getRefList.done: action ==>
	guard
		sizeIdx = listSize
	do
		listIdx := listIdx + 1;
	end

	send2ndMv.launch: action ==> PocRef:[pocToSend], RefIdx:[refIdxToSend],
		Mv:[mvToSend] repeat 2, PredCuSize:[puSize] repeat 2
	guard
		isBiPredOrLx = BI_PRED
	var
		int refIdxToSend,
		int mvToSend[2],
		int(size=16) pocToSend
	do
		refIdxToSend := refIdxRef[currIdx][lcuAddr][puAddrInLcu][1];
		mvToSend := [mvVal[1][i] + (cuAddr[i]<<2): for int i in 0 .. 1];
		pocToSend := pocRefListX[1][refIdxToSend];
		if DEBUG_Mv then
			println("mv = "+mvToSend[0]+", "+mvToSend[1]);
		end		
	end

	send2ndMv.skip: action ==>
	guard
		isBiPredOrLx != BI_PRED
	end

	schedule fsm GetPartMode:
		GetPartMode (isNewPicOrSlice  )--> CheckIndepSlc;
		GetPartMode (getPartMode      )--> GetCuInfo;

		CheckIndepSlc(checkDepSlc.isTrue  )--> GetPartMode;
		CheckIndepSlc(checkDepSlc.isFalse )--> GetTilesCoord;

		GetTilesCoord (getTilesCoord.launch )--> GetTilesCoord;
		GetTilesCoord (getTilesCoord.done   )--> GetRps;

		GetRps (getRps.launch )--> GetRpsPoc;
		GetRps (getRps.done   )--> GetSizeRefList;

		GetRpsPoc (getRpsPoc.launch )--> GetRpsPoc;
		GetRpsPoc (getRpsPoc.done   )--> GetRps;

		GetSizeRefList (getSizeRefList.launch )--> GetRefList;
		GetSizeRefList (getSizeRefList.done   )--> GetPartMode;

		GetRefList (getRefList.launch )--> GetRefList;
		GetRefList (getRefList.done   )--> GetSizeRefList;

		GetCuInfo   (getCuInfo.launch )--> GetCuMode;
		GetCuInfo   (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotInter )--> GetCuInfo;
		GetCuMode (getCuMode.isInter    )--> CheckMergeIdx;

		CheckMergeIdx (checkMergeIdx )--> GetMvd;
		GetMvd        (getMvd        )--> Send2ndMv;
		Send2ndMv     (send2ndMv     )--> GetCuInfo;
	end
end