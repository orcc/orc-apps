/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * This actor generates the components needed for the inter prediction
 * (mv and refIdx).
 *
 * 
 * @input ColocInfo : Informations concerning the colocation picture.
 * 
 * @input CuAddr : Address in pixel of all Cu sent.
 * 
 * @input CuMode : Mode (Intra, Inter or Skip mode) of all Cu sent.
 * 
 * @input CuSize : Size of all Cu sent.
 * 
 * @input PartMode : Giving the partitioning mode of the current Cu.
 * 
 * @input Poc : Picture Order Count of the current slice.
 * 
 * @input RefList : Reference Lists (L0 and L1) of the current slice.
 * 
 * @input RpsPoc : Poc present in the Reference Picture Set of the current slice.
 * 
 * @input SliceType : Slice type (I, P or B) of the current slice.
 * 
 * @input SyntaxElem : Syntax elements decoded by the parser.
 * 
 * 
 * @output IsBiPredOrLx : Indicates when the current Cu is using Bi-prediction.
 * 
 * @output IsReadOrNewSlc : Indicates if samples are asked from the current Rps
 *		or if there is a new picture.
 * 
 * @output Mv : movement vectors of the current Cu.
 * 
 * @output PocRef : Poc used for the prediction of the current Cu.
 * 
 * @output PredCuSize : Size of the largest side of the current Cu.
 * 
 * @output RefIdx : Reference indexes of the lists (L0 and L1) of the current
 *		slice.
 *
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */

package devel.org.sc29.wg11.mpegh.part2.main.inter;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor MvComponentPred(bool FIX_TMVP_REFIDX0)
	uint(size=16) CUInfo,
	uint(size=8)  LcuSizeMax,
	uint(size=4)  PartMode,
	uint(size=16) PicSize,
	int(size=16) Poc,
	int (size=16) RefList,
	int (size=16) RpsPoc,
	uint(size=16) SliceAddr,
	uint(size=2)  SliceType,
	int (size=16) SyntaxElem,
	uint(size=16) TilesCoord
		==>
	uint(size=2)  IsBiPredOrLx,
	uint(size=1)  IsReadOrNewSlice,
	int (size=32) Mv,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize,
	uint(size=3)  RefIdx
		:

	uint(size=16) MAX_NUM_SLICE = 1000;

 	bool DEBUG_CUInfo	    = false;
 	bool DEBUG_PartMode	    = false;
 	bool DEBUG_PicSize	    = false;
 	bool DEBUG_RefList		= false;
 	bool DEBUG_RpsPoc		= false;
 	bool DEBUG_SyntaxElem	= false;
 	bool DEBUG_Mv			= false;
	/* Constants representing all the neighbour required during for predicting
	 * the different components
	 */
	int LEFT_BOTTOM = 0;
	int LEFT = 1;
	int ABOVE_RIGHT = 2;
	int ABOVE = 3;
	int ABOVE_LEFT = 4;
	int RIGHT_BOTTOM = 5;
	int CENTER = 6;

	/* Specification of l0CandIdx and l1CandIdx */
	uint(size=2) combIdxToLXCandIdx[16][2] =
		[[0,1], [1,0], [0,2], [2,0], [1,2], [2,1],
	 [0,3], [3,0], [1,3], [3,1], [2,3], [3,2]];

	uint(size=4)  cuPartMode;
	int           mergeIdx;
	int           mvpIdx[2];
	int           colPoc;
	int           colRefIdx;
	int(size=16)  colRefPoc[2][16];
	uint(size=1)  colocFromL0;
	uint(size=3)  numPart;
	uint(size=3)  numPartDecoded;
	uint(size=2)  listIdx;
	uint(size=3)  listSize;
	uint(size=3)  sizeIdx;
	int (size=16) maxPoc;
	int           picSizeInPart[2];
	bool          useLN;
	bool          isBSlice;
	int           partAddr[2];
	int           partAddr1stPu[2];
	int           cuAddr[2];
	uint(size=2)  cuMode;
	int           mvPred[5][2][2];
	int           refIdxPred[5][2];
	int(size=16)  pocRef[17];
	uint(size=16) numSlcPerPict[17];
	int(size=16)  pocRefList[17][MAX_NUM_SLICE][2][16];
	uint(size=16) slcAddrRef[17][MAX_NUM_SLICE][2];
	int(size=4)   refIdxRef[17][PICT_WIDTH/4][PICT_HEIGHT/4][2];
//	uint(size=4)  modeRef[17][PICT_WIDTH/4][PICT_HEIGHT/4];
	int(size=16)  mvRef[17][PICT_WIDTH/4][PICT_HEIGHT/4][2][2];
	int           neighbLocation[2];
	int           nPSH;
	int           nPSW;
	bool          isRef[17];
	bool          isStillRef[17];
	int (size=4)  currIdx;
	uint(size=16) slcIdx;
	int (size=16) colSlcIdx;
	bool          predFlag;
	int (size=8)  paralMergeLvl;
	int numCandidate;
	uint sizeOfList;
	uint nbList;
	uint(size=5)  minSizeRefListX;
	int (size=16) pocRefListX[2][16];
	uint(size=2)  isBiPredOrLx;
	uint(size=7)  predCuSize;
	uint(size=7)  cuSize[2];
	bool          enTmpMvp;
	uint(size=16) slcAddr[2];
	bool          dependSlc;
	bool          newPict;
	int(size=16)  iLoop;
	uint(size=16) numTiles;
	uint(size=16) tilesBeg[MAX_NUM_TILES][2];
	uint(size=16) tilesEnd[MAX_NUM_TILES][2];
	int (size=16) puTilesBeg[2];
	int (size=16) puTilesEnd[2];
	uint(size=8)  lcuSizeMax;
	uint(size=8)  lcuSizeMaxInPart;
	uint(size=8)  maskLcuSzMax;
	
	function isInter(int xN, int yN) --> bool
	:
		if(xN>=0 && yN>=0 && xN<picSizeInPart[0] && yN<picSizeInPart[1])then
			if(dependSlc || not (yN < slcAddr[1] || (yN < slcAddr[1] + lcuSizeMax/4 &&
			   xN < slcAddr[0]))) then
				if(xN >= puTilesBeg[0] && xN < puTilesEnd[0] &&
				   yN >= puTilesBeg[1] && yN < puTilesEnd[1]) then
					refIdxRef[currIdx][xN][yN][0] != -1 ||
					refIdxRef[currIdx][xN][yN][1] != -1
				else
					false
				end
			else
				false
			end
		else
			false
		end
	end

	function getIsAvailable() --> bool
	var
		int xN = neighbLocation[0],
		int yN = neighbLocation[1]
	:
		if(xN >= 0 && xN < picSizeInPart[0] && yN >= 0 && yN < picSizeInPart[1]) then
			refIdxRef[currIdx][xN][yN][0] != -1 || refIdxRef[currIdx][xN][yN][1] != -1
		else
			false
		end
	end

	/* Indicates if the Cu Orig and Neighb located in the current picture have the same reference indexes and movement vectors. */
	function hasNotSameMvComp(int orig[2], int neighb[2]) --> bool
	var
		int xNOrig = orig[0],
		int yNOrig = orig[1],
		int xNNeighb = neighb[0],
		int yNNeighb = neighb[1],
		int xNOrigMasked = orig[0] & (MASK_WIDTH_POW_2>>2),
		int yNOrigMasked = orig[1] & (MASK_HEIGHT_POW_2>>2),
		int xNNeighbMasked = neighb[0] & (MASK_WIDTH_POW_2>>2),
		int yNNeighbMasked = neighb[1] & (MASK_HEIGHT_POW_2>>2),
		int refIdxCurrCu[2] = [refIdxRef[currIdx][xNOrigMasked]
			[yNOrigMasked][i]:for int i in 0 .. 1],
		int refIdxNeighb[2] = [refIdxRef[currIdx][xNNeighbMasked]
			[yNNeighbMasked][i]: for int i in 0 .. 1],
		int mvCurrCu[2][2] = [[mvRef[currIdx][xNOrigMasked]
			[yNOrigMasked][i][j]:for int j in 0 .. 1]:for int i in 0 .. 1],
		int mvNeighb[2][2] = [[mvRef[currIdx][xNNeighbMasked][yNNeighbMasked]
			[i][j]: for int j in 0 .. 1]:for int i in 0 .. 1]
	:
		if(xNNeighb >= 0 && yNNeighb >= 0 && xNNeighb < picSizeInPart[0] &&
			yNNeighb < picSizeInPart[1]) then

			if(not (xNOrig >= 0 && yNOrig >= 0 && xNOrig < picSizeInPart[0] &&
				yNOrig < picSizeInPart[1])) then

				false
			else
				if(refIdxCurrCu[0] = refIdxNeighb[0] && refIdxCurrCu[1] =
					refIdxNeighb[1]) then
					not ((refIdxCurrCu[0] = -1 ||(mvCurrCu[0][0] =
						mvNeighb[0][0] && mvCurrCu[0][1] = mvNeighb[0][1])) &&
						(refIdxCurrCu[1] = -1 || (mvCurrCu[1][0] =
							mvNeighb[1][0] && mvCurrCu[1][1] = mvNeighb[1][1])))
				else
					true
				end
			end
		else
			true
		end
	end

	procedure searchColSlcAddr(int(size=32) partAddr[2])
	var
		int(size=32) pocSlcAddr[2]
	begin
		colSlcIdx := -1;
		foreach int i in 0 .. numSlcPerPict[colRefIdx] - 1
		do
			pocSlcAddr := [slcAddrRef[colRefIdx][i][j]: for int j in 0 .. 1];
			if(partAddr[1] >= pocSlcAddr[1] + lcuSizeMax / 4 ||
					(partAddr[1] >= pocSlcAddr[1] && partAddr[0] >= pocSlcAddr[0])) then
				if(colSlcIdx != -1) then
					if(pocSlcAddr[1] > slcAddrRef[colRefIdx][colSlcIdx][1] ||
					   pocSlcAddr[1] = slcAddrRef[colRefIdx][colSlcIdx][1] &&
					   pocSlcAddr[0] > slcAddrRef[colRefIdx][colSlcIdx][0]) then
						colSlcIdx := i;
					end
				else
					colSlcIdx := i;
				end
			end
		end
		foreach int list in 0 .. 1
		do
			foreach int k in 0 .. 15
			do
				colRefPoc[list][k] := pocRefList[colRefIdx][colSlcIdx][list][k];
			end
		end
	end

	/** Saving information for the next predictions **/
	procedure saveRefIdx(int refIdxToSave[2])
	begin
		foreach int x in partAddr[0] .. partAddr[0] + nPSW - 1
		do
			foreach int y in partAddr[1] .. partAddr[1] + nPSH - 1
			do
				refIdxRef[currIdx][x][y] := [refIdxToSave[i]:
					for int i in 0 .. 1];
			end
		end
	end

	procedure saveMvComponent(int(size=16) mvToSave[2][2])
	begin
		foreach int x in partAddr[0] .. partAddr[0] + nPSW - 1
		do
			foreach int y in partAddr[1] .. partAddr[1] + nPSH - 1
			do
				mvRef[currIdx][x][y] :=
					[[mvToSave[i][j]:for int j in 0 .. 1]:for int i in 0 .. 1];
			end
		end
	end

	/* Computes the location of the neighbour. The result will be in the vector
	 * neighbLocation
	 */
	procedure getNeighbAddr(int location, bool isMerged, bool depSlcOrCol, bool isColNeighb)
	var
		int bitMod = 3
	begin
		if(location = LEFT) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] + nPSH - 1;
		else if(location = ABOVE) then
			neighbLocation[0] := partAddr[0] + nPSW - 1;
			neighbLocation[1] := partAddr[1] - 1;
		else if(location = ABOVE_RIGHT) then
			neighbLocation[0] := partAddr[0] + nPSW;
			neighbLocation[1] := partAddr[1] - 1;
		else if(location = LEFT_BOTTOM) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] + nPSH;
		else if(location = ABOVE_LEFT) then
			neighbLocation[0] := partAddr[0] - 1;
			neighbLocation[1] := partAddr[1] - 1;
		else if(location = RIGHT_BOTTOM) then
			neighbLocation[0] := partAddr[0] + nPSW;
			neighbLocation[1] := partAddr[1] + nPSH;
			if(neighbLocation[0] >= picSizeInPart[0] ||
				neighbLocation[1] >= picSizeInPart[1]) then
				neighbLocation[0] := -1;
				neighbLocation[1] := -1;
			else
				if((neighbLocation[1] & maskLcuSzMax) = 0 ||
					(neighbLocation[1]>>4 != partAddr[1]>>4)) then
					neighbLocation[1] := -1;
				end
				neighbLocation[0] := neighbLocation[0] & ~bitMod;
				neighbLocation[1] := neighbLocation[1] & ~bitMod;
			end
		else
			neighbLocation[0] := partAddr[0] + nPSW/2;
			neighbLocation[1] := partAddr[1] + nPSH/2;
			if(neighbLocation[1] >> 4 != partAddr[1] >> 4) then
				neighbLocation[1] := -1;
			end
			neighbLocation[0] := neighbLocation[0] & ~bitMod;
			neighbLocation[1] := neighbLocation[1] & ~bitMod;
		end end end end end end

		if(not depSlcOrCol && (neighbLocation[1] < slcAddr[1] ||
			(neighbLocation[1]< slcAddr[1] + lcuSizeMax/4 &&
				neighbLocation[0] < slcAddr[0]))) then
			neighbLocation[1] := -1;
		end
		if(not isColNeighb and (neighbLocation[0] < puTilesBeg[0] or
			neighbLocation[0] >= puTilesEnd[0] or neighbLocation[1] < puTilesBeg[1] or
			neighbLocation[1] >= puTilesEnd[1])) then
			neighbLocation[1] := -1;
		end
	end

	/* method used for getting the neighbour. This method is used when mergeIdx
	 * value is absent (in this decoder it corresponds to mergeidx = -1)
	 */
	procedure getNonMergedNeighbourMv(uint listX)
	var
		int xN := neighbLocation[0],
		int yN := neighbLocation[1],
		int xPartAddr = partAddr[0],
		int yPartAddr = partAddr[1],
		bool sameComponent := false,
		int refIdx1,
		int refIdx2,
		int currMv[2],
		int i := 0
	begin
		predFlag := false;
		if(xN >= 0 && yN >= 0 && xN < picSizeInPart[0] &&
			yN < picSizeInPart[1]) then
			if(refIdxRef[currIdx][xN][yN][listX] =
				refIdxRef[currIdx][xPartAddr][yPartAddr][listX]) then
				getNeighbourMv(true, listX, false);
			else
				refIdx1 := refIdxRef[currIdx][xN][yN][listX^1];
				refIdx2 := refIdxRef[currIdx][xPartAddr][yPartAddr][listX];
				if(refIdx1!=-1 && refIdx2 != -1) then
					if(pocRefListX[listX^1][refIdx1] =
						pocRefListX[listX][refIdx2]) then
						predFlag := true;
						mvPred[numCandidate][listX] := [mvRef[currIdx][xN][yN]
							[listX^1][j]:for int j in 0 .. 1];
						numCandidate := numCandidate + 1;
				end end
			end
			if(predFlag) then
				currMv := [mvPred[numCandidate-1][listX][j]:
					for int j in 0 .. 1];
				while(i<numCandidate-1 && not sameComponent)
				do
					if(mvPred[i][listX][0] = currMv[0] &&
						mvPred[i][listX][1] = currMv[1]) then
						numCandidate := numCandidate - 1;
						sameComponent := true;
					end
					i:=i+1;
				end
			end
		end
	end

	procedure getNeighbourMv(bool isNonMerged, uint listX, bool scaled)
	var
		int xN = neighbLocation[0],
		int yN = neighbLocation[1],
		bool sameComponent := false,
		uint listAvail
	begin
		predFlag := false;
		if(isNonMerged || (partAddr[0] >> paralMergeLvl) != (xN >> paralMergeLvl) ||
		                  (partAddr[1] >> paralMergeLvl) != (yN >> paralMergeLvl)) then
			if(xN>=0 && yN>=0 && xN<picSizeInPart[0] && yN<picSizeInPart[1]) then
				predFlag := refIdxRef[currIdx][xN][yN][0] != -1 ||
					refIdxRef[currIdx][xN][yN][1] != -1 ;
				if(predFlag) then
					if(isNonMerged && not scaled) then
						foreach int i in 0 .. numCandidate-1
						do
							if(mvPred[i][0][0] = mvRef[currIdx][xN][yN][0][0] &&
							   mvPred[i][0][1] = mvRef[currIdx][xN][yN][0][1] &&
							   mvPred[i][1][0] = mvRef[currIdx][xN][yN][1][0] &&
							   mvPred[i][1][1] = mvRef[currIdx][xN][yN][1][1]) then
								sameComponent := true;
							end
						end
					end
					if(not sameComponent) then
						if(isNonMerged) then
							listAvail :=
								if(refIdxRef[currIdx][xN][yN][listX] != -1) then
									listX
								else
									listX^1
								end;
							mvPred[numCandidate][listX] := [mvRef[currIdx][xN][yN]
								[listAvail][i]:for int i in 0 .. 1];
							refIdxPred[numCandidate][listX] := refIdxRef[currIdx]
								[xN][yN][listAvail];
						else
							mvPred[numCandidate] :=
								[[mvRef[currIdx][xN][yN][list][i]:
									for int i in 0 .. 1]:for int list in 0 .. 1];
							refIdxPred[numCandidate] := [refIdxRef[currIdx][xN][yN]
								[list]:for int list in 0 .. 1];
						end
						numCandidate := numCandidate + 1;
					end
				end
			end
		end
	end

	procedure getNonMergedScaledMv(uint listX)
	var
		int xN := neighbLocation[0],
		int yN := neighbLocation[1],
		int xPartAddr = partAddr[0],
		int yPartAddr = partAddr[1],
		int listAvail,
		int currMv[2],
		int refIdxRefCurrPic,
		int i := 0,
		bool sameComponent:= false,
		int mvParam[2]
	begin
		predFlag := false;
		if(xN>=0 && yN>=0 && xN<picSizeInPart[0] && yN<picSizeInPart[1]) then
			if(refIdxRef[currIdx][xN][yN][0] != -1 ||
				refIdxRef[currIdx][xN][yN][1] != -1) then
				listAvail :=
					if(refIdxRef[currIdx][xN][yN][listX] != -1) then
						listX
					else
						listX^1
					end;
				getNeighbourMv(true, listX, true);
				refIdxRefCurrPic := refIdxRef[currIdx][xPartAddr][yPartAddr]
					[listX];
				if(refIdxRefCurrPic = -1) then
					refIdxRefCurrPic := 0;
				end
				mvParam := [mvPred[numCandidate-1][listX][j]:for int j in 0 .. 1];
				mvScaling(mvParam, refIdxRefCurrPic, listAvail, listX, currIdx,
					pocRefListX);
				mvPred[numCandidate-1][listX] :=
					[mvParam[j]:for int j in 0 .. 1];
				
				currMv :=
					[mvPred[numCandidate-1][listX][j]: for int j in 0 .. 1];
				while(i<numCandidate-1 && not sameComponent)
				do
					if(mvPred[i][listX][0] = currMv[0] &&
						mvPred[i][listX][1] = currMv[1]) then
						numCandidate := numCandidate - 1;
						sameComponent := true;
					end
					i:=i+1;
				end
			end
		end
	end

	/* Scaling the movement vector acording to the Cu from the neighbour part
	 * and the current Cu
	 */
	procedure mvScaling(int mv[2], int refIdxRefCurrPic, uint listAvail,
		uint listX, uint pictIdx, int(size=16) refList[2][16])
	var
		int xN = neighbLocation[0],
		int yN = neighbLocation[1],
		int idxColRef = refIdxRef[pictIdx][xN][yN][listAvail],
		int pocRefCol = refList[listAvail][idxColRef],
		int pocRefCurrPic = pocRefList[currIdx][slcIdx][listX][refIdxRefCurrPic],
		int deltaColPic,
		int deltaCurrPic,
		int td,
		int tb,
		int tx,
		int distScaleFactor,
		int newMv
	begin
		deltaColPic := pocRef[pictIdx] - pocRefCol;
		deltaCurrPic := pocRef[currIdx] - pocRefCurrPic;
		if(deltaColPic != deltaCurrPic) then
			td := clip_i32(deltaColPic, -127, 128);
			tb := clip_i32(deltaCurrPic, -127, 128);
			tx := (16384 + abs(td/2))/td;
			distScaleFactor := clip_i32((tb*tx+32)>>6, -4096, 4095);
			foreach int i in 0 .. 1
			do
				newMv := distScaleFactor*mv[i];
				if(newMv>= 0) then
					newMv := (newMv + 127)>>8;
				else
					newMv := -((-newMv + 127)>>8);
				end
				mv[i] := newMv;
			end
		end
	end

	/* Derivation process for temporal motion vector prediction part1 */
	procedure getColCandidate(bool isMerged, uint listX)
	begin
		if(isMerged) then
			listX := 0;
		end
		getNeighbAddr(RIGHT_BOTTOM, false, true, true);
		getColNeighbourMv(isMerged, listX);
		if(not predFlag) then
			getNeighbAddr(CENTER, false, true, true);
			getColNeighbourMv(isMerged, listX);
		end
	end

	/* Derivation process for temporal motion vector prediction part2 */
	procedure getColNeighbourMv(bool isMerged, uint listX)
	var
		int xN := neighbLocation[0],
		int yN := neighbLocation[1],
		int mv[2][2],
		int refIdxRefCurrPic,
		int refIdxRefCurrPicL1,
		int listAvail[2],
		int partIdx = numPartDecoded - 1,
		int mvScal[2]
	begin
		predFlag := false;
		if(xN>=0 && yN>=0 && xN<picSizeInPart[0] && yN<picSizeInPart[1]) then
			predFlag := refIdxRef[colRefIdx][xN][yN][0] != -1 ||
				refIdxRef[colRefIdx][xN][yN][1] != -1;
			if(predFlag) then
				mv := [[mvRef[colRefIdx][xN][yN][i][j]:for int j in 0 .. 1]:
					for int i in 0 .. 1];
				if(isMerged) then
					if(not FIX_TMVP_REFIDX0) then
						refIdxRefCurrPic :=
							if(isInter(partAddr[0]-1, partAddr[1]+nPSH-1)) then
								refIdxRef[currIdx][partAddr[0] - 1]
									[partAddr[1] + nPSH - 1][0]
							else
								0
							end;
						if(refIdxRefCurrPic = -1 || partIdx = 1) then
							refIdxRefCurrPic := 0;
						end
						refIdxRefCurrPicL1 :=
							if(isInter(partAddr[0] - 1, partAddr[1] + nPSH - 1))
							then
								refIdxRef[currIdx][partAddr[0] - 1]
									[partAddr[1] + nPSH - 1][1]
							else
								0
							end;
						if(refIdxRefCurrPicL1 = -1 || partIdx = 1) then
							refIdxRefCurrPicL1 := 0;
						end
					else
						refIdxRefCurrPic := 0;
						refIdxRefCurrPicL1 := 0;
					end
					if(refIdxRef[colRefIdx][xN][yN][1] = -1) then
						mv[1][0] := mv[0][0];
						mv[1][1] := mv[0][1];
						listAvail := [0, 0];
					else if(refIdxRef[colRefIdx][xN][yN][0] = -1) then
						mv[0][0] := mv[1][0];
						mv[0][1] := mv[1][1];
						listAvail := [1, 1];
					else
						if(useLN) then
							if(colocFromL0 = 0)then
								mv[1][0] := mv[0][0];
								mv[1][1] := mv[0][1];
								listAvail := [0, 0];
							else
								mv[0][0] := mv[1][0];
								mv[0][1] := mv[1][1];
								listAvail := [1, 1];
							end
						else
							listAvail := [0, 1];
						end
					end end
					searchColSlcAddr(neighbLocation);
					mvScal := [mv[0][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPic,   listAvail[0], 0, 
						colRefIdx, colRefPoc);
					mv[0] := [mvScal[i]:for int i in 0 .. 1];
					mvScal := [mv[1][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPicL1, listAvail[1], 1,
						colRefIdx, colRefPoc);
					mv[1] := [mvScal[i]:for int i in 0 .. 1];
					refIdxPred[numCandidate][0] := refIdxRefCurrPic;
					refIdxPred[numCandidate][1] := refIdxRefCurrPicL1;
					mvPred[numCandidate] := [[mv[i][j]:for int j in 0 .. 1]:
						for int i in 0 .. 1];
				else
					listAvail[0] :=
						if(refIdxRef[colRefIdx][xN][yN][listX] != -1) then
							listX
						else
							listX^1
						end;
					if(refIdxRef[colRefIdx][xN][yN][0] != -1 &&
						refIdxRef[colRefIdx][xN][yN][1] != -1 && useLN) then
						listAvail[0] := colocFromL0;
					end
					refIdxRefCurrPic :=
						if(isInter(partAddr[0],partAddr[1])) then
							refIdxRef[currIdx][partAddr[0]][partAddr[1]][listX]
						else
							0
						end;
					if(refIdxRefCurrPic = -1) then
						refIdxRefCurrPic := 0;
					end
					searchColSlcAddr(neighbLocation);
					mvScal := [mv[listAvail[0]][i]:for int i in 0 .. 1];
					mvScaling(mvScal, refIdxRefCurrPic, listAvail[0], listX,
						colRefIdx, colRefPoc);
					mv[listAvail[0]] := [mvScal[i]:for int i in 0 .. 1];
					mvPred[numCandidate][listX] := [mv[listAvail[0]][i]:
						for int i in 0 .. 1];
					refIdxPred[numCandidate][listX] := refIdxRefCurrPic;
				end
				numCandidate := numCandidate + 1;
			end
		end
	end

	/* Derivation process for combined bi-predictive merging candidates */
	procedure biPredMergeCand(uint maxNumCandidate)
	var
		int combIdxMax = numCandidate * (numCandidate-1),
		int combIdx := 0,
		uint l0CandIdx,
		uint l1CandIdx,
		int  refIdxL0Cand,
		int  refIdxL1Cand,
		uint mvL0Cand[2],
		uint mvL1Cand[2]
	begin
		while(combIdx != combIdxMax && numCandidate != maxNumCandidate)
		do
			l0CandIdx := combIdxToLXCandIdx[combIdx][0];	
			l1CandIdx := combIdxToLXCandIdx[combIdx][1];
			refIdxL0Cand := refIdxPred[l0CandIdx][0];
			refIdxL1Cand := refIdxPred[l1CandIdx][1];
			mvL0Cand := [mvPred[l0CandIdx][0][i]:for int i in 0 .. 1];
			mvL1Cand := [mvPred[l1CandIdx][1][i]:for int i in 0 .. 1];
			if(refIdxL0Cand!=-1 && refIdxL1Cand!= -1) then
				if(pocRefListX[0][refIdxL0Cand] !=
					pocRefListX[1][refIdxL1Cand] ||
					mvL0Cand[0] != mvL1Cand[0] || mvL0Cand[1] != mvL1Cand[1])
					then
					mvPred[numCandidate][0] := [mvL0Cand[i]:
						for int i in 0 .. 1];
					mvPred[numCandidate][1] := [mvL1Cand[i]:
						for int i in 0 .. 1];
					refIdxPred[numCandidate][0] := refIdxL0Cand;
					refIdxPred[numCandidate][1] := refIdxL1Cand;
					numCandidate := numCandidate + 1;
				end
			end
			combIdx := combIdx + 1;
		end
	end

	/* Getting information from new Slice, finding some place for the refence
	 * tables, and initializing the reference tables
	 */
	isNewSlice: action PartMode:[partMode], SliceAddr:[sliceAddress] repeat 2,
		SyntaxElem:[paralMergeLevel, tmvpFlag] ==>
	guard
		partMode = PART_MODE_SLICE_DEP || partMode = PART_MODE_SLICE_INDEP ||
		partMode = PART_MODE_PICT
	do
		slcAddr   := [sliceAddress[0]/4, sliceAddress[1]/4];
		dependSlc := partMode = PART_MODE_SLICE_DEP;
		newPict   := partMode = PART_MODE_PICT;
		enTmpMvp  := tmvpFlag != 0;
		paralMergeLvl := paralMergeLevel - 2;
		if DEBUG_PartMode then
			println("partMode = "+partMode);
		end
		nbList := 0;
		if(partMode = PART_MODE_PICT) then
			slcIdx := 0;
		elsif(partMode = PART_MODE_SLICE_INDEP) then
			slcIdx := slcIdx + 1;
			slcAddrRef[currIdx][slcIdx] := [slcAddr[i]: for int i in 0 .. 1];
			numSlcPerPict[currIdx] := numSlcPerPict[currIdx] + 1;
		end
	end

	getTilesCoord.launch: action TilesCoord:[tilesCoord] repeat 4 ==>
	guard
		iLoop < numTiles
	do
		tilesBeg[iLoop] := [tilesCoord[0]/4, tilesCoord[1]/4];
		tilesEnd[iLoop] := [tilesCoord[2]/4, tilesCoord[3]/4];
		iLoop := iLoop + 1;
	end

	getTilesCoord.done: action ==>
	guard
		iLoop = numTiles
	end

	checkDepSlc.isTrue: action ==>
	guard
		dependSlc
	end

	checkDepSlc.isFalse: action SyntaxElem:[colFromLX, colRefIdxVal],
		LcuSizeMax:[log2_lcuSz], PicSize:[picSize] repeat 2, Poc:[poc],
		SliceType:[sliceType], TilesCoord:[valNumTiles] ==> IsReadOrNewSlice:[0]
	guard
		not dependSlc
	do
		isBSlice := sliceType = B_SLICE;
		listIdx := 0;
		maxPoc := MIN_INT16;
		foreach int i in 0 .. 16
		do
			isStillRef[i] := false;
		end

		if(newPict) then
			currIdx := -1;
			foreach int i in 0 .. 16
			do
				if((currIdx = -1 and not isRef[i]) ||
					(isRef[i] and pocRef[i]=poc)) then
					currIdx  := i;
				end
			end
			numSlcPerPict[currIdx] := 1;
			slcAddrRef[currIdx][0] := [slcAddr[i]: for int i in 0 .. 1];

			foreach int x in 0 .. (picSize[0] - 1) / 4
			do
				foreach int y in 0 .. (picSize[1] - 1) / 4
				do
					refIdxRef[currIdx][x][y] := [-1, -1];
				end
			end
		end
		
		isRef[currIdx] := true;
		pocRef[currIdx] := poc;
		colRefIdx := colRefIdxVal & 15;
		if(isBSlice)then
			colFromLX := 1-colFromLX;
		else
			colFromLX := 0;
		end
		colocFromL0 := colFromLX^1;
		if DEBUG_PicSize then
			println("picSize = "+picSize[0] + " " + picSize[1]);
		end
		picSizeInPart[0] := picSize[0]/4;
		picSizeInPart[1] := picSize[1]/4;

		numTiles := valNumTiles;
		iLoop := 0;

		lcuSizeMax := 1 << log2_lcuSz;
		lcuSizeMaxInPart := lcuSizeMax / 4;
		maskLcuSzMax     := lcuSizeMaxInPart - 1;
	end

	getPartMode: action PartMode:[partMode] ==>
	guard
		partMode != PART_MODE_SLICE_DEP && partMode != PART_MODE_SLICE_INDEP &&
		partMode != PART_MODE_PICT
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
		cuPartMode := partMode;
		if DEBUG_PartMode then
			println("partMode = "+partMode);
		end
	end

	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		predCuSize := max(cuInfo[3], cuInfo[4]);
		cuSize := [cuInfo[3], cuInfo[4]];
		partAddr[0] := cuInfo[1]/4;
		partAddr[1] := cuInfo[2]/4;
		cuAddr := [cuInfo[1], cuInfo[2]];
		nPSW := cuInfo[3]/4;
		nPSH := cuInfo[4]/4;
		if(numPartDecoded = 0) then
			partAddr1stPu := partAddr;
		end
		numPartDecoded := numPartDecoded + 1;
		if DEBUG_CUInfo then
			println("CUInfo = "+cuInfo[0] + " " + cuInfo[1] + " "+ cuInfo[2] + " " + cuInfo[3] + " " + cuInfo[4]);
		end
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	end

	getCuMode.isNotInter: action ==>
	guard
		not(cuMode = INTER || cuMode = SKIP)
	end

	getCuMode.isInter: action SyntaxElem:[mergeIndex] ==>
	guard
		cuMode = INTER || cuMode = SKIP
	do
		foreach int tileIdx in 0 .. numTiles - 1
		do
			if(partAddr[0] >= tilesBeg[tileIdx][0] && partAddr[0] < tilesEnd[tileIdx][0] &&
			   partAddr[1] >= tilesBeg[tileIdx][1] && partAddr[1] < tilesEnd[tileIdx][1]) then
			   	puTilesBeg := [tilesBeg[tileIdx][0], tilesBeg[tileIdx][1]];
			   	puTilesEnd := [tilesEnd[tileIdx][0], tilesEnd[tileIdx][1]];
			 end
		end
		mergeIdx := mergeIndex;
		if DEBUG_SyntaxElem then
			println("mergeIdx = "+mergeIdx);	
		end
	end

	/* Derivation process for motion vectors for merge mode */
	checkMergeIdx.isNotEqToMin1: action ==>
	guard
		mergeIdx != -1
	var
		int numNeighbSelect := 0,
		bool tryGetNeighbour,
		int locationUp[2],
		int locationLeft[2],
		int refIdxVal := 0,
		int partIdx = numPartDecoded-1,
		bool isAvailableA1 := false,
		bool isAvailableB1 := false,
		uint(size=8) nPSHInit = nPSH,
		uint(size=8) nPSWInit = nPSW,
		uint(size=4) cuPartModeInit = cuPartMode,
		int          partAddrInit[2] = partAddr
	do
		if(paralMergeLvl > 0 && cuPartMode != PART_2Nx2N && predCuSize <= 8) then
			nPSW := max(nPSW, nPSH);
			nPSH := nPSW;
			cuPartMode := PART_2Nx2N;
			partAddr := partAddr1stPu;
		end
		numCandidate := 0;
		getNeighbAddr(ABOVE, true, dependSlc, false);
		locationUp := neighbLocation;
		getNeighbAddr(LEFT, true, dependSlc, false);
		locationLeft := neighbLocation;

		//A1
		if(not (cuPartMode = PART_Nx2N || cuPartMode = PART_nLx2N ||
			cuPartMode = PART_nRx2N) || partIdx!=1) then
			isAvailableA1 := getIsAvailable() and
				((locationLeft[0] >> paralMergeLvl) != (partAddr[0] >> paralMergeLvl) ||
			     (locationLeft[1] >> paralMergeLvl) != (partAddr[1] >> paralMergeLvl));
			getNeighbourMv(false, 0, false);
			numNeighbSelect := if(predFlag) then 1 else 0 end;
		end

		//B1
		if( not(cuPartMode = PART_2NxN || cuPartMode = PART_2NxnU ||
			cuPartMode = PART_2NxnD) || partIdx != 1) then

			tryGetNeighbour := not isAvailableA1 || hasNotSameMvComp(locationUp, locationLeft);
			neighbLocation := locationUp;
			isAvailableB1 := getIsAvailable() and
				((locationUp[0] >> paralMergeLvl) != (partAddr[0] >> paralMergeLvl) ||
			     (locationUp[1] >> paralMergeLvl) != (partAddr[1] >> paralMergeLvl));
			if(tryGetNeighbour) then
				getNeighbourMv(false, 0, false);
				numNeighbSelect := numNeighbSelect +
					if(predFlag) then 1 else 0 end;
			end
		end

		//B0
		getNeighbAddr(ABOVE_RIGHT, true, dependSlc, false);
		tryGetNeighbour := not isAvailableB1 || hasNotSameMvComp(neighbLocation, locationUp);
		if(tryGetNeighbour) then
			getNeighbourMv(false, 0, false);
			numNeighbSelect := numNeighbSelect +
				if(predFlag) then 1 else 0 end;
		end

		//A0
		getNeighbAddr(LEFT_BOTTOM, true, dependSlc, false);
		tryGetNeighbour := not isAvailableA1 || hasNotSameMvComp(neighbLocation, locationLeft);
		if(tryGetNeighbour) then
			getNeighbourMv(false, 0, false);
			numNeighbSelect := numNeighbSelect +
				if(predFlag) then 1 else 0 end;
		end

		if(numNeighbSelect<4) then
			getNeighbAddr(ABOVE_LEFT, true, dependSlc, false);
			tryGetNeighbour := not isAvailableB1 || hasNotSameMvComp(neighbLocation, locationUp);
			tryGetNeighbour := tryGetNeighbour &&
				(not isAvailableA1 || hasNotSameMvComp(neighbLocation, locationLeft));
			if(tryGetNeighbour) then
				getNeighbourMv(false, 0, false);
			end
		end
		if enTmpMvp then
			getColCandidate(true, 0);
		end
 		if(isBSlice) then
			biPredMergeCand(5);
		end
		foreach int i in numCandidate .. 4
		do
			mvPred[i] := [[0,0],[0,0]];
			refIdxPred[i] := [refIdxVal, refIdxVal];
			if(refIdxVal = minSizeRefListX-1) then
				refIdxVal := 0;
			else
				refIdxVal := refIdxVal + 1;
			end
		end
		nPSH := nPSHInit;
		nPSW := nPSWInit;
		cuPartMode := cuPartModeInit;
		partAddr := partAddrInit;
	end

	checkMergeIdx.isEqToMin1: action SyntaxElem:[se] repeat 4 ==>
	guard
		mergeIdx = -1
	var
		int refIdx[2] = [se[2],se[3]],
		int numNeighbSelect
	do
		if DEBUG_SyntaxElem then
			println("mvp_l0 = "+se[0]+" : mvp_l1 = "+se[1]);
			println("refIdx_l0 = "+se[2]+" : refIdx_l1 = "+se[3]);
		end
		saveRefIdx(refIdx);
		mvpIdx := [se[0], se[1]];
		foreach int list in 0 .. 1
		do
			numCandidate := 0;

			//Left neighbours
			getNeighbAddr(LEFT_BOTTOM, false, dependSlc, false); // A0
			getNonMergedNeighbourMv(list);
			if(not predFlag) then
				getNeighbAddr(LEFT, false, dependSlc, false); // A1
				getNonMergedNeighbourMv(list);
			end
			if(not predFlag) then
				getNeighbAddr(LEFT_BOTTOM, false, dependSlc, false); // A0'
				getNonMergedScaledMv(list);
			end
			if(not predFlag) then
				getNeighbAddr(LEFT, false, dependSlc, false); // A1'
				getNonMergedScaledMv(list);
			end
			numNeighbSelect := if(predFlag) then 1 else 0 end;

			//Above neighbours
			getNeighbAddr(ABOVE_RIGHT, false, dependSlc, false); // B0
			getNonMergedNeighbourMv(list);
			if(not predFlag) then
				getNeighbAddr(ABOVE, false, dependSlc, false); // B1
				getNonMergedNeighbourMv(list);
			end
			if(not predFlag) then
				getNeighbAddr(ABOVE_LEFT, false, dependSlc, false); // B2
				getNonMergedNeighbourMv(list);
			end
			numNeighbSelect := numNeighbSelect +
				if(predFlag) then 1 else 0 end;
			if(numNeighbSelect != 2) then
				predFlag := isInter(partAddr[0] - 1, partAddr[1] + nPSH) ||
					isInter(partAddr[0] - 1, partAddr[1] + nPSH - 1);
			else
				predFlag := true;
			end
			if(not predFlag) then
				getNeighbAddr(ABOVE_RIGHT, false, dependSlc, false); // B0'
				getNonMergedScaledMv(list);
			end
			if(not predFlag) then
				getNeighbAddr(ABOVE, false, dependSlc, false); // B1'
				getNonMergedScaledMv(list);
			end
			if(not predFlag) then
				getNeighbAddr(ABOVE_LEFT, false, dependSlc, false); // B2'
				getNonMergedScaledMv(list);
			end
			if enTmpMvp then
				getColCandidate(false, list);
			end
			foreach int i in numCandidate .. 4
			do
				mvPred[i][list][0] := 0;
				mvPred[i][list][1] := 0;
			end
		end
	end

	getMvd: action SyntaxElem:[mvd] repeat 4 ==> IsBiPredOrLx:[isBiPredOrLx],
		IsReadOrNewSlice:[1], Mv:[mvToSend] repeat 2, RefIdx:[refIdxToSend],
		PocRef:[pocToSend], PredCuSize:[cuSize] repeat 2
	var
		int idxMvInfo,
		int(size=16) mv[2][2],
		int refIdx[2],
		int(size=32) mvToSend[2],
		int refIdxToSend,
		int(size=16) pocToSend
	do
		if DEBUG_SyntaxElem then
			println("mvd_0_x = "+mvd[0]+" : mvd_0_y = "+mvd[1]);
			println("mvd_1_x = "+mvd[2]+" : mvd_1_y = "+mvd[3]);
		end
		foreach int i in 0 .. 1
		do
			idxMvInfo :=
				if(mergeIdx >= 0) then
					mergeIdx
				else
					mvpIdx[i]
				end;
			if idxMvInfo > -1 and idxMvInfo < 5 then
				if(mvPred[idxMvInfo][i][0] >  32767) then mvPred[idxMvInfo][i][0] :=  32767; end
				if(mvPred[idxMvInfo][i][0] < -32768) then mvPred[idxMvInfo][i][0] := -32768; end
				if(mvPred[idxMvInfo][i][1] >  32767) then mvPred[idxMvInfo][i][1] :=  32767; end
				if(mvPred[idxMvInfo][i][1] < -32768) then mvPred[idxMvInfo][i][1] := -32768; end
				mv[i][0] := mvPred[idxMvInfo][i][0] + mvd[2*i];
				mv[i][1] := mvPred[idxMvInfo][i][1] + mvd[2*i + 1];
				refIdx[i] := refIdxPred[idxMvInfo][i];
			end
		end
		if(mergeIdx = -1) then
			refIdx := [refIdxRef[currIdx][partAddr[0]][partAddr[1]][i]:
				for int i in 0 .. 1];
		end
		if(not isBSlice || refIdx[0]!=-1 && refIdx[1] !=-1 &&
			predCuSize = 8 && (cuSize[0] < 8 || cuSize[1]<8)) then
			refIdx[1] := -1;
			mv[1][0] := 0;
			mv[1][1] := 0;
		end
		if(refIdx[0] = -1) then
			mv[0][0] := 0;
			mv[0][1] := 0;
		end
		if(refIdx[1] = -1) then
			mv[1][0] := 0;
			mv[1][1] := 0;
		end
		saveRefIdx(refIdx);
		saveMvComponent(mv);
		if(refIdx[0]!= -1 and refIdx[1]!= -1) then
			isBiPredOrLx := BI_PRED;
		else if(refIdx[0] != -1) then
			isBiPredOrLx := PRED_L0;
		else
			isBiPredOrLx := PRED_L1;
		end end
		if(refIdx[0]!=-1) then
			refIdxToSend := refIdx[0];
			pocToSend := pocRefListX[0][refIdx[0]];
			mvToSend := [mv[0][i] + (cuAddr[i]<<2): for int i in 0 ..1];
		else
			refIdxToSend := refIdx[1];
			pocToSend    := pocRefListX[1][refIdx[1]];
			mvToSend     := [mv[1][i] + (cuAddr[i]<<2): for int i in 0 ..1];
		end
		if DEBUG_Mv then
			println("mv = "+mvToSend[0]+", "+mvToSend[1]);
		end
	end

	getRps.launch: action RpsPoc:[numPic]==>
	guard
		nbList < 5
	do
		sizeOfList := numPic;
		if DEBUG_RpsPoc then
			println("RefPocSize["+nbList+"] = "+sizeOfList);
		end
	end

	getRps.done: action ==>
	guard
		nbList = 5
	do
		foreach int i in 0 .. 16
		do
			isRef[i] := isRef[i] and isStillRef[i];
		end
		isRef[currIdx] := true;
		minSizeRefListX := 31;
	end

	getRpsPoc.launch: action RpsPoc:[pocVal] ==>
	guard
		sizeOfList > 0
	do
		sizeOfList := sizeOfList - 1;
		if DEBUG_RpsPoc then
			println("RefPoc = "+pocVal);
		end
		foreach int i in 0 .. 16
		do
			if(pocRef[i] = pocVal)then
				isStillRef[i] := true;
			end
		end
	end

	getRpsPoc.done: action ==>
	guard
		sizeOfList = 0
	do
		nbList := nbList + 1;
	end

	getSizeRefList.launch: action RefList:[sizeList] ==>
	guard
		listIdx < 2
	do
		listSize := sizeList;
		minSizeRefListX := min(sizeList, minSizeRefListX);
		sizeIdx := 0;
		if DEBUG_RefList then
			println("numRefIdxLxAct["+listIdx+"] = "+listSize);
		end		
	end

	getSizeRefList.done: action ==>
	guard
		listIdx = 2
	do
		useLN := (maxPoc>pocRef[currIdx]) || not isBSlice;
		
		colPoc := pocRefListX[colocFromL0^1][colRefIdx];
		colRefIdx := 0;
		foreach int i in 0 .. 16
		do
			if(isRef[i] && pocRef[i] = colPoc) then
				foreach int list in 0 .. 1
				do
					foreach int j in 0 .. 15
					do
						colRefPoc[list][j] := pocRefList[i][slcIdx][list][j];
					end
				end
				colRefIdx := i;
			end
		end
	end

	getRefList.launch: action RefList:[refPoc] ==>
	guard
		sizeIdx < listSize
	do
		if DEBUG_RefList then
			println("RefList["+listIdx+"]["+sizeIdx+"] = "+refPoc);
		end
		maxPoc := max(maxPoc, refPoc);
		pocRefListX[listIdx][sizeIdx] := refPoc;
		pocRefList[currIdx][slcIdx][listIdx][sizeIdx] := refPoc;
		sizeIdx := sizeIdx + 1;
	end

	getRefList.done: action ==>
	guard
		sizeIdx = listSize
	do
		listIdx := listIdx + 1;
	end

	send2ndMv.launch: action ==> PocRef:[pocToSend], RefIdx:[refIdxToSend],
		Mv:[mvToSend] repeat 2, PredCuSize:[cuSize] repeat 2
	guard
		isBiPredOrLx = BI_PRED
	var
		int refIdxToSend,
		int mvToSend[2],
		int(size=16) pocToSend
	do
		refIdxToSend := refIdxRef[currIdx][partAddr[0]][partAddr[1]][1];
		mvToSend := [mvRef[currIdx][partAddr[0]][partAddr[1]][1][i] +
			(cuAddr[i]<<2): for int i in 0 .. 1];
		pocToSend := pocRefListX[1][refIdxToSend];
		if DEBUG_Mv then
			println("mv = "+mvToSend[0]+", "+mvToSend[1]);
		end		
	end

	send2ndMv.skip: action ==>
	guard
		isBiPredOrLx != BI_PRED
	end

	schedule fsm GetPartMode:
		GetPartMode (isNewSlice       )--> CheckIndepSlc;
		GetPartMode (getPartMode      )--> GetCuInfo;

		CheckIndepSlc(checkDepSlc.isTrue  )--> GetPartMode;
		CheckIndepSlc(checkDepSlc.isFalse )--> GetTilesCoord;

		GetTilesCoord (getTilesCoord.launch )--> GetTilesCoord;
		GetTilesCoord (getTilesCoord.done   )--> GetRps;

		GetRps (getRps.launch )--> GetRpsPoc;
		GetRps (getRps.done   )--> GetSizeRefList;

		GetRpsPoc (getRpsPoc.launch )--> GetRpsPoc;
		GetRpsPoc (getRpsPoc.done   )--> GetRps;

		GetSizeRefList (getSizeRefList.launch )--> GetRefList;
		GetSizeRefList (getSizeRefList.done   )--> GetPartMode;

		GetRefList (getRefList.launch )--> GetRefList;
		GetRefList (getRefList.done   )--> GetSizeRefList;

		GetCuInfo   (getCuInfo.launch )--> GetCuMode;
		GetCuInfo   (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotInter )--> GetCuInfo;
		GetCuMode (getCuMode.isInter    )--> CheckMergeIdx;

		CheckMergeIdx (checkMergeIdx )--> GetMvd;
		GetMvd        (getMvd        )--> Send2ndMv;
		Send2ndMv     (send2ndMv     )--> GetCuInfo;
	end
end