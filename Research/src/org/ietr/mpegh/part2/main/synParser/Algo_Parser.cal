package org.ietr.mpegh.part2.main.synParser;

import  std.util.Math.*;
import  std.stdio.Source.*;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  org.sc29.wg11.common.CabacDecodeBinFunction.*;
import  devel.org.sc29.wg11.mpegh.part2.main.synParser.Algo_ParserUtils.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacDecodeBinFunction.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacContextConstantHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacContextFunctionHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacParserFunctionHEVC.*;

actor Algo_Parser (uint TILE_INDEX, uint TILE_SPLIT_ENABLE) 
// TilesInfo[0]: number of tiles to decode
// TilesInfo[i>0]: increasing indexes of tiles  
				uint(size= 8) byte
				==>
				uint(size=16) CUInfo,
				uint(size= 6) IntraPredMode,
				//FIXME default value
				uint(size=16) SliceAddr,
				uint(size=16) TilesCoord,
				uint(size=16) RealTilesCoord,
				uint(size=8)  LcuSizeMax,
				uint(size= 4) PartMode,
                uint(size=2)  IsPicSlcLcu,
                uint(size=2)  LFAcrossSlcTile,
				uint(size=16) PictSize,
				 int(size=16) Poc,
				 int(size= 9) SaoSeLuma,
				 int(size= 9) SaoSeChromaU,
				 int(size= 9) SaoSeChromaV,
				uint(size= 8) SEI_MD5,
				uint(size= 2) SliceType,
				bool          SplitTransform,
				 int(size= 8) TUSize,
				 int(size=16) Coeff,
				bool 		  StrongIntraSmoothing,
				uint(size=14) DispCoord,
				uint(size=9)  PicSizeInMb,
				uint(size= 5) NumRefIdxLxActive,
				uint(size= 4) RefPicListModif,
				 int(size=16) RefPoc,
				 int(size=16) MvPredSyntaxElem,
				bool Cbf,
				bool DBFDisable,
				 int(size=8)  DbfSe,
				 int(size=16) WeightedPredLuma,
				 int(size=16) WeightedPredChroma,
				uint(size=16) TileSize,
                uint(size=16) TileCUInfo,
                 int(size= 8) Qp
				 
:
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	uint(size= 8) se_idx;
	uint(size=32) cnt_i;
	uint(size=10) sps_id;
	uint(size=10) pps_id;
	uint(size= 8) localizeAEB := 0;
	uint NUM_ENTRY_MAX = 64;
	uint entryOffsetsTab[NUM_ENTRY_MAX];
	//uint(size=8) curr_Tile := TilesInfo[1];
	bool byPassFlag := false;
	uint(size=8) TilesInfo[2];
	
	
	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/
	
	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
 	uint counterByte := 0;
 	action byte:[ b ] ==>
	guard 
		not isFifoFull(fifo)
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
            counterByte := counterByte + 1; //localizeAEB := localizeAEB >> 1;
		if b != EPR_VALUE or zeroByte != 3 then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		else 
            	if b = EPR_VALUE then //println("AntiEmulationByte");
				//localizeAEB := localizeAEB + 128;
				//println("localize AEB = " + localizeAEB);
			end
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNIT                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * byte_align_a
	 *************************************************************************/	
	byte_align_a : action ==>
	guard
		isFifoFull(fifo)
	do
        	byte_align(fifo); //localizeAEB := localizeAEB >> 1;
	end 	
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode(fifo) and isFifoFull(fifo)
   	do
		flushBits( 8, fifo );
		if DEBUG_BITSTREAM then		
  			println("start_code.search");
   		end
	end
	start_code.done: action ==>
	guard
		IsStartCode(fifo) and isFifoFull(fifo)
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/		
        uint temporal_id := 0;
	uint(size= 6) nal_unit_type;
	
	read_nal_unit_header : action ==> 
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
            	flushBits_name(1, fifo,
            	"forbidden_zero_bit                      ");
            	vld_u_name(6, fifo, res,
            	"nal_unit_type                           ");
			nal_unit_type := res[0];
            	flushBits_name(6, fifo,
            	"nuh_reserved_zero_6bits                 ");
            	vld_u_name(3, fifo, res,
            	"nuh_temporal_id_plus1                   ");
		else
			flushBits( 1, fifo );
			vld_u(  6, fifo, res);
			nal_unit_type := res[0];
			flushBits( 6, fifo  );
			vld_u(  3, fifo, res); 
            	temporal_id := res[0] - 1;
		end
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.VPS_header
	 *************************************************************************/
	look_for.VPS_header: action ==>
	guard
		nal_unit_type = NAL_VPS
	do
		if DEBUG_PARSER then
			println("=========== Video Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.SEI_header
	 *************************************************************************/
	look_for.SEI_header: action ==>
	guard
		nal_unit_type = NAL_SEI_PREFIX or nal_unit_type = NAL_SEI_SUFFIX
	do
		if DEBUG_PARSER then
			println("=========== SEI message ===========");
		end
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nal_unit_type = NAL_TRAIL_R    or
		 nal_unit_type = NAL_TSA_N      or
		 nal_unit_type = NAL_TSA_R      or
		 nal_unit_type = NAL_TRAIL_N    or
		 nal_unit_type = NAL_STSA_N		or
		 nal_unit_type = NAL_STSA_R		or
		 nal_unit_type = NAL_RADL_N		or
		 nal_unit_type = NAL_RADL_R		or
		 nal_unit_type = NAL_RASL_N		or
		 nal_unit_type = NAL_RASL_R		or
		 nal_unit_type = NAL_IDR_N_LP	or
		 nal_unit_type = NAL_BLA_W_LP   or
         nal_unit_type = NAL_BLA_W_RADL or
         nal_unit_type = NAL_BLA_N_LP   or
         nal_unit_type = NAL_IDR_W_DLP  or
         nal_unit_type = NAL_CRA_NUT    or
         nal_unit_type = NAL_RASL_R)
	do
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Video Parameter Set HEADER           *********************
	 **************************************************************************
	 *************************************************************************/
    uint(size= 3) vps_max_sub_layers_minus1;
    uint(size= 6) vps_max_nuh_reserved_zero_layer_id;
    uint(size= 1) vps_timing_info_present_flag;
    uint(size=10) vps_num_op_sets_minus1;
    uint(size=10) vps_num_hrd_parameters;

	/**************************************************************************
	 * read_VPS_Header.se_idx_1
	 *************************************************************************/
	read_VPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  4, fifo, res, "vps_video_parameter_set_id              ");
		vld_u_name(  2, fifo, res, "vps_reserved_three_2bits                ");
		vld_u_name(  6, fifo, res, "vps_reserved_zero_6bits                 ");
		vld_u_name(  3, fifo, res, "vps_max_sub_layers_minus1               ");
        vps_max_sub_layers_minus1 := res[0];
        vld_u_name(  1, fifo, res, "vps_temporal_id_nesting_flag            ");
        vld_u_name( 16, fifo, res, "vps_reserved_ffff_16bits                ");
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_2
	 *************************************************************************/
	read_VPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
            	vld_u_name(2, fifo, res,
            	"XXX_profile_space[]                     ");
            	vld_u_name(1, fifo, res,
            	"XXX_tier_flag[]                         ");
            	vld_u_name(5, fifo, res,
            	"XXX_profile_idc[]                       ");
	        foreach int i in 0 .. 31 do
            		vld_u_name(1, fifo, res,
            		"XXX_profile_compatibility_flag[][j]     ");
			end
            	vld_u_name(1, fifo, res,
            	"general_progressive_source_flag         ");
            	vld_u_name(1, fifo, res,
            	"general_interlaced_source_flag          ");
            	vld_u_name(1, fifo, res,
            	"general_non_packed_constraint_flag      ");
            	vld_u_name(1, fifo, res,
            	"general_frame_only_constraint_flag      ");
		end
        se_idx := se_idx + 1;
	end
    /**************************************************************************
     * read_VPS_Header.se_idx_3
     *************************************************************************/
	read_VPS_Header.se_idx_3 : action ==>
    guard
        se_idx = 3 and isFifoFull(fifo)
    var
        bool profile_present_flag = true,
        uint(size = 32) res[1]
    do
        if (profile_present_flag) then
            vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[0..15]         ");
            vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[16..31]        ");
            vld_u_name( 12, fifo, res, "XXX_reserved_zero_44bits[32..43]        ");
        end
        vld_u_name(  8, fifo, res, "general_level_idc                       ");
        cnt_i  := 0;  
        se_idx := se_idx + 1;
    end
	/**************************************************************************
	 * read_VPS_Header.se_idx_4
	 *************************************************************************/
	bool profile_present_flag := true;
	bool sub_layer_profile_present_flag;
	bool sub_layer_level_present_flag;
		
	read_VPS_Header.se_idx_4.loop1 : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		cnt_i < vps_max_sub_layers_minus1      
	var
		uint(size = 32) res[1]
	do
        res[0] := 0;
        if profile_present_flag then
            vld_u_name(  1, fifo, res, "sub_layer_profile_present_flag[i]       ");
        end
        sub_layer_profile_present_flag := (res[0] = 1);
        vld_u_name(  1, fifo, res, "sub_layer_level_present_flag[i]         ");
        sub_layer_level_present_flag := (res[0] = 1);
        cnt_i := cnt_i + 1;
    end
    
    read_VPS_Header.se_idx_4.insertedCond : action ==>
	guard
		se_idx = 40 and isFifoFull(fifo)
	do
        if (vps_max_sub_layers_minus1 > 0) then
        	foreach int k in vps_max_sub_layers_minus1 .. 7 do
        		flushBits_name( 2, fifo,    "reserved_zero_2bits[ i ]                ");
        	end
        end
        se_idx := 41;
    end
   
    read_VPS_Header.se_idx_4.loop2 : action ==>
	guard
		se_idx = 41 and isFifoFull(fifo),
		cnt_i < vps_max_sub_layers_minus1      
	var
		uint(size = 32) res[1]
	do
	    if (profile_present_flag and sub_layer_profile_present_flag) then
			vld_u_name(  2, fifo, res, "sub_layer_profile_space[i]              ");
			vld_u_name(  1, fifo, res, "sub_layer_tier_flag[i]                  ");
			vld_u_name(  5, fifo, res, "sub_layer_profile_idc[i]                ");
            foreach int j in 0 .. 31 do
	        		vld_u_name(1, fifo, res,
	        		"sub_layer_profile_compatibility_flags[i][j]");
            end
	        	flushBits_name(16, fifo,
	        	"sub_layer_reserved_zero_16bits[i]         ");
        end
        if (sub_layer_level_present_flag) then
			vld_u_name(  1, fifo, res, "sub_layer_level_idc[i]                  ");
	    end
	    cnt_i := cnt_i + 1;
	end
    read_VPS_Header.se_idx_4.loop1End : action ==>
    guard
        se_idx = 4 ,
        cnt_i = vps_max_sub_layers_minus1
        do
		cnt_i  := 0;
        se_idx := 40;
    end
    
    read_VPS_Header.se_idx_4.loop2End : action ==>
    guard
        se_idx = 41 ,
        cnt_i = vps_max_sub_layers_minus1
    do
    	se_idx := 42;
    	cnt_i := 0;
    end
    
    read_VPS_Header.se_idx_4.decodeInfoPresentFlag : action ==>
    guard
        se_idx = 42 and isFifoFull(fifo)
    var
        uint(size=32) res[1]
    do
        vld_u_name(  1, fifo, res, "vps_sub_layer_ordering_info_present_flag");
        if res[0] = 1 then
            cnt_i  := 0;
        else
            cnt_i  := vps_max_sub_layers_minus1;
        end
        se_idx := 5;
    end
    /**************************************************************************
     * read_VPS_Header.se_idx_5
     *************************************************************************/
    read_VPS_Header.se_idx_5.loop11 : action ==>
    guard
        se_idx = 5 and isFifoFull(fifo),
        cnt_i < vps_max_sub_layers_minus1 +1      
    var
        int(size=32) res[1]
    do
        vld_ue_name(    fifo, res, "vps_max_dec_pic_buffering[i]            ");
        vld_ue_name(    fifo, res, "vps_num_reorder_pics[i]                 ");
        vld_ue_name(    fifo, res, "vps_max_latency_increase[i]             ");
        cnt_i := cnt_i + 1;
    end
    read_VPS_Header.se_idx_5.loopEnd : action ==>
    guard
        se_idx = 5 and isFifoFull(fifo),
        cnt_i = vps_max_sub_layers_minus1 + 1
    var
        uint(size=32) res[1]
    do
        vld_u_name(  6, fifo, res, "vps_max_nuh_reserved_zero_layer_id      ");
        vps_max_nuh_reserved_zero_layer_id := res[0];
        vld_ue_name(    fifo, res, "vps_max_op_sets_minus1                  ");
        vps_num_op_sets_minus1 := res[0];
        cnt_i  := 1;
        cnt_i  := vps_num_op_sets_minus1 + 1; // TODO : bypass layer_id_included_flag()
        se_idx := 6;
    end
    /**************************************************************************
     * read_VPS_Header.se_idx_6
     *************************************************************************/
    read_VPS_Header.se_idx_6.loop : action ==>
    guard
        se_idx = 6 and isFifoFull(fifo),
        cnt_i <= vps_num_op_sets_minus1      
    var
        uint(size=32) res[1]
    do
        foreach int(size=8) i in 0 .. vps_max_nuh_reserved_zero_layer_id - 1 do
            vld_u_name(  1, fifo, res, "layer_id_included_flag[][i]             ");
        end
        cnt_i := cnt_i + 1;
    end
    read_VPS_Header.se_idx_6.loopEnd : action ==>
    guard
        se_idx = 6 and isFifoFull(fifo),
        cnt_i = vps_num_op_sets_minus1 + 1
    var
        uint(size=32) res[1]
    do
        vld_u_name(  1, fifo, res, "vps_timing_info_present_flag            "); 
        vps_timing_info_present_flag := res[0];
        if vps_timing_info_present_flag = 1 then
            se_idx := se_idx + 1;
        else
            se_idx := 10;
        end
    end
    /**************************************************************************
     * read_VPS_Header.se_idx_7
     *************************************************************************/
    read_VPS_Header.se_idx_7 : action ==>
    guard
        se_idx = 7 and isFifoFull(fifo)
    var
        uint(size=32) res[1]
    do
        vld_u_name( 32, fifo, res, "vps_num_units_in_tick                   ");
        vld_u_name( 32, fifo, res, "vps_time_scale                          ");
        se_idx := se_idx + 1;
    end
    /**************************************************************************
     * read_VPS_Header.se_idx_8
     *************************************************************************/
    read_VPS_Header.se_idx_8 : action ==>
    guard
        se_idx = 8 and isFifoFull(fifo)
    var
        uint(size=32) res[1]
    do
        vld_u_name(  1, fifo, res, "vps_poc_proportional_to_timing_flag     ");
        if res[0] = 1 then
            vld_ue_name(    fifo, res, "vps_num_ticks_poc_diff_one_minus1       ");
        end
        vld_ue_name(    fifo, res, "vps_num_hrd_parameters                  ");
        vps_num_hrd_parameters := res[0];
        se_idx := se_idx + 1;
    end
    /**************************************************************************
     * read_VPS_Header.se_idx_9
     *************************************************************************/
    read_VPS_Header.se_idx_9.loop : action ==>
    guard
        se_idx = 9 and isFifoFull(fifo),
        cnt_i < vps_num_hrd_parameters      
    var
        uint(size=32) res[1],
        uint(size= 1) cprms_present_flag := 0
    do
        vld_ue_name(    fifo, res, "hrd_op_set_idx[i]                       ");
        if cnt_i > 0 then
            vld_u_name(  1, fifo, res, "cprms_present_flag[i]                   ");
            cprms_present_flag := res[0];
        end
        if cprms_present_flag = 1 then
            println("not support for vps_num_hrd_parameters != 0");
        end
        cnt_i := cnt_i + 1;
    end
    read_VPS_Header.se_idx_9.loopEnd : action ==>
    guard
        se_idx = 9,
        cnt_i = vps_num_hrd_parameters
    do
        se_idx := se_idx + 1;
    end
	/**************************************************************************
	 * read_VPS_Header_done
	 *************************************************************************/	
	read_VPS_Header_done : action ==>
	guard
		se_idx = 10 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
	        vld_u_name(1, fifo, res,
	        "vps_extension_flag                      ");
		if res[0] = 1 then
            println("not support for vps_extension_flag != 0");
		end
	end 	
	/**************************************************************************
	 **************************************************************************
	 ********        SEI message                          *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SEI_Header.se_idx_1
	 *************************************************************************/
 	uint(size=16) sei_payloadType;
 	uint(size=16) sei_payloadSize;
 	uint(size=16) sei_payloadPosition;
 	uint(size= 8) sei_idx;
	/**************************************************************************
	 * read_SEI_Header.init
	 *************************************************************************/
	read_SEI_Header.init : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	do
		sei_payloadType     := 0;
		sei_payloadSize     := 0;
		sei_payloadPosition := 0;
		se_idx              := se_idx + 1;
		sei_idx             := 1;
	end
	/**************************************************************************
	 * read_SEI_Header.payload_type
	 *************************************************************************/
	read_SEI_Header.payload_type : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "payload_type                            ");
		sei_payloadType := sei_payloadType + res[0];
		if res[0] != 0xFF then
			se_idx := se_idx + 1;
		end
	end
	/**************************************************************************
	 * read_SEI_Header.payload_size
	 *************************************************************************/
	read_SEI_Header.payload_size : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
	        vld_u_name(8, fifo, res,
	        "payload_size                            ");
		sei_payloadSize := sei_payloadSize + res[0];
	        if res[0] != 0xFF then // sei_payload( payloadType, payloadSize )
			se_idx := se_idx + 1;
		end
	end
	/**************************************************************************
	 * read_SEI_Header.decoded_picture_hash
	 *************************************************************************/
 	uint(size= 8) sei_cIdx;
 	uint(size= 8) sei_i;
 	uint(size= 8) sei_hash_type;
	read_SEI_Header.decoded_picture_hash.init : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		sei_idx = 1 and sei_payloadType = 132
	var
		uint(size=32) res[1]
	do
		if DEBUG_PARSER then
			println("=========== Decoded picture hash SEI message ===========");
		end
		vld_u_name(  8, fifo, res, "hash_type                               ");
		sei_payloadPosition := sei_payloadPosition + 8;			
		sei_hash_type       := res[0];
		sei_cIdx            := 0;
		sei_i               := 0;
		sei_idx             := sei_idx + 1;
	end
	read_SEI_Header.decoded_picture_hash.loop : action ==> SEI_MD5:[res[0]]
	guard
		se_idx = 4 and isFifoFull(fifo),
		sei_idx = 2 and sei_payloadType = 132,
		sei_cIdx < 3, /*if sps_chroma_format_idc[sps_id] = 0 then 1 else 3 end,*/
		sei_i    < 16
	var
		uint(size=32) res[1]
	do
		if sei_hash_type = 0 then
			vld_u_name(  8, fifo, res, "picture_md5                             ");
			sei_payloadPosition := sei_payloadPosition +  8;
			sei_i               := sei_i + 1;		
	        	elsif sei_hash_type = 1 then vld_u_name(16, fifo, res,
	        	"picture_crc                             ");
			sei_payloadPosition := sei_payloadPosition + 16;			
			sei_i               := 16;		
	        	elsif sei_hash_type = 2 then vld_u_name(32, fifo, res,
	        	"picture_checksum                        ");
			sei_payloadPosition := sei_payloadPosition + 32;			
			sei_i               := 16;		
		end
		if sei_i = 16 then
		    sei_i := 0;
			sei_cIdx := sei_cIdx + 1;
	        	if sei_cIdx = 3
	
	        	/*if sps_chroma_format_idc[sps_id] = 0 then 1 else 3 end*/
	        	then
				se_idx := se_idx + 1;
			end
		end 
	end
	/**************************************************************************
	 * read_SEI_Header.sei_payload_end
	 *************************************************************************/
	read_SEI_Header.sei_payload_end : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if not(isByteAlign(fifo) and sei_payloadPosition = (sei_payloadSize << 3)) then
//			if payload_extension_present( ) then
//				reserved_payload_extension_data
//			end
			vld_u_name(  1, fifo, res, "bit_equal_to_one                        ");			
			while not isByteAlign(fifo) do
				vld_u_name(  1, fifo, res, "bit_equal_to_zero                       ");			
			end
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SEI_Header.done
	 *************************************************************************/
	read_SEI_Header_done : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
    var
        uint(size=32) res[1]
   	do
   	    vld_u_name(  8, fifo, res, "rbsp_trailing_bits");
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	uint(size= 4) sps_max_sub_layers_minus1[NB_MAX_SPS];
	uint(size=16) sps_pic_width_in_luma_samples[NB_MAX_SPS];
    uint(size=16) sps_pic_height_in_luma_samples[NB_MAX_SPS];
    uint(size= 1) sps_separate_colour_plane_flag[NB_MAX_SPS];
	uint(size= 2) sps_chroma_format_idc[NB_MAX_SPS];
	
	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
	        vld_u_name(4, fifo, res,
	        "sps_video_parameter_set_id              ");
	        vld_u_name(3, fifo, res,
	        "sps_max_sub_layers_minus1               ");
		sps_max_sub_layers_minus1[sps_id] := res[0];
	        vld_u_name(1, fifo, res,
	        "sps_temporal_id_nesting_flag            ");
		se_idx := 20;
	end
    /**************************************************************************
     * read_SPS_Header.se_idx_20
     *************************************************************************/
   	read_SPS_Header.se_idx_20 : action ==>
	guard
		se_idx = 20 and isFifoFull(fifo)
   var
        bool profile_present_flag = true,
        uint(size = 32) res[1]
    do
        if (profile_present_flag) then
            vld_u_name(  2, fifo, res, "XXX_profile_space[]                     ");
            vld_u_name(  1, fifo, res, "XXX_tier_flag[]                         ");
            vld_u_name(  5, fifo, res, "XXX_profile_idc[]                       ");
            foreach int i in 0 .. 31 do
	        		vld_u_name(1, fifo, res,
	        		"XXX_profile_compatibility_flag[][j]     ");
            end
            vld_u_name(  1, fifo, res, "general_progressive_source_flag         ");
            vld_u_name(  1, fifo, res, "general_interlaced_source_flag          ");
            vld_u_name(  1, fifo, res, "general_non_packed_constraint_flag      ");
            vld_u_name(  1, fifo, res, "general_frame_only_constraint_flag      ");
        end
        se_idx := se_idx + 1;
	end
    /**************************************************************************
     * read_SPS_Header.se_idx_20
     *************************************************************************/
    read_SPS_Header.se_idx_21 : action ==>
    guard
        se_idx = 21 and isFifoFull(fifo)
	   var
        bool profile_present_flag = true,
        uint(size = 32) res[1]
    do
        if (profile_present_flag) then
            vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[0..15]         ");
            vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[16..31]        ");
            vld_u_name( 12, fifo, res, "XXX_reserved_zero_44bits[32..43]        ");
        end
        vld_u_name(  8, fifo, res, "general_level_idc                       ");
        cnt_i  := 0;  
        se_idx := se_idx + 1;
    end
	/**************************************************************************
	 * read_SPS_Header.se_idx_22
	 *************************************************************************/
	bool sps_sub_layer_level_present_flag := false;
	bool sps_profile_present_flag := true;
	bool sps_sub_layer_profile_present_flag := false;
	
	read_SPS_Header.se_idx_22.loop1 : action ==>
	guard
		se_idx = 22 and isFifoFull(fifo),
		cnt_i < sps_max_sub_layers_minus1[sps_id]
	var
		uint(size = 32) res[1]
	do
        res[0] := 0;
        if sps_profile_present_flag then
            vld_u_name(  1, fifo, res, "sub_layer_profile_present_flag[i]       ");
        end
        sps_sub_layer_profile_present_flag := (res[0] = 1);
        vld_u_name(  1, fifo, res, "sub_layer_level_present_flag[i]         ");
        sps_sub_layer_level_present_flag := (res[0] = 1);
        cnt_i := cnt_i + 1;
    end
    
    read_SPS_Header.se_idx_22.loopEnd1 : action ==>
    guard
        se_idx = 22 and isFifoFull(fifo),
        cnt_i = sps_max_sub_layers_minus1[sps_id]
    do
		cnt_i := 0;
		se_idx := 221;
	end
    
    read_SPS_Header.se_idx_22.indertedCond : action ==>
	guard
		se_idx = 221 and isFifoFull(fifo)
	do
		if sps_max_sub_layers_minus1[sps_id] > 0 then
			foreach int i in sps_max_sub_layers_minus1[sps_id] .. 7 do
	        		flushBits_name(2, fifo,
	        		"reserved_zero_2bits[i]                    ");
			end
		end
		se_idx := 222;
	end
	
	read_SPS_Header.se_idx_22.loop2 : action ==>
	guard
		se_idx = 222 and isFifoFull(fifo),
		cnt_i < sps_max_sub_layers_minus1[sps_id]
	var
		uint(size = 32) res[1]
	do
        if (sps_profile_present_flag and sps_sub_layer_profile_present_flag) then
            vld_u_name(  2, fifo, res, "sub_layer_profile_space[i]              ");
            vld_u_name(  1, fifo, res, "sub_layer_tier_flag[i]                  ");
            vld_u_name(  5, fifo, res, "sub_layer_profile_idc[i]                ");
            foreach int j in 0 .. 31 do
                vld_u_name(  1, fifo, res, "sub_layer_profile_compatibility_flags[i][j]");
            end
            flushBits_name(16, fifo,    "sub_layer_reserved_zero_16bits[i]         ");
        end
        if (sps_sub_layer_level_present_flag) then
            vld_u_name(  1, fifo, res, "sub_layer_level_idc[i]                  ");
        end
        cnt_i := cnt_i + 1;
    end
    read_SPS_Header.se_idx_22.loopEnd : action ==>
    guard
        se_idx = 222 and isFifoFull(fifo),
        cnt_i = sps_max_sub_layers_minus1[sps_id]
    do
		se_idx := 11;
	end
    /**************************************************************************
     * read_SPS_Header.se_idx_1_1
     *************************************************************************/
	read_SPS_Header.se_idx_1_1 : action ==>
	guard
		se_idx = 11 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "sps_seq_parameter_set_id                ");
		sps_id := res[0];
	        vld_ue_name(fifo, res,
	        "chroma_format_idc                       ");
		sps_chroma_format_idc[sps_id] := res[0]; 
		if res[0] = 3 then
	        	vld_u_name(1, fifo, res,
	        	"separate_colour_plane_flag              ");
            sps_separate_colour_plane_flag[sps_id] := res[0];
		end
	        vld_ue_name(fifo, res,
	        "pic_width_in_luma_samples               ");
		sps_pic_width_in_luma_samples[sps_id] := res[0];
	        vld_ue_name(fifo, res,
	        "pic_height_in_luma_samples              ");
        sps_pic_height_in_luma_samples[sps_id] := res[0];
		se_idx := 2;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	uint(size= 8) sps_log2_max_pic_order_cnt_lsb_minus4[NB_MAX_SPS];
	uint(size=32) max_poc_lsb[NB_MAX_SPS];
	int sps_bit_depth_luma_minus8[NB_MAX_SPS];
	int sps_bit_depth_chroma_minus8[NB_MAX_SPS];
	
	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=1)  conformance_window_flag
	do
        vld_u_name(  1, fifo, res, "conformance_window_flag                 ");
		conformance_window_flag := res[0];
		if conformance_window_flag = 1 then
	        	vld_ue_name(fifo, res,
	        	"conf_win_left_offset                    ");
	        	vld_ue_name(fifo, res,
	        	"conf_win_right_offset                   ");
	        	vld_ue_name(fifo, res,
	        	"conf_win_top_offset                     ");
	        	vld_ue_name(fifo, res,
	        	"conf_win_bottom_offset                  ");
		end
	        vld_ue_name(fifo, res,
	        "sps_bit_depth_luma_minus8                   ");
		sps_bit_depth_luma_minus8[sps_id] := res[0];
	        vld_ue_name(fifo, res,
	        "sps_bit_depth_chroma_minus8                 ");
		sps_bit_depth_chroma_minus8[sps_id] := res[0];
	        vld_ue_name(fifo, res,
	        "log2_max_pic_order_cnt_lsb_minus4       ");
		sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] := res[0];
	        max_poc_lsb[sps_id] := 1 <<
	        (sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4);
	        vld_u_name(1, fifo, res,
	        "sps_sub_layer_ordering_info_present_flag");
		if res[0] = 1 then
            cnt_i  := 0;
		else
            cnt_i  := sps_max_sub_layers_minus1[sps_id];
		end
		se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo),
		cnt_i <= sps_max_sub_layers_minus1[sps_id]
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "sps_max_dec_pic_buffering               "); 
		vld_ue_name(    fifo, res, "sps_num_reorder_pics                    "); 
		vld_ue_name(    fifo, res, "sps_max_latency_increase                "); 
		cnt_i := cnt_i + 1;
	end 

	read_SPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3,
		cnt_i = sps_max_sub_layers_minus1[sps_id] + 1
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/
        uint(size= 8) sps_log2_min_coding_block_size[NB_MAX_SPS];
	uint(size= 8) sps_log2_diff_max_min_coding_block_size[NB_MAX_SPS];
        uint(size= 8) sps_log2_min_transform_block_size[NB_MAX_SPS];
	uint(size= 8) sps_log2_diff_max_min_transform_block_size[NB_MAX_SPS];
	uint(size=16) sps_maxCUWidth[NB_MAX_SPS];
	uint(size=16) sps_addCUDepth[NB_MAX_SPS];

	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_min_coding_block_size_minus3       ");
                sps_log2_min_coding_block_size[sps_id] := res[0] + 3;
	        vld_ue_name(fifo, res,
	        "log2_diff_max_min_coding_block_size     ");
		sps_log2_diff_max_min_coding_block_size[sps_id] := res[0];
	        vld_ue_name(fifo, res,
	        "log2_min_transform_block_size_minus2    ");
		sps_log2_min_transform_block_size[sps_id] := res[0] + 2;
	        vld_ue_name(fifo, res,
	        "log2_diff_max_min_transform_block_size  ");
		sps_log2_diff_max_min_transform_block_size[sps_id] := res[0];
	        sps_maxCUWidth[sps_id] := 1 << (Log2MinCbSize +
	        sps_log2_diff_max_min_coding_block_size[sps_id]);
    	sps_addCUDepth[sps_id] := 0;
	        while ((sps_maxCUWidth[sps_id] >>
	        sps_log2_diff_max_min_coding_block_size[sps_id]) > (1 <<
	        (sps_log2_min_transform_block_size[sps_id] +
	        sps_log2_diff_max_min_coding_block_size[sps_id]))) do
        	sps_addCUDepth[sps_id] := sps_addCUDepth[sps_id] + 1;
    	end
		se_idx := se_idx + 1;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/	 	
	uint(size= 8) sps_max_transform_hierarchy_depth_inter[NB_MAX_SPS];
	uint(size= 8) sps_max_transform_hierarchy_depth_intra[NB_MAX_SPS];
	uint(size= 1) sps_scaling_list_enabled_flag[NB_MAX_SPS];
	    int(size=32) ctb_width;
	    int(size=32) min_cb_width;
   
	
	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_inter     ");
		sps_max_transform_hierarchy_depth_inter[sps_id] := res[0];
	        vld_ue_name(fifo, res,
	        "max_transform_hierarchy_depth_intra     ");
		sps_max_transform_hierarchy_depth_intra[sps_id] := res[0];
	        vld_u_name(1, fifo, res,
	        "sps_scaling_list_enabled_flag           ");
   		sps_scaling_list_enabled_flag[sps_id] := res[0];

	        min_cb_width := sps_pic_width_in_luma_samples[sps_id] >>
	        sps_log2_min_coding_block_size[sps_id];


   		if sps_scaling_list_enabled_flag[sps_id] = 1 then
			se_idx := 60;
		else
			se_idx := 6;
		end
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/
	uint(size= 1) sps_sample_adaptive_offset_enabled_flag[NB_MAX_SPS];
	uint(size= 8) sps_num_short_term_ref_pic_sets[NB_MAX_SPS];
	uint(size= 1) sps_pcm_enabled_flag[NB_MAX_SPS];
	uint(size= 1) amp_enabled_flag;
	uint(size= 8) sps_sl[NB_MAX_SPS][4][6][64];
    uint(size= 8) sps_sl_dc[NB_MAX_SPS][2][6];
    int sps_size_id := 0;
    int sps_size_id_matrixCase;
    int sps_matrix_id := 0;
    int sps_coef_num :=0;
    int sps_pos;
    int sps_scaling_list_delta_coef;
    int sps_next_coef;
	
	read_SPS_Header.se_idx_60 : action ==>
	guard
		se_idx = 60 and isFifoFull(fifo) 
	var
		uint(size=32) res[1],
		uint(size= 1) sps_scaling_list_data_present_flag
   	do    
	        foreach int matrixId in 0 .. 5 do // 4x4 default is 16
	        foreach int i in 0 .. 15 do
	        	sps_sl[sps_id][0][matrixId][i] := 16;
	        end
	        sps_sl_dc[sps_id][0][matrixId] := 16; // default for 16x16
	        sps_sl_dc[sps_id][1][matrixId] := 16; // default for 32x32
   		end
   		foreach int i in 0 .. 63 do
   			sps_sl[sps_id][1][0][i] := default_scaling_list_intra[i];
   			sps_sl[sps_id][1][1][i] := default_scaling_list_intra[i];
   			sps_sl[sps_id][1][2][i] := default_scaling_list_intra[i];
   			sps_sl[sps_id][1][3][i] := default_scaling_list_inter[i];
   			sps_sl[sps_id][1][4][i] := default_scaling_list_inter[i];
   			sps_sl[sps_id][1][5][i] := default_scaling_list_inter[i];
   			sps_sl[sps_id][2][0][i] := default_scaling_list_intra[i];
   			sps_sl[sps_id][2][1][i] := default_scaling_list_intra[i];
   			sps_sl[sps_id][2][2][i] := default_scaling_list_intra[i];
   			sps_sl[sps_id][2][3][i] := default_scaling_list_inter[i];
   			sps_sl[sps_id][2][4][i] := default_scaling_list_inter[i];
   			sps_sl[sps_id][2][5][i] := default_scaling_list_inter[i];
   			sps_sl[sps_id][3][0][i] := default_scaling_list_intra[i];
   			sps_sl[sps_id][3][1][i] := default_scaling_list_inter[i];
   		end
		vld_u_name(  1, fifo, res, "sps_scaling_list_data_present_flag      ");
		sps_scaling_list_data_present_flag := res[0];
		if sps_scaling_list_data_present_flag = 1 then
			se_idx := 61;
		else
			se_idx := 6;
		end
	end
	
	read_SPS_Header.se_idx_61_loopSize_id : action ==>
	guard
		se_idx = 61 and isFifoFull(fifo) , sps_size_id < 4
   	do  
        if sps_size_id = 3 then sps_size_id_matrixCase := 2; else sps_size_id_matrixCase := 6; end
        se_idx := 62;
    end
    
    read_SPS_Header.se_idx_61_loopMatrix_id : action ==>
	guard
		se_idx = 62 and isFifoFull(fifo) , sps_matrix_id < sps_size_id_matrixCase
	var
		uint(size=32) res[1],
		int delta,
		int size_id_memcpyCase,
	    uint(size= 8) sps_scaling_list_pred_mode_flag[4][6],
    	uint(size= 32) sps_scaling_list_dc_coef[2][6]
   	do  
    	vld_u_name(  1, fifo, res, "scaling_list_pred_mode_flag             ");
        sps_scaling_list_pred_mode_flag[sps_size_id][sps_matrix_id] := res[0];
        if sps_scaling_list_pred_mode_flag[sps_size_id][sps_matrix_id] = 0 then
        	vld_ue_name(    fifo, res, "delta                                   ");
		    	delta := res[0]; // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
		    	if delta != 0 then // Copy from previous array.
                if (sps_matrix_id - delta < 0) then
                    println("Invalid delta in scaling list data");				                        
                end
		    		if sps_size_id > 0 then
		    			size_id_memcpyCase := 64;
		    		else
		    			size_id_memcpyCase := 16;
		    		end
				foreach int k in 0 .. size_id_memcpyCase - 1 do
		    			sps_sl[sps_id][sps_size_id][sps_matrix_id][k] :=
		    			sps_sl[sps_id][sps_size_id][sps_matrix_id - delta][k];
				end
                if (sps_size_id > 1) then
		    			sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id] :=
		    			sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id - delta];
                end
    		end
    		sps_matrix_id := sps_matrix_id + 1;
		else
            sps_next_coef := 8;
            sps_coef_num := min(64, (1  <<  (4 + (sps_size_id  <<  1))));
            if (sps_size_id > 1) then
            	vld_se_name(    fifo, res, "scaling_list_dc_coef                    ");
                sps_scaling_list_dc_coef[sps_size_id - 2][sps_matrix_id] := res[0] + 8;
		    		sps_next_coef := sps_scaling_list_dc_coef[sps_size_id -
		    		2][sps_matrix_id];
                sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id] := sps_next_coef;
            end
        	se_idx := 63;
        	cnt_i := 0;
        end
	end
	
	read_SPS_Header.se_idx_63_loopNumCoef : action ==>
	guard
		se_idx = 63 and isFifoFull(fifo), cnt_i < sps_coef_num
	var
		uint(size=32) res[1]
	do
        if (sps_size_id = 0) then
            sps_pos := 4 * hevc_diag_scan4x4_y[cnt_i] + hevc_diag_scan4x4_x[cnt_i];
        else
            sps_pos := 8 * hevc_diag_scan8x8_y[cnt_i] + hevc_diag_scan8x8_x[cnt_i];
        end
        vld_se_name(    fifo, res, "scaling_list_delta_coef                 ");
        sps_scaling_list_delta_coef := res[0];
        sps_next_coef := (sps_next_coef + sps_scaling_list_delta_coef + 256) mod 256;
        sps_sl[sps_id][sps_size_id][sps_matrix_id][sps_pos] := sps_next_coef;
        cnt_i := cnt_i +1;
    end
    
    read_SPS_Header.se_idx_63_loopNumCoefEnd : action ==>
	guard
		se_idx = 63 and isFifoFull(fifo), cnt_i = sps_coef_num
	do
		cnt_i := 0;
		sps_matrix_id := sps_matrix_id + 1;
		se_idx := 62;
	end
		
    
    read_SPS_Header.se_idx_62_loopMatrix_id_End : action ==>
	guard
		se_idx = 62 and isFifoFull(fifo) , sps_matrix_id = sps_size_id_matrixCase
	do
		sps_size_id := sps_size_id + 1;
		sps_matrix_id := 0;
		se_idx := 61;
	end
    
    read_SPS_Header.se_idx_61_size_id_loopEnd : action ==>
	guard
		se_idx = 61 and isFifoFull(fifo) , sps_size_id = 4
   	do 
   		sps_size_id := 0;
   		se_idx := 6;
   	end  
    
		uint log2_min_pcm_cb_size[NB_MAX_SPS];
		uint log2_max_pcm_cb_size[NB_MAX_SPS];
		
    read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo) 
	var
		uint(size=32) res[1]
	do
	        vld_u_name(1, fifo, res,
	        "amp_enabled_flag                        ");
		amp_enabled_flag := res[0];
	        vld_u_name(1, fifo, res,
	        "sample_adaptive_offset_enabled_flag     ");
        sps_sample_adaptive_offset_enabled_flag[sps_id] := res[0];
	        vld_u_name(1, fifo, res,
	        "pcm_enabled_flag                        ");
        sps_pcm_enabled_flag[sps_id] := res[0];
		if sps_pcm_enabled_flag[sps_id] = 1 then
	        	vld_u_name(4, fifo, res,
	        	"pcm_sample_bit_depth_luma_minus1        ");
	        	vld_u_name(4, fifo, res,
	        	"pcm_sample_bit_depth_chroma_minus1      ");
	        	vld_ue_name(fifo, res,
	        	"log2_min_pcm_luma_coding_block_size_minus3");
	        	log2_min_pcm_cb_size[sps_id] := res[0] + 3;
	        	vld_ue_name(fifo, res,
	        	"log2_diff_max_min_pcm_luma_coding_block_size");
	        	log2_max_pcm_cb_size[sps_id] := log2_min_pcm_cb_size[sps_id] +
	        	res[0];
	        	vld_u_name(1, fifo, res,
	        	"pcm_loop_filter_disable_flag            ");
		end
	        vld_ue_name(fifo, res,
	        "num_short_term_ref_pic_sets             ");
		sps_num_short_term_ref_pic_sets[sps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/
	int(size=8) pcRPS[NB_MAX_SPS][NB_MAX_PICS+1][PC_RPS_STRUCT_SIZE];	

	read_SPS_Header.se_idx_7.loop : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo),
		cnt_i < sps_num_short_term_ref_pic_sets[sps_id]
   	do
   		parseShortTermRefPicSet(sps_id, cnt_i, sps_num_short_term_ref_pic_sets[sps_id], fifo, pcRPS);
		cnt_i := cnt_i + 1;
 	end
 	read_SPS_Header.se_idx_7.loopEnd : action ==>
	guard
		se_idx = 7,
		cnt_i = sps_num_short_term_ref_pic_sets[sps_id]
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/	
	uint(size= 1) sps_long_term_ref_pics_present_flag[NB_MAX_SPS];
	uint(size= 1) sps_temporal_mvp_enable_flag[NB_MAX_SPS];
	bool          sps_strong_intra_smoothing_enable_flag[NB_MAX_SPS];
	uint(size= 6) sps_num_long_term_ref_pics_sps[NB_MAX_SPS];
	uint(size=16) lt_ref_pic_poc_lsb_sps[32];
	uint(size= 8) used_by_curr_pic_lt_sps_flag[32];
	
	read_SPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
	        vld_u_name(1, fifo, res,
	        "long_term_ref_pics_present_flag         ");
		sps_long_term_ref_pics_present_flag[sps_id] := res[0];
		if res[0] = 1 then
	        	vld_ue_name(fifo, res,
	        	"num_long_term_ref_pics_sps              ");
            sps_num_long_term_ref_pics_sps[sps_id] := res[0];
	        	foreach int i in 0 .. sps_num_long_term_ref_pics_sps[sps_id] - 1
	        	do
	        		vld_u_name(sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4,
	        		fifo, res, "lt_ref_pic_poc_lsb_sps                  ");
                lt_ref_pic_poc_lsb_sps[i] := res[0];
	        		vld_u_name(1, fifo, res,
	        		"used_by_curr_pic_lt_sps_flag            ");
                used_by_curr_pic_lt_sps_flag[i] := res[0];
            end
		end
	        vld_u_name(1, fifo, res,
	        "sps_temporal_mvp_enable_flag            ");
		sps_temporal_mvp_enable_flag[sps_id] := res[0];
	        vld_u_name(1, fifo, res,
	        "sps_strong_intra_smoothing_enable_flag  ");
		sps_strong_intra_smoothing_enable_flag[sps_id] := res[0] = 1;
	        vld_u_name(1, fifo, res,
	        "vui_parameters_present_flag             ");
		if res[0] = 1 then
            println("not support for vui_parameters_present_flag != 0");
        end
		se_idx := se_idx + 1;
	end 
	
	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/	
	read_SPS_Header_done : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
	        vld_u_name(1, fifo, res,
	        "sps_extension_flag                      ");
		if res[0] = 1 then
            println("not support for sps_extension_flag != 0");
		end
	end 
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER         *********************
	 **************************************************************************
	 *************************************************************************/
	  
	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/	
	uint(size= 8) pps_sps_id[NB_MAX_PPS];
	uint(size= 2) pps_tiles_enabled_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "pps_pic_parameter_set_id                "); 
		pps_id := res[0];
		vld_ue_name(    fifo, res, "pps_seq_parameter_set_id                "); 
		sps_id := res[0];
		pps_sps_id[pps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/
	uint(size= 1) pps_dependent_slice_segments_enabled_flag[NB_MAX_PPS];
    uint(size= 1) pps_output_flag_present_flag[NB_MAX_PPS];
    uint(size= 3) pps_num_extra_slice_header_bits[NB_MAX_PPS];	
	uint(size= 1) pps_sign_data_hiding_flag[NB_MAX_PPS];
	uint(size= 1) pps_cabac_init_present_flag[NB_MAX_PPS];
	uint(size= 8) pps_num_ref_idx_l0_default_active_minus1[NB_MAX_PPS];
	uint(size= 8) pps_num_ref_idx_l1_default_active_minus1[NB_MAX_PPS];
	 int(size=32) pps_init_qp_minus26[NB_MAX_PPS];
	uint(size= 1) pps_transform_skip_enabled_flag[NB_MAX_PPS];
	bool          pps_constrained_intra_pred_flag[NB_MAX_PPS];
	uint(size= 1) pps_cu_qp_delta_enabled_flag[NB_MAX_PPS];
	uint(size=16) pps_diff_cu_qp_delta_depth[NB_MAX_PPS];
	 int(size= 8) pps_cb_qp_offset[NB_MAX_PPS];
	 int(size= 8) pps_cr_qp_offset[NB_MAX_PPS];
	uint(size= 1) pps_slice_chroma_qp_offsets_present_flag[NB_MAX_PPS];
	uint(size= 1) pps_weighted_pred_flag[NB_MAX_PPS];
    uint(size= 1) pps_weighted_bipred_flag[NB_MAX_PPS];
	uint(size= 1) pps_transquant_bypass_enable_flag[NB_MAX_PPS];
	uint(size= 1) pps_entropy_coding_sync_enabled_flag[NB_MAX_PPS];
	uint(size= 8) pps_num_tile_columns_minus1[NB_MAX_PPS];
	uint(size= 8) pps_num_tile_rows_minus1[NB_MAX_PPS];
	uint(size= 1) pps_uniform_spacing_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_2 : action ==> 
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
   	do
		vld_u_name(  1, fifo, res, "dependent_slice_segments_enabled_flag   ");
		pps_dependent_slice_segments_enabled_flag[pps_id] := res[0];
        vld_u_name(  1, fifo, res, "output_flag_present_flag                ");
        pps_output_flag_present_flag[pps_id]:=res[0];
        vld_u_name(  3, fifo, res, "num_extra_slice_header_bits             ");
        pps_num_extra_slice_header_bits[pps_id] := res[0];
        vld_u_name(  1, fifo, res, "sign_data_hiding_flag                   ");
		pps_sign_data_hiding_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "cabac_init_present_flag                 ");
		pps_cabac_init_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_idx_l0_default_active_minus1    ");
		pps_num_ref_idx_l0_default_active_minus1[pps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_idx_l1_default_active_minus1    ");
		pps_num_ref_idx_l1_default_active_minus1[pps_id] := res[0];
		vld_se_name(    fifo, res, "init_qp_minus26                         ");
		pps_init_qp_minus26[pps_id] := res[0]; 
		vld_u_name(  1, fifo, res, "constrained_intra_pred_flag             ");
		pps_constrained_intra_pred_flag[pps_id] := res[0] != 0;
		vld_u_name(  1, fifo, res, "transform_skip_enabled_flag             ");
		pps_transform_skip_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "cu_qp_delta_enabled_flag                ");
        pps_cu_qp_delta_enabled_flag[pps_id] := res[0];
		if res[0] = 1 then
			vld_ue_name(    fifo, res, "diff_cu_qp_delta_depth                  ");
			pps_diff_cu_qp_delta_depth[pps_id] := res[0];
		else
			pps_diff_cu_qp_delta_depth[pps_id] := 0;
		end
		vld_se_name(    fifo, res, "pps_cb_qp_offset                        ");
		pps_cb_qp_offset[pps_id] := res[0];
		vld_se_name(    fifo, res, "pps_cr_qp_offset                        ");
		pps_cr_qp_offset[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "pps_slice_chroma_qp_offsets_present_flag");
		pps_slice_chroma_qp_offsets_present_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "weighted_pred_flag                      ");
		pps_weighted_pred_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "weighted_bipred_flag                    ");
        pps_weighted_bipred_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "transquant_bypass_enable_flag           ");
		pps_transquant_bypass_enable_flag[pps_id]:=res[0];
		vld_u_name(  1, fifo, res, "tiles_enabled_flag                      ");
		pps_tiles_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "entropy_coding_sync_enabled_flag        ");
		pps_entropy_coding_sync_enabled_flag[pps_id] := res[0];
		pps_num_tile_columns_minus1[pps_id] := 0;
		pps_num_tile_rows_minus1[pps_id]    := 0;
		pps_uniform_spacing_flag[pps_id]    := 1;
		if pps_tiles_enabled_flag[pps_id] = 1 then
			vld_ue_name(    fifo, res, "num_tile_columns_minus1                 "); 
			pps_num_tile_columns_minus1[pps_id] := res[0];
			vld_ue_name(    fifo, res, "num_tile_rows_minus1                    ");
			pps_num_tile_rows_minus1[pps_id] := res[0];
			vld_u_name ( 1, fifo, res, "uniform_spacing_flag                    ");
			pps_uniform_spacing_flag[pps_id] :=res[0];
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
 	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_3
	 *************************************************************************/	
	uint(size=16) pps_column_width[NB_MAX_PPS][PICT_WIDTH / MIN_CTB_SIZE_Y];

  	read_PPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3  and isFifoFull(fifo),
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i <= pps_num_tile_columns_minus1[pps_id] - 1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "column_width[ ]                         ");
		pps_column_width[pps_id][cnt_i] := res[0] + 1;
		if cnt_i >= (PICT_WIDTH / MIN_CTB_SIZE_Y) then
			println("Error read_PPS_Header.se_idx_3.loop : "+cnt_i+" >= "+(PICT_WIDTH / MIN_CTB_SIZE_Y));
		end		
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3,
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i > pps_num_tile_columns_minus1[pps_id] - 1
   	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end 
	read_PPS_Header.se_idx_3.noLoop : action ==>
	guard
		se_idx = 3,
		pps_uniform_spacing_flag[pps_id] = 1
   	do
		se_idx := se_idx + 2;
	end 
	/**************************************************************************
	 * read_PPS_Header.se_idx4
	 *************************************************************************/	
	uint(size=16) pps_row_height[NB_MAX_PPS][PICT_HEIGHT / MIN_CTB_SIZE_Y];
	uint(size= 1) pps_scaling_list_data_present_flag[NB_MAX_PPS];
	
	read_PPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i <= pps_num_tile_rows_minus1[pps_id] - 1
	var
		uint(size=32) res[1]
   	do
		vld_ue_name(    fifo, res, "row_height[ ]                           ");
		pps_row_height[pps_id][cnt_i] := res[0] + 1;
		if cnt_i >= (PICT_HEIGHT / MIN_CTB_SIZE_Y) then
			println("Error read_PPS_Header.se_idx_4.loop : "+cnt_i+" >= "+(PICT_HEIGHT / MIN_CTB_SIZE_Y));
		end
		cnt_i := cnt_i + 1;
	end 
	read_PPS_Header.se_idx_4.loopEnd : action ==>
	guard
		se_idx = 4,
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i > pps_num_tile_rows_minus1[pps_id] - 1
	do
		cnt_i  := 0;
		se_idx := 5;
	end 
	
	read_PPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
   	do
		if (pps_tiles_enabled_flag[pps_id] = 1) then
			vld_u_name(  1, fifo, res, "loop_filter_across_tiles_enabled_flag   ");
			//pps_loop_filter_across_tile_enabled_flag[pps_id] := res[0];
		end
		vld_u_name(  1, fifo, res, "loop_filter_across_slices_enabled_flag  ");
		pps_loop_filter_across_slice_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "deblocking_filter_control_present_flag  ");
		pps_deblocking_filter_control_present_flag[pps_id] := res[0];
        deblocking_filter_override_enabled_flag[pps_id] := 0;
		if pps_deblocking_filter_control_present_flag[pps_id] = 1 then
            vld_u_name(  1, fifo, res, "deblocking_filter_override_enabled_flag ");
            deblocking_filter_override_enabled_flag[pps_id] := res[0];
            vld_u_name(  1, fifo, res, "pps_disable_deblocking_filter_flag      ");
            pps_disable_deblocking_filter_flag[pps_id] := res[0];
            if res[0] = 0 then
                vld_se_name(    fifo, res, "pps_beta_offset_div2                    ");
                pps_beta_offset[pps_id] := res[0] << 1;
                vld_se_name(    fifo, res, "pps_tc_offset_div2                      ");
                pps_tc_offset[pps_id] := res[0] << 1;
            end
		end
		vld_u_name(  1, fifo, res, "pps_scaling_list_data_present_flag      ");
		pps_scaling_list_data_present_flag[pps_id] := res[0];
		if pps_scaling_list_data_present_flag[pps_id] = 0 then
			se_idx := 52;
		else
			se_idx := 50;
		end 
	end
	
	/**************************************************************************
	 * read_PPS_Header.se_idx5
	 *************************************************************************/	
	uint(size= 1) pps_deblocking_filter_control_present_flag[NB_MAX_PPS];
	uint(size =1) deblocking_filter_override_enabled_flag[NB_MAX_PPS];
	//uint(size= 1) pps_loop_filter_across_tile_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_loop_filter_across_slice_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_lists_modification_present_flag[NB_MAX_PPS];
    uint(size= 1) pps_slice_segment_header_extension_present_flag[NB_MAX_PPS];
    uint(size= 1) pps_disable_deblocking_filter_flag[NB_MAX_PPS]; 
    uint(size= 1) pps_beta_offset[NB_MAX_PPS]; 
    uint(size= 1) pps_tc_offset[NB_MAX_PPS]; 
    uint(size= 8) pps_log2_parallel_merge_level[NB_MAX_PPS]; 
    uint(size= 8) pps_sl[NB_MAX_PPS][4][6][64];
    uint(size= 8) pps_sl_dc[NB_MAX_PPS][2][6];
    int pps_matrix_id :=0;
    int pps_size_id := 0;
    int pps_next_coef;
	int pps_coef_num;
	int pps_scaling_list_delta_coef;
	int pps_pos;
	int pps_size_id_matrixCase;

	read_PPS_Header.se_idx_51 : action ==>
	guard
		se_idx = 52 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
   	do
        vld_u_name(  1, fifo, res, "lists_modification_present_flag         ");
        pps_lists_modification_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "log2_parallel_merge_level_minus2        ");
		pps_log2_parallel_merge_level[pps_id] := res[0] + 2;
		vld_u_name(  1, fifo, res, "slice_segment_header_extension_present_flag");
		pps_slice_segment_header_extension_present_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "pps_extension_flag                      ");
		if res[0] = 1 then
            println("not support for pps_extension_flag != 0");
		end
		se_idx := 6;
	end 
	
	read_PPS_Header.se_idx_50 : action ==>
	guard
		se_idx = 50 and isFifoFull(fifo)
   	do 
   		foreach int matrixId in 0 .. 5 do
        	// 4x4 default is 16
	        foreach int i in 0 .. 15 do
	        	pps_sl[pps_id][0][matrixId][i] := 16;
	        end
	        pps_sl_dc[pps_id][0][matrixId] := 16; // default for 16x16
	        pps_sl_dc[pps_id][1][matrixId] := 16; // default for 32x32
   		end
   		foreach int i in 0 .. 63 do
   			pps_sl[pps_id][1][0][i] := default_scaling_list_intra[i];
   			pps_sl[pps_id][1][1][i] := default_scaling_list_intra[i];
   			pps_sl[pps_id][1][2][i] := default_scaling_list_intra[i];
   			pps_sl[pps_id][1][3][i] := default_scaling_list_inter[i];
   			pps_sl[pps_id][1][4][i] := default_scaling_list_inter[i];
   			pps_sl[pps_id][1][5][i] := default_scaling_list_inter[i];
   			pps_sl[pps_id][2][0][i] := default_scaling_list_intra[i];
   			pps_sl[pps_id][2][1][i] := default_scaling_list_intra[i];
   			pps_sl[pps_id][2][2][i] := default_scaling_list_intra[i];
   			pps_sl[pps_id][2][3][i] := default_scaling_list_inter[i];
   			pps_sl[pps_id][2][4][i] := default_scaling_list_inter[i];
   			pps_sl[pps_id][2][5][i] := default_scaling_list_inter[i];
   			pps_sl[pps_id][3][0][i] := default_scaling_list_intra[i];
   			pps_sl[pps_id][3][1][i] := default_scaling_list_inter[i];
   		end
		se_idx := 51;
	end
	
	read_PPS_Header.se_idx_51_loopSize_id : action ==>
	guard
		se_idx = 51 and isFifoFull(fifo) , pps_size_id < 4
	do
		if pps_size_id = 3 then pps_size_id_matrixCase := 2; else pps_size_id_matrixCase := 6; end
		se_idx := 53;
    end
    
    read_PPS_Header.se_idx_53_loopMatrix_id: action ==>
	guard
		se_idx = 53 and isFifoFull(fifo) , pps_matrix_id < pps_size_id_matrixCase
	var
		uint(size=32) res[1],
		int delta,
		int size_id_memcpyCase,
	    uint(size= 8) pps_scaling_list_pred_mode_flag[4][6],
    	uint(size= 32) pps_scaling_list_dc_coef[2][6]
   	do  
    	vld_u_name(  1, fifo, res, "scaling_list_pred_mode_flag             ");
        pps_scaling_list_pred_mode_flag[pps_size_id][pps_matrix_id] := res[0];
        if pps_scaling_list_pred_mode_flag[pps_size_id][pps_matrix_id] = 0 then
        	vld_ue_name(    fifo, res, "delta                                   ");
		    	delta := res[0]; // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
		    	if delta != 0 then // Copy from previous array.
                if (pps_matrix_id - delta < 0) then
                    println("Invalid delta in scaling list data");				                        
                end
		    		if pps_size_id > 0 then
		    			size_id_memcpyCase := 64;
		    		else
		    			size_id_memcpyCase := 16;
		    		end
				foreach int k in 0 .. size_id_memcpyCase do
		    			pps_sl[pps_id][pps_size_id][pps_matrix_id][k] :=
		    			pps_sl[pps_id][pps_size_id][pps_matrix_id - delta][k];
				end
                if (pps_size_id > 1) then
		    			pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id] :=
		    			pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id - delta];
                end
    		end
    		pps_matrix_id := pps_matrix_id + 1;
		else
            pps_next_coef := 8;
            pps_coef_num := min(64, (1  <<  (4 + (pps_size_id  <<  1))));
            if (pps_size_id > 1) then
            	vld_se_name(    fifo, res, "scaling_list_dc_coef                    ");
                pps_scaling_list_dc_coef[pps_size_id - 2][pps_matrix_id] := res[0] + 8;
		    		pps_next_coef := pps_scaling_list_dc_coef[pps_size_id -
		    		2][pps_matrix_id];
                pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id] := pps_next_coef;
            end
            se_idx := 54;
        	cnt_i := 0;
        end
	end
	
	read_PPS_Header.se_idx_54_loopNumCoef : action ==>
	guard
		se_idx = 54 and isFifoFull(fifo), cnt_i < pps_coef_num
	var
		uint(size=32) res[1]
	do
        if (pps_size_id = 0) then
            pps_pos := 4 * hevc_diag_scan4x4_y[cnt_i] + hevc_diag_scan4x4_x[cnt_i];
        else
            pps_pos := 8 * hevc_diag_scan8x8_y[cnt_i] + hevc_diag_scan8x8_x[cnt_i];
        end
        vld_se_name(    fifo, res, "scaling_list_delta_coef                 ");
        pps_scaling_list_delta_coef := res[0];
        pps_next_coef := (pps_next_coef + pps_scaling_list_delta_coef + 256) & 255;
        pps_sl[pps_id][pps_size_id][pps_matrix_id][pps_pos] := pps_next_coef;
        cnt_i := cnt_i + 1;
    end
    
    read_PPS_Header.se_idx_54_loopNumCoefEnd : action ==>
	guard
		se_idx = 54 and isFifoFull(fifo), cnt_i = pps_coef_num
	do
		cnt_i := 0;
		pps_matrix_id := pps_matrix_id + 1;
		se_idx := 53;
	end
		
    
    read_PPS_Header.se_idx_53_loopMatrix_id_End : action ==>
	guard
		se_idx = 53 and isFifoFull(fifo) , pps_matrix_id = pps_size_id_matrixCase
	do
		pps_size_id := pps_size_id + 1;
		pps_matrix_id := 0;
		se_idx := 51;
	end
    
    read_PPS_Header.se_idx_51_loopSize_id_End : action ==>
	guard
		se_idx = 51 and isFifoFull(fifo) , pps_size_id = 4
   	do 
   		pps_size_id := 0;
   		se_idx := 52;
   	end  
	
	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/	
	read_PPS_Header_done : action ==>
	guard
		se_idx = 6
	end 	

	/**************************************************************************
	 **************************************************************************
	 ********        Slice HEADER                         *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/
    uint(size= 8) Log2CtbSize;
    uint(size= 8) Log2MinCbSize;
    uint(size=16) PicWidthInCtbsY;
    uint(size=16) PicHeightInCtbsY;
    uint(size=16) PicSizeInCtbsY;
    uint(size= 1) slice_temporal_mvp_enable_flag;

    int(size=32) poc;
	uint(size= 3) slice_type;
	uint(size=32) slice_segment_address;
	uint(size= 1) slice_sample_adaptive_offset_flag[4];
	
	procedure compute_POC(int pic_order_cnt_lsb)
	var
	     int iPOClsb = pic_order_cnt_lsb,
	     int iPrevPOC = poc,
	     int iMaxPOClsb := max_poc_lsb[sps_id],
	     int iPrevPOClsb,
	     int iPrevPOCmsb,
	     int iPOCmsb
	begin
		iPrevPOClsb := iPrevPOC mod iMaxPOClsb;
		iPrevPOCmsb := iPrevPOC-iPrevPOClsb;
	    if( (iPOClsb < iPrevPOClsb) and ( (iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2) ) ) then
	    	iPOCmsb := iPrevPOCmsb + iMaxPOClsb;
	    else 
	    	if( (iPOClsb > iPrevPOClsb)  and ( (iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2) ) ) then
	 			iPOCmsb := iPrevPOCmsb - iMaxPOClsb;
	   		else
				iPOCmsb := iPrevPOCmsb;
			end
		end
                if (nal_unit_type = NAL_BLA_W_LP   or
                nal_unit_type = NAL_BLA_W_RADL or
                nal_unit_type = NAL_BLA_N_LP)
        then
                iPOCmsb := 0;
        end

	    poc:= iPOCmsb+iPOClsb;
	end
	
	uint(size= 1) first_slice_segment_in_pic_flag := 1;
	uint(size= 1) dependent_slice_segment_flag;
	uint(size=16) pictSize[2];
	uint(size=16) num_long_term_sps := 0;
    uint(size=16) num_long_term_pics := 0;
    uint(size= 8) poc_lsb_lt[32];
    uint(size= 8) UsedByCurrPicLt[32];
    uint(size= 8) DeltaPocMsbCycleLt[32];
    uint(size= 8) delta_poc_msb_present_flag[32];
    int pic_order_cnt_lsb;
    uint(size=16) pictOrTileSize[2] := [0,0];
    uint rowIndex := 0;
    uint colIndex := 0;
    uint(size=16) prevTileCoord[2] := [0,0];
    uint prevRowIndex := 0;
    uint prevColIndex := 0;
	uint slice_addr := 0;
    int slice_idx :=0;
	int idx := 0;
	
	read_SliceHeader.se_idx_1 : action ==> 	PictSize:[pictSize] repeat 2 , TileSize:[pictOrTileSize] repeat 2, PicSizeInMb:[(pictSize[0] + 15)/16, (pictSize[1] + 15)/16], 
											DispCoord:[0, pictSize[0]-1, 0, pictSize[1]-1], PartMode:[part_mode], 
								            LFAcrossSlcTile:[pps_loop_filter_across_slice_enabled_flag[pps_id] + (pps_loop_filter_across_slice_enabled_flag[pps_id]<<1)]
		
	guard
	        se_idx = 1 and idx = 0 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 4) part_mode
   	do	
	    	
        Log2MinCbSize     := sps_log2_min_coding_block_size[sps_id] ;
        Log2CtbSize       := Log2MinCbSize + sps_log2_diff_max_min_coding_block_size[sps_id];
        PicWidthInCtbsY   := ( sps_pic_width_in_luma_samples[sps_id]  + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
        PicHeightInCtbsY  := ( sps_pic_height_in_luma_samples[sps_id] + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
        PicSizeInCtbsY    := PicWidthInCtbsY * PicHeightInCtbsY;
	        
   	    TilesInfo := [TILE_SPLIT_ENABLE, TILE_INDEX];
   	
        vld_u_name(  1, fifo, res, "first_slice_segment_in_pic_flag         ");
		first_slice_segment_in_pic_flag := res[0];

		if nal_unit_type >= 16 and nal_unit_type <= 23 then
			vld_u_name(  1, fifo, res, "no_output_of_prior_pics_flag            ");
		end
        vld_ue_name(    fifo, res, "slice_pic_parameter_set_id              "); 
		pps_id := res[0];
		sps_id := pps_sps_id[pps_id];
		dependent_slice_segment_flag := 0;

		if first_slice_segment_in_pic_flag = 0 then
			if (pps_dependent_slice_segments_enabled_flag[pps_id] = 1) then
				vld_u_name(  1, fifo, res, "dependent_slice_segment_flag                    ");
				dependent_slice_segment_flag := res[0];
			end
            vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifo, res, "slice_segment_address                   ");
			slice_segment_address := res[0];
			if (dependent_slice_segment_flag = 0) then
	                slice_addr := slice_segment_address;
            	slice_idx := slice_idx + 1;
        	end
		else
			slice_segment_address := 0;
	            slice_addr := 0;
		end
	        
	        pictSize[0] := sps_pic_width_in_luma_samples[sps_id];
	        pictSize[1] := sps_pic_height_in_luma_samples[sps_id];
	        
		if first_slice_segment_in_pic_flag = 1 then
			part_mode := PART_MODE_PICT;
		elsif dependent_slice_segment_flag = 0 then
			part_mode := PART_MODE_SLICE_INDEP;
		else
			part_mode := PART_MODE_SLICE_DEP;
		end
		if dependent_slice_segment_flag = 0 then
	        	se_idx := 200;
	        else
	        	se_idx := 6;
	        end
	    end
	        
	    read_SliceHeader.se_idx_11 : action ==> LcuSizeMax:[1 << Log2CtbSize], Poc:[poc], SliceType:[slice_type]
	    guard
	            se_idx = 200 and isFifoFull(fifo)
	    var
	        uint(size=32) res[1],
	        uint(size= 8) numbits := 0,
	        uint(size= 8) lt_idx_sps := 0,
	        uint(size= 8) prevDeltaMSB := 0,
	        uint(size=16) column_width[PICT_WIDTH / MIN_CTB_SIZE_Y]= [pps_column_width[pps_id][ i ] : for int i in 0 .. (PICT_WIDTH / MIN_CTB_SIZE_Y)-1],
		    uint(size=16) row_height[PICT_HEIGHT / MIN_CTB_SIZE_Y]  = [pps_row_height[pps_id][ i ] : for int i in 0 .. (PICT_HEIGHT / MIN_CTB_SIZE_Y)-1],
		    uint(size= 8) num_tile_columns_minus1           = pps_num_tile_columns_minus1[pps_id],
		    uint(size= 8) num_tile_rows_minus1                      = pps_num_tile_rows_minus1[pps_id],
		    uint(size= 1) uniform_spacing_flag                      = pps_uniform_spacing_flag[pps_id]
	    do
            foreach int i in 0 .. pps_num_extra_slice_header_bits[pps_id] - 1 do
                vld_u_name(  1, fifo, res, "slice_reserved_undetermined_flag[i]     ");
            end
			vld_ue_name(    fifo, res, "slice_type                              ");
			slice_type := res[0];
	        
			slice_temporal_mvp_enable_flag := 0;
			idx := 0;
			if(pps_output_flag_present_flag[pps_id] = 1) then	
				vld_u_name(  1, fifo, res, "pic_output_flag                         ");
			end
			if sps_separate_colour_plane_flag[sps_id] = 1 then
                vld_u_name(  2, fifo, res, "colour_plane_id                         ");
            end

			if nal_unit_type = NAL_IDR_W_DLP or nal_unit_type = NAL_IDR_N_LP then
				poc := 0;
	        	//sps_num_short_term_ref_pic_sets[sps_id] := 0;
			else
				vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "pic_order_cnt_lsb                       "); 
				pic_order_cnt_lsb := res[0];
				//compute the number of POC
				compute_POC(res[0]);
				vld_u_name(  1, fifo, res, "short_term_ref_pic_set_sps_flag         ");
				if res[0] = 0 then
			   		parseShortTermRefPicSet(sps_id, sps_num_short_term_ref_pic_sets[sps_id], sps_num_short_term_ref_pic_sets[sps_id], fifo, pcRPS);
		   		else
                    while ((1 << numbits) < sps_num_short_term_ref_pic_sets[sps_id]) do
                        numbits := numbits + 1;
                    end
                    res[0] := 0;
                    if (numbits > 0) then
                        vld_u_name(   numbits, fifo, res, "short_term_ref_pic_set_idx              ");
                    end
				    pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]] := [pcRPS[sps_id][res[0]][i] : for int i in 0 .. PC_RPS_STRUCT_SIZE - 1]; 
				end
				num_long_term_sps := 0;
    			num_long_term_pics := 0;
    			
				if sps_long_term_ref_pics_present_flag[sps_id] = 1 then
				    if sps_num_long_term_ref_pics_sps[sps_id] > 0 then
                        vld_ue_name(    fifo, res, "num_long_term_sps                       ");
                        num_long_term_sps := res[0];
                    end
					vld_ue_name(    fifo, res, "num_long_term_pics                      ");
					num_long_term_pics := res[0]; 
//					numbits := 0;
//                    while (sps_num_long_term_ref_pics_sps[sps_id] > (1 << numbits)) do
//                        numbits := numbits + 1;
//                    end
					foreach int i in 0 .. num_long_term_sps + num_long_term_pics - 1 do
						if i < num_long_term_sps then
							if num_long_term_pics > 1 then
								vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifo, res, "lt_idx_sps                              ");
								lt_idx_sps := res[0];
                           	end
                           	poc_lsb_lt[i] := lt_ref_pic_poc_lsb_sps[lt_idx_sps];
                           	UsedByCurrPicLt[i] := used_by_curr_pic_lt_sps_flag[lt_idx_sps];
						else
                            vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "poc_lsb_lt                              ");
                            poc_lsb_lt[i] := res[0];
                            vld_u_name(  1, fifo, res, "used_by_curr_pic_lt_flag                ");
                            UsedByCurrPicLt[i] :=  res[0];
						end
						vld_u_name(  1, fifo, res, "delta_poc_msb_present_flag              ");
						delta_poc_msb_present_flag[i] := res[0];
						if res[0] = 1 then
							if( i = 0 or i = num_long_term_sps ) then
                            	vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                ");
                            	DeltaPocMsbCycleLt[i] := res[0];
                        	else
			    				vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                ");
			    				DeltaPocMsbCycleLt[i] := res[0] + prevDeltaMSB;
			    			end
			    			prevDeltaMSB := DeltaPocMsbCycleLt[i];
						end
					end
				end
                if sps_temporal_mvp_enable_flag[sps_id] = 1 then
                    vld_u_name(  1, fifo, res, "slice_temporal_mvp_enable_flag          "); 
                    slice_temporal_mvp_enable_flag := res[0];
                else
                	slice_temporal_mvp_enable_flag := 0;
                end 
			end
	        
	        if (temporal_id = 0 and nal_unit_type != NAL_TRAIL_N and
	            nal_unit_type != NAL_TSA_N   and
	            nal_unit_type != NAL_STSA_N  and
	            nal_unit_type != NAL_RADL_N  and
	            nal_unit_type != NAL_RADL_R  and
	            nal_unit_type != NAL_RASL_N  and
	            nal_unit_type != NAL_RASL_R) then
	            
//	            pocTid0 := poc;
		    end
	        
			if( sps_sample_adaptive_offset_enabled_flag[sps_id] = 1) then
				vld_u_name(  1, fifo, res, "slice_sao_luma_flag                     "); 
				slice_sample_adaptive_offset_flag[0] := res[0];
				vld_u_name(  1, fifo, res, "slice_sao_chroma_flag                   ");
				slice_sample_adaptive_offset_flag[1] := res[0];
				slice_sample_adaptive_offset_flag[2] := res[0];
                        else
                                slice_sample_adaptive_offset_flag[0] := 0;
                        slice_sample_adaptive_offset_flag[1] := 0;
                        slice_sample_adaptive_offset_flag[2] := 0;
			end
		
		
	
	//	            if (first_slice_segment_in_pic_flag = 1) then
	//	                    sao := slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1);
	//	                    isPicSlcLcu := 0;
	//	            else
	//	                    sao := slice_sample_adaptive_offset_flag[0] + slice_sample_adaptive_offset_flag[1];
	//	                    isPicSlcLcu := 2 ;
	//	            end
	
		//////////////////////////////////////////////////////////////////////////// copied from line 2412
		if num_tile_columns_minus1 >= (PICT_WIDTH / MIN_CTB_SIZE_Y) then
			println("Error read_SliceData.init : ColumnWidth : "+num_tile_columns_minus1+" >= "+(PICT_WIDTH / MIN_CTB_SIZE_Y));
		end
		if uniform_spacing_flag = 1 then
			foreach int i in 0 .. num_tile_columns_minus1 do
				colWidth[ i ] := ((i + 1)*PicWidthInCtbsY) / (num_tile_columns_minus1+1) - (i*PicWidthInCtbsY) / (num_tile_columns_minus1+1);
				colTileInPix[ i + 1 ] :=   (colWidth[ i ] << Log2CtbSize) + colTileInPix[ i ];
				if i = num_tile_columns_minus1 then
					colTileInPix[ i + 1 ] := pictSize [0];
				end
			end
		else
			colWidth[ num_tile_columns_minus1 ] := PicWidthInCtbsY;
			foreach int i in 0 .. num_tile_columns_minus1 - 1 do
				colWidth[ i ] := column_width[ i ] ;
				colWidth[ num_tile_columns_minus1 ] := colWidth[ num_tile_columns_minus1 ] - colWidth[ i ];
				colTileInPix[ i + 1 ] :=   (colWidth[ i ] << Log2CtbSize) + colTileInPix[ i ];
				if i = num_tile_columns_minus1 - 1 then
					colTileInPix[ i + 2 ] := pictSize [0];
				end
			end
		end
		
		if num_tile_rows_minus1 >= (PICT_HEIGHT / MIN_CTB_SIZE_Y) then
			println("Error read_SliceData.init : RowHeight : "+num_tile_rows_minus1+" >= "+(PICT_HEIGHT / MIN_CTB_SIZE_Y));
		end
		if uniform_spacing_flag = 1 then
			foreach int i in 0 .. num_tile_rows_minus1 do
				rowHeight[ i ] := ((i+1)*PicHeightInCtbsY) / (num_tile_rows_minus1+1) - (i*PicHeightInCtbsY) / (num_tile_rows_minus1+1);
				rowTileInPix[ i + 1 ] :=   (rowHeight[ i ] << Log2CtbSize) + rowTileInPix[ i ];
				if i = num_tile_rows_minus1 then
					rowTileInPix[ i + 1 ] := pictSize [1];
				end
			end
		else
			rowHeight[ num_tile_rows_minus1 ] := PicHeightInCtbsY;
			foreach int i in 0 .. num_tile_rows_minus1 - 1 do
				rowHeight[ i ] := row_height[ i ];
				rowHeight[ num_tile_rows_minus1 ] := rowHeight[ num_tile_columns_minus1 ] - rowHeight[ i ];
				rowTileInPix[ i + 1 ] :=   (rowHeight[ i ] << Log2CtbSize) + rowTileInPix[ i ];
				if i = num_tile_rows_minus1 - 1 then
					rowTileInPix[ i + 2 ] := pictSize [1];
				end
			end
		end
		if TILE_SPLIT_ENABLE = 0 then // no tiles split : send image size
			pictOrTileSize[0] := pictSize[0];
			pictOrTileSize[1] := pictSize[1];
		else // tiles split : send current tile size
			colIndex := TilesInfo[1]  mod (num_tile_columns_minus1+1);
			rowIndex := TilesInfo[1]  div (num_tile_columns_minus1+1);
			
			pictOrTileSize[0] := colTileInPix[colIndex + 1] - colTileInPix[colIndex];
			pictOrTileSize[1] := rowTileInPix[rowIndex + 1] - rowTileInPix[rowIndex];
			if TilesInfo[1] != 0 then
				prevColIndex := (TilesInfo[1] - 1)  mod (num_tile_rows_minus1+1);
    			prevRowIndex := (TilesInfo[1] - 1)  div (num_tile_columns_minus1+1);
				prevTileCoord[0] := colTileInPix[prevColIndex + 1];
				prevTileCoord[1] := rowTileInPix[prevRowIndex + 1];
			end
		end
	        se_idx := 2;
	end
	
	
	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/
	uint(size= 8) num_ref_idx_l0_active;
	uint(size= 8) num_ref_idx_l1_active;
	uint(size= 1) mvd_l1_zero_flag;
	uint(size= 8) ref_pic_list_modification_flag_lx[2] := [0,0];
	uint(size=4) list_entry_lx [2][32];
	
	read_SliceHeader.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		int NumPocTotalCurr := 0
   	do
	   	num_ref_idx_l0_active    := 0;
	   	num_ref_idx_l1_active    := 0;
	   	mvd_l1_zero_flag         := 0;
		if slice_type = P_SLICE or slice_type = B_SLICE then
		   	num_ref_idx_l0_active := pps_num_ref_idx_l0_default_active_minus1[pps_id] + 1;
		   	if slice_type = B_SLICE then
				num_ref_idx_l1_active := pps_num_ref_idx_l1_default_active_minus1[pps_id] + 1;	
			end
			vld_u_name(  1, fifo, res, "num_ref_idx_active_override_flag        ");		
	   		if res[0] = 1 then
				vld_ue_name(    fifo, res, "num_ref_idx_l0_active_minus1            ");
				num_ref_idx_l0_active := res[0] + 1;
				if slice_type = B_SLICE then
					vld_ue_name(    fifo, res, "num_ref_idx_l1_active_minus1            ");
					num_ref_idx_l1_active := res[0] + 1;
				end
	   		end
	   		
	   		ref_pic_list_modification_flag_lx[0] := 0;
	   		ref_pic_list_modification_flag_lx[1] := 0;
	   		
	   		foreach int i in 0 .. pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS]-1 do
	   			if (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+i] = 1) then 
	   				NumPocTotalCurr := NumPocTotalCurr + 1;
	   			end
	   		end
	   		
	   		foreach int i in pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS] .. pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_PICS]-1 do
	   			if (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+i] = 1) then 
	   				NumPocTotalCurr := NumPocTotalCurr + 1;
	   			end
	   		end
	   	
	   		foreach int i in 0 .. num_long_term_sps + num_long_term_pics - 1 do
	   			if ( UsedByCurrPicLt[i] = 1) then 
	   				NumPocTotalCurr := NumPocTotalCurr + 1;
	   			end
	   		end
	   		
		    if pps_lists_modification_present_flag[pps_id] = 1 and NumPocTotalCurr > 1 then
		    	vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_l0       ");
		    	ref_pic_list_modification_flag_lx[0] := res[0];
		    	if ref_pic_list_modification_flag_lx[0] = 1 then 
		    		foreach int i in 0 .. num_ref_idx_l0_active - 1 do
		    			vld_u_name(log2((NumPocTotalCurr-1)<<1) , fifo, res, "list_entry_lx                           ");
		    			list_entry_lx[0][i] := res[0];
		    		end
		    	end
		    	
		    	if slice_type = B_SLICE then
		    		vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_l1       ");
		    		ref_pic_list_modification_flag_lx[1] := res[0];
		    		if ref_pic_list_modification_flag_lx[1] = 1 then
		    			foreach int i in 0 .. num_ref_idx_l1_active - 1 do
		    				vld_u_name(log2((NumPocTotalCurr-1)<<1) , fifo, res, "list_entry_lx                           ");
		    				list_entry_lx[1][i] := res[0];
		    			end
		    		end
		    	end
		    end
		    if slice_type = B_SLICE then
				vld_u_name(  1, fifo, res, "mvd_l1_zero_flag                        ");
				mvd_l1_zero_flag := res[0];		
			end	    
	    end
		se_idx := 10;
	end
	/**************************************************************************
	 * read_SliceHeader.sendRefPOC
	 *************************************************************************/
	int(size=16)  pocTables[5][NB_MAX_PICS];
    int numPic[5];
	uint(size= 8) idxNumPic;
	uint(size= 8) idxRefPoc;

	procedure setRefTables(int sps_id, int idx, int(size=8) pc_rps[NB_MAX_SPS][NB_MAX_PICS+1][PC_RPS_STRUCT_SIZE], int poc)
	var
		uint j := 0,
		uint k := 0,
		int pocLt := poc_lsb_lt[0]
	begin
		foreach int i in 0 .. pc_rps[sps_id][idx][NUM_NEGATIVE_PICS]-1
		do
			if(pc_rps[sps_id][idx][USED+i]=1) then
                		pocTables[ST_CURR_BEF][j] := poc +
                		pc_rps[sps_id][idx][DELTAPOC + i];
				j := j + 1;
			else
				pocTables[ST_FOLL][k] := poc + pc_rps[sps_id][idx][DELTAPOC+i];
				k := k + 1;
			end
		end
		numPic[ST_CURR_BEF] := j;
		j:=0;
                foreach uint(size=8) i in
                pc_rps[sps_id][idx][NUM_NEGATIVE_PICS] ..
                pc_rps[sps_id][idx][NUM_PICS] - 1 do
			if(pc_rps[sps_id][idx][USED+i]=1) then
                		pocTables[ST_CURR_AFT][j] := poc +
                		pc_rps[sps_id][idx][DELTAPOC + i];
				j := j + 1;
			else
				pocTables[ST_FOLL][k] := poc + pc_rps[sps_id][idx][DELTAPOC+i];
				k := k + 1;
			end
		end
		numPic[ST_CURR_AFT] := j;
		numPic[ST_FOLL] := k;
		j := 0;
		k := 0;
                foreach uint i in 0 .. (num_long_term_sps +
                num_long_term_pics) - 1 do
            pocLt := poc_lsb_lt[i];
            if delta_poc_msb_present_flag[i] = 1 then
                pocLt := pocLt + poc - DeltaPocMsbCycleLt[i] * max_poc_lsb[sps_id] - pic_order_cnt_lsb;
            end
            if UsedByCurrPicLt[i] = 1 then
                pocTables[LT_CURR][j] := pocLt;
                j := j + 1;
            else 
                pocTables[LT_FOLL][k] := pocLt;
                k := k + 1;
            end
        end
		numPic[LT_CURR] := j;
		numPic[LT_FOLL] := k;
	end

	read_SliceHeader.sendRefPOC.init : action ==> NumRefIdxLxActive:[num_ref_idx_l0_active, num_ref_idx_l1_active] 
	guard
		se_idx = 10
	do
		setRefTables(sps_id, sps_num_short_term_ref_pic_sets[sps_id], pcRPS, poc);
		idxNumPic := 0;
		se_idx    := 101;
	end
	
	read_SliceHeader.sendListEntryL0Flag : action ==> RefPicListModif:[ref_pic_list_modification_flag_lx[0]]
	guard
		se_idx = 101
	do
		if ref_pic_list_modification_flag_lx[0] = 0 then
			se_idx := 201;
		else
			se_idx := 102;
		end
	end
	
	read_SliceHeader.sendListEntryL0Loop : action ==> RefPicListModif:[list_entry_lx[0][cnt_i - 1]]
	guard
		se_idx = 102,
		cnt_i < num_ref_idx_l0_active
	do
		cnt_i := cnt_i + 1;
	end
	
	read_SliceHeader.sendListEntryL0End : action ==>
	guard
		se_idx = 102,
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
		se_idx := 201;
		
	end
	
	read_SliceHeader.sendListEntryL1Flag : action ==> RefPicListModif:[ref_pic_list_modification_flag_lx[1]]
	guard
		se_idx = 201
	do
		if ref_pic_list_modification_flag_lx[1] = 0 then
			se_idx := 11;
		else
			se_idx := 202;
		end
	end
	
	read_SliceHeader.sendListEntryL1Loop : action ==> RefPicListModif:[list_entry_lx[1][cnt_i - 1]]
	guard
		se_idx = 202,
		cnt_i < num_ref_idx_l1_active
	do
		cnt_i := cnt_i + 1;
	end
	
	read_SliceHeader.sendListEntryL1End : action ==>
	guard
		se_idx = 202,
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
		se_idx    := 11;
	end
	read_SliceHeader.sendRefPOC.sendSize : action ==> RefPoc:[refPocSize]
	guard
		se_idx = 11
	var
                int(size=16) refPocSize = numPic[idxNumPic]
	do
		if numPic[idxNumPic] = 0 then
			idxNumPic := idxNumPic + 1;
			if idxNumPic = 5 then
				se_idx := 3;
			end
		else
			idxRefPoc := 0;
			se_idx    := 12;
		end
	end
	read_SliceHeader.sendRefPOC.sendRefPoc : action ==> RefPoc:[refPoc]
	guard
		se_idx = 12
	var
                int(size=16) refPoc = pocTables[idxNumPic][idxRefPoc]
	do
		idxRefPoc := idxRefPoc + 1;
		if idxRefPoc = numPic[idxNumPic] then
			idxNumPic := idxNumPic + 1;
			if idxNumPic = 5 then
				se_idx := 3;
			else
				se_idx := 11;
			end
		end
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/
	 int(size= 8) slice_qp;
	 int(size= 8) slice_cb_qp_offset;
	 int(size= 8) slice_cr_qp_offset;
	uint(size=16) MaxNumMergeCand;
	uint(size= 1) cabac_init_flag;
        uint(size= 1) collocated_from_lX := 0;
        uint(size= 3) collocated_ref_idx := 0;
	 	
	read_SliceHeader.se_idx_3 : action ==> WeightedPredLuma:[weighted_pred_flag], WeightedPredChroma:[weighted_pred_flag]
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 2) weighted_pred_flag := 0,
                uint(size= 1) collocated_from_l0_flag := 1
   	do	
        		collocated_from_lX := 0;
        		collocated_ref_idx := 0;
   		cabac_init_flag := 0;
   		se_idx := 5;
   		
		if slice_type = P_SLICE or slice_type = B_SLICE then
			if pps_cabac_init_present_flag[pps_id] = 1	then
				vld_u_name(  1, fifo, res, "cabac_init_flag                         ");	
				cabac_init_flag := res[0];
			end
			if slice_temporal_mvp_enable_flag = 1 then
				res[0] := 1;
				if( slice_type = B_SLICE ) then	
					vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 ");
					collocated_from_l0_flag := res[0];
					collocated_from_lX := res[0];
				end
				if ( collocated_from_l0_flag = 1 and num_ref_idx_l0_active > 1 ) or ( collocated_from_l0_flag = 0 and num_ref_idx_l1_active > 1 ) then
					vld_ue_name(    fifo, res, "collocated_ref_idx                      ");
					collocated_ref_idx := res[0];
				end
			end
			if pps_weighted_pred_flag[pps_id] = 1 or pps_weighted_bipred_flag[pps_id] = 1 then 
				weighted_pred_flag := 1;
			end
			
			if weighted_pred_flag != 0 then
		   		se_idx := 4;
			end
		end
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_4
	 *************************************************************************/
	uint(size= 1) luma_weight_l0_flag[16];
	uint(size= 1) chroma_weight_l0_flag[16];
	 int(size= 8) delta_luma_weight_l0;
	 int(size= 8) luma_offset_l0;
	 int(size= 8) delta_chroma_weight_l00;
	 int(size= 8) delta_chroma_weight_l01;
	 int(size= 10) delta_chroma_offset_l00;
	 int(size= 10) delta_chroma_offset_l01;
	 
	uint(size= 1) luma_weight_l1_flag[16];
	uint(size= 1) chroma_weight_l1_flag[16];
	 int(size= 8) delta_luma_weight_l1;
	 int(size= 8) luma_offset_l1;
	 int(size= 8) delta_chroma_weight_l10;
	 int(size= 8) delta_chroma_weight_l11;
	 int(size= 10) delta_chroma_offset_l10;
	 int(size= 10) delta_chroma_offset_l11;
	 
	read_SliceHeader.se_idx_40 : action ==> WeightedPredLuma:[luma_log2_weight_denom, delta_chroma_log2_weight_denom],
											 WeightedPredChroma:[luma_log2_weight_denom, delta_chroma_log2_weight_denom]
	guard
		se_idx = 4 and isFifoFull(fifo),
		slice_type = P_SLICE or slice_type = B_SLICE,
		(pps_weighted_pred_flag[pps_id] = 1 and slice_type = P_SLICE) or ( pps_weighted_bipred_flag[pps_id] = 1 and slice_type = B_SLICE )
	var
		uint(size=32) res[1],
		uint(size= 3) luma_log2_weight_denom := 0,
		 int(size= 4) delta_chroma_log2_weight_denom :=0
   	do		
		vld_ue_name(    fifo, res, "luma_log2_weight_denom                  ");					
		luma_log2_weight_denom := res[0];
        if sps_chroma_format_idc[sps_id] != 0 then
			vld_se_name(    fifo, res, "delta_chroma_log2_weight_denom          ");					
			delta_chroma_log2_weight_denom := res[0];
		end
		se_idx := 41;
	end
	
	read_SliceHeader.se_idx_41 : action ==> WeightedPredLuma:[luma_weight_l0_flag[cnt_i - 1]]
	guard
		se_idx = 41 and isFifoFull(fifo),
		cnt_i <num_ref_idx_l0_active
	var 
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "luma_weight_lX_flag                     ");
		luma_weight_l0_flag[cnt_i] := res[0];
		cnt_i := cnt_i +1;
	end
	
	read_SliceHeader.se_idx_42 : action ==> 
	guard
		se_idx = 41 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
		se_idx := 43;
	end
	
	read_SliceHeader.se_idx_43 : action ==> WeightedPredChroma:[chroma_weight_l0_flag[cnt_i - 1]]
	guard
		se_idx = 43 and isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] = 1,
		cnt_i < num_ref_idx_l0_active
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "chroma_weight_lX_flag                   ");
		chroma_weight_l0_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;	
	end
	
	read_SliceHeader.se_idx_44 : action ==>
	guard
		se_idx = 43 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
		se_idx := 45;
	end
	
	
	read_SliceHeader.se_idx_45_skip_loop : action ==>
	guard
		se_idx = 45 and isFifoFull(fifo),
		luma_weight_l0_flag[cnt_i] = 0,
		chroma_weight_l0_flag[cnt_i] = 0,
		cnt_i < num_ref_idx_l0_active
	do
		cnt_i := cnt_i + 1;
	end
	
	read_SliceHeader.se_idx_45_skip_loop_done : action ==>
	guard
		se_idx = 45 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active,
		slice_type = B_SLICE
	do
		cnt_i := 0;
		se_idx := 48;
	end
	
	read_SliceHeader.se_idx_45_skip_all : action ==>
	guard
		se_idx = 45 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active,
		slice_type != B_SLICE
	do
		cnt_i := 0;
		se_idx := 5;
	end
	
	read_SliceHeader.se_idx_45 : action ==> WeightedPredLuma:[delta_luma_weight_l0, luma_offset_l0]
	guard
		se_idx = 45 and isFifoFull(fifo),
		luma_weight_l0_flag[cnt_i] = 1,
		cnt_i < num_ref_idx_l0_active
	var
		uint(size=32) res[1]
	do	
		vld_se_name(    fifo, res, "delta_luma_weight_lX                    ");
		delta_luma_weight_l0 := res[0];
		vld_se_name(    fifo, res, "luma_offset_lX                          ");
		luma_offset_l0 := res[0];
		se_idx := 46;
	end
	
	read_SliceHeader.se_idx_45_skip : action ==> 
	guard
		se_idx = 45 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		luma_weight_l0_flag[cnt_i] = 0
	do
		se_idx := 46;
	end
	
	read_SliceHeader.se_idx_46_skip : action ==>
	guard
		se_idx = 46 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 0
	do
		cnt_i := cnt_i + 1;
		se_idx := 45;
	end
	
	read_SliceHeader.se_idx_46 : action ==> WeightedPredChroma:[delta_chroma_weight_l00]
	guard
		se_idx = 46 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do	
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l00 := res[0];
		se_idx := 47;
	end
	
	read_SliceHeader.se_idx_47 : action ==> WeightedPredChroma:[delta_chroma_offset_l00, delta_chroma_weight_l01, delta_chroma_offset_l01]
	guard
		se_idx = 47 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do	
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l00 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l01 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l01 := res[0];		
		cnt_i := cnt_i + 1;
		se_idx := 45;
	end
	
	
	
	read_SliceHeader.se_idx_48 : action ==>  WeightedPredLuma:[luma_weight_l1_flag[cnt_i-1]]
	guard
		se_idx = 48 and isFifoFull(fifo),
		slice_type = B_SLICE,
		cnt_i < num_ref_idx_l1_active
	var
		uint(size=32) res[1]
	do	
		vld_u_name(  1, fifo, res, "luma_weight_lX_flag                     ");
		luma_weight_l1_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end
			
	read_SliceHeader.se_idx_49 : action ==> 
	guard
		se_idx = 48 and isFifoFull(fifo),
		slice_type = B_SLICE,
		cnt_i = num_ref_idx_l1_active
	do	
		cnt_i := 0;
		se_idx := 50;
	end
	
	read_SliceHeader.se_idx_50_skip : action ==>  
	guard
		se_idx = 50 and isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] = 0
	do		
		cnt_i := 0;
		se_idx := 52;
	end
	
	read_SliceHeader.se_idx_50 : action ==>  WeightedPredChroma:[chroma_weight_l1_flag[cnt_i - 1]]
	guard
		se_idx = 50 and isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] != 0,
		cnt_i < num_ref_idx_l1_active
	var
		uint(size=32) res[1]
	do		
		vld_u_name(  1, fifo, res, "chroma_weight_lX_flag                   ");
		chroma_weight_l1_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end
	
	read_SliceHeader.se_idx_51 : action ==>  
	guard
		se_idx = 50 and isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] != 0,
		cnt_i = num_ref_idx_l1_active
	do		
		cnt_i := 0;
		se_idx := 52;
	end
	
	read_SliceHeader.se_idx_52_skip_loop : action ==>
	guard
		se_idx = 52 and isFifoFull(fifo),
		luma_weight_l1_flag[cnt_i] = 0,
		chroma_weight_l1_flag[cnt_i] = 0,
		cnt_i < num_ref_idx_l1_active
	do
		cnt_i := cnt_i + 1;
	end
	
	read_SliceHeader.se_idx_52_skip_loop_done : action ==>
	guard
		se_idx = 52 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
		se_idx := 5;
	end
	
	read_SliceHeader.se_idx_52 : action ==> WeightedPredLuma:[delta_luma_weight_l1, luma_offset_l1]
	guard
		se_idx = 52 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		luma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_luma_weight_lX                    ");
		delta_luma_weight_l1 := res[0];
		vld_se_name(    fifo, res, "luma_offset_lX                          ");
		luma_offset_l1 := res[0];
		se_idx := 53;
	end
	
	read_SliceHeader.se_idx_52_skip : action ==> 
	guard
		se_idx = 52 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		luma_weight_l1_flag[cnt_i] = 0
	do
		se_idx := 53;
	end
	
	read_SliceHeader.se_idx_53_skip : action ==>
	guard
		se_idx = 53 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 0
	do
		cnt_i := cnt_i + 1;
		se_idx := 52;
	end
	
	read_SliceHeader.se_idx_53 : action ==> WeightedPredChroma:[delta_chroma_weight_l10]
	guard
		se_idx = 53 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do	
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l10 := res[0];
		se_idx := 54;
	end
	
	read_SliceHeader.se_idx_54 : action ==> WeightedPredChroma:[delta_chroma_offset_l10,delta_chroma_weight_l11,delta_chroma_offset_l11]
	guard
		se_idx = 54 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do	
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l10 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l11 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l11 := res[0];
		cnt_i := cnt_i + 1;
		se_idx := 52;
	end

		uint(size=16) qp_bd_offset_luma;
	/**************************************************************************
	 * read_SliceHeader.se_idx_5
	 *************************************************************************/
	read_SliceHeader.se_idx_5 : action ==> DBFDisable:[slice_disable_deblocking_filter_flag !=0],
		DbfSe:[betaOff, tcOff, pps_cb_qp_offset[pps_id] + slice_cb_qp_offset, pps_cr_qp_offset[pps_id] + slice_cr_qp_offset]
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) slice_disable_deblocking_filter_flag := pps_disable_deblocking_filter_flag[pps_id],
		int(size=8) betaOff := pps_beta_offset[pps_id],
		int(size=8) tcOff := pps_tc_offset[pps_id]
   	do	
		if slice_type = P_SLICE or slice_type = B_SLICE then
			vld_ue_name(    fifo, res, "five_minus_max_num_merge_cand           ");
			MaxNumMergeCand := 5 - res[0];
		end
		vld_se_name(    fifo, res, "slice_qp_delta                          ");
		slice_qp := pps_init_qp_minus26[pps_id] + 26 +res[0];
		slice_cb_qp_offset := 0;
		slice_cr_qp_offset := 0;
                qp_y := slice_qp;
                qp_bd_offset_luma           := 6 * sps_bit_depth_luma_minus8[sps_id];
                if pps_cu_qp_delta_enabled_flag[pps_id] = 0 then
		            qp_y    := ((slice_qp + 52 + 2 * qp_bd_offset_luma) mod (52 + qp_bd_offset_luma)) - qp_bd_offset_luma;
				end
		if pps_slice_chroma_qp_offsets_present_flag[pps_id] = 1 then
			vld_se_name(    fifo, res, "slice_cb_qp_offset                      ");
			slice_cb_qp_offset := res[0];
			vld_se_name(    fifo, res, "slice_cr_qp_offset                      ");
			slice_cr_qp_offset := res[0];
		end
		if(pps_deblocking_filter_control_present_flag[pps_id] = 1) then	
           res[0] := 0;
            if(deblocking_filter_override_enabled_flag[pps_id] = 1) then
                		vld_u_name(1, fifo, res,
                		"deblocking_filter_override_flag         ");
            end
            if res[0] = 1 then
                		vld_u_name(1, fifo, res,
                		"slice_disable_deblocking_filter_flag    ");
                slice_disable_deblocking_filter_flag := res[0];
				if( slice_disable_deblocking_filter_flag = 0) then
                			vld_se_name(fifo, res,
                			"beta_offset_div2                        ");
					betaOff := res[0] << 1;
                			vld_se_name(fifo, res,
                			"tc_offset_div2                          ");
					tcOff := res[0] << 1;
				end
			end
		end	
                if (pps_loop_filter_across_slice_enabled_flag[sps_id] = 1 and
                (slice_sample_adaptive_offset_flag[0] = 1 or
                slice_sample_adaptive_offset_flag[1] = 1 or
                slice_disable_deblocking_filter_flag = 0)) then
                	vld_u_name(1, fifo, res,
                	"slice_loop_filter_across_slices_enabled_flag");
 		end
 		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/	
//         procedure initWpScaling()
//         begin
//                foreach uint(size=8) e in 0 .. 1 do
//                        foreach uint(size=8) i in 0 .. MAX_NUM_REF-1 do
//                                foreach uint(size=8) yuv in 0 .. 2 do
//                                        if wp[e][i][yuv][WP_PRESENT_FLAG] = 1 then
//                                                wp[e][i][yuv][WP_I_WEIGHT] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]);
//                                                wp[e][i][yuv][WP_I_OFFSET] := 0;
//                                        end
//                                        wp[e][i][yuv][WP_W]     := wp[e][i][yuv][WP_I_WEIGHT];
//                                        wp[e][i][yuv][WP_O]     := wp[e][i][yuv][WP_I_OFFSET] * (1);
//                                        wp[e][i][yuv][WP_SHIFT] := wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM];
//                                        if wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM] >= 1 then
//                                                wp[e][i][yuv][WP_ROUND] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]) - 1;
//                                        else
//                                                wp[e][i][yuv][WP_ROUND] := 0;
//                                        end
//                                end
//                        end
//                end
//        end
	uint(size=16) num_entry_point_offsets := 0;
	uint(size=16) offset_len;
	uint(size= 8) slice_segment_header_extension_length;
	uint num_entry_offsets := 0;
	
        read_SliceHeader.se_idx_6 : action ==> TilesCoord:[num_entry_offsets], RealTilesCoord:[num_entry_offsets]
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		se_idx := 8;
                if pps_tiles_enabled_flag[pps_id] = 1 or
                pps_entropy_coding_sync_enabled_flag[pps_id] = 1 then
			vld_ue_name(    fifo, res, "num_entry_point_offsets                 ");
    		num_entry_point_offsets := res[0];
    		if num_entry_point_offsets > NUM_ENTRY_MAX then
    			println("ERROR: fix NUM_ENTRY_MAX");
    		end
    		if num_entry_point_offsets > 0 then
				vld_ue_name(    fifo, res, "offset_len_minus1                       ");
				offset_len := res[0]+1;
				se_idx := 7;
    		end
    	end
    	
    	if TILE_SPLIT_ENABLE != 0 then
                        num_entry_offsets := 1;
		else
                        num_entry_offsets := (pps_num_tile_columns_minus1[pps_id] + 1) * (pps_num_tile_rows_minus1[pps_id] + 1);
		end
    end
    
    read_SliceHeader.se_idx_7_loop : action ==> 
	guard
		se_idx = 7 and isFifoFull(fifo), cnt_i < num_entry_point_offsets
	var
		uint(size=32) res[1]
	do
		if offset_len > 32 then
			println("ERROR with vld_ue : check offset_len size");
		end
		vld_u_name(  offset_len, fifo, res, "entry_point_offset                      ");
		entryOffsetsTab[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end
	
	read_SliceHeader.se_idx_7_endLoop : action ==> 
	guard
		se_idx = 7 and isFifoFull(fifo), cnt_i = num_entry_point_offsets
	do
		cnt_i := 0;
		se_idx := 8;
	end
	
	read_SliceHeader.se_idx_8 : action ==> 
    guard
		se_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
	    se_idx := 100;
    	if pps_slice_segment_header_extension_present_flag[pps_id] = 1 then
            vld_ue_name(    fifo, res, "slice_segment_header_extension_length   ");
            slice_segment_header_extension_length := res[0];
            se_idx := 9;                            
        end
    end
    
    read_SliceHeader.se_idx_9_loop : action ==> 
    guard
		se_idx = 9 and isFifoFull(fifo), cnt_i < slice_segment_header_extension_length
	var
		uint(size=32) res[1]
	do
    	vld_u_name(  8, fifo, res, "slice_segment_header_extension_data_byte");
    end
    
    read_SliceHeader.se_idx_9_endLoop : action ==> 
    guard
		se_idx = 9 and isFifoFull(fifo), cnt_i = slice_segment_header_extension_length
	do
    	cnt_i := 0;
    	se_idx := 100;
    end
    
    uint totalByPass := 0;
    
	    read_SliceHeader_done : action ==> 
		StrongIntraSmoothing:[sps_strong_intra_smoothing_enable_flag[sps_id], pps_constrained_intra_pred_flag[pps_id]]
    guard
		se_idx = 100
	do
		if DEBUG_CABAC or CHECK_CABAC then
			println("\tPOC: "+poc);
		end
		sliceData_idx := 1;
		totalByPass := 0;
		if num_entry_point_offsets > 0 and TILE_SPLIT_ENABLE != 0 then //bypass
			if TilesInfo[1] != 0 then
				byPassFlag := true;
				byte_align(fifo);
				foreach int k in 0 .. TilesInfo[1] - 1 do
					totalByPass := totalByPass + entryOffsetsTab[k];
				end
			end
		end 	
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Slice Data                           *********************
	 **************************************************************************
	 *************************************************************************/
	int countAEB := 0;
	uint(size= 9) codIRange[1];
	uint(size=16) codIOffset[1];
	uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX];
	uint(size= 9) ctxTableWPP[NB_MAX_SE][NB_MAX_NUM_CTX];
	uint(size= 8) sliceData_idx;

	/**************************************************************************
	 * read_SliceData.init
	 *************************************************************************/	
	//bool          isNotFirstSlice := (first_slice_segment_in_pic_flag = 0);
	uint(size= 8) prev_pps_id;
	
	uint(size= 8) Log2MinTrafoSize;
	uint(size= 8) Log2MaxTrafoSize;
	uint(size=16) ctbAddrRStoTS[CTB_ADDR_TS_MAX];
	uint(size=16) ctbAddrTStoRS[CTB_ADDR_TS_MAX];
	uint(size=16) TileId[CTB_ADDR_TS_MAX];
	uint(size=16) nbCtbTile[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
	uint(size=16) colTileInPix[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
	uint(size=16) rowTileInPix[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
	uint tile_idx := 0;
	uint(size= 1) skip_flag_tab[PICT_WIDTH][2];
	uint(size= 8) intraPredMode[PICT_WIDTH][2];
	uint(size=16) colWidth[PICT_WIDTH / MIN_CTB_SIZE_Y];
	uint(size=16) rowHeight[PICT_HEIGHT / MIN_CTB_SIZE_Y];

        read_SliceData.init: action ==> IsPicSlcLcu:[0], MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id], slice_temporal_mvp_enable_flag ,collocated_from_lX , collocated_ref_idx],
        								SaoSeLuma:[slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1)], 
        								SaoSeChromaU:[slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1)],
        								SaoSeChromaV:[slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1)]
	guard
		sliceData_idx = 1 and isFifoFull(fifo),
		first_slice_segment_in_pic_flag = 1 or prev_pps_id != pps_id
	var
		uint(size= 8) num_tile_columns_minus1		= pps_num_tile_columns_minus1[pps_id],
		uint(size= 8) num_tile_rows_minus1			= pps_num_tile_rows_minus1[pps_id],
		uint(size=16) ColBd[PICT_WIDTH / MIN_CTB_SIZE_Y],
		uint(size=16) RowBd[PICT_HEIGHT / MIN_CTB_SIZE_Y],
		uint(size=16) tileX,
		uint(size=16) tileY,
		uint(size=16) val,
		uint(size=16) tbX,
		uint(size=16) tbY,
		uint(size=16) tIdx,
		uint count :=0
	do
        	
		//isNotFirstSlice   := true;
		prev_pps_id       := pps_id;
        skip_flag_tab := [ [ 0 : for int j in 0 .. 1 ] : for int i in 0 .. PICT_WIDTH - 1 ];
        intraPredMode := [ [ INTRA_DC : for int j in 0 .. 1 ] : for int i in 0 .. PICT_WIDTH - 1 ];
        Log2MinTrafoSize  := sps_log2_min_transform_block_size[sps_id] ;
        Log2MaxTrafoSize := Log2MinTrafoSize +
        sps_log2_diff_max_min_transform_block_size[sps_id];
		foreach int i in 0 .. num_tile_rows_minus1 do
			foreach int j in 0 .. num_tile_columns_minus1 do
				if count = 0 then
					nbCtbTile[count] := rowHeight[ i ] * colWidth[ j ];
				else
                	nbCtbTile[count] := nbCtbTile[count - 1] + rowHeight[i] *
                	colWidth[j];
                end //println("nbCtbTile[count]"+nbCtbTile[count]);
				count := count + 1;
			end
		end
		ColBd[ 0 ] := 0;
		foreach int i in 0 .. num_tile_columns_minus1 do
			ColBd[ i + 1 ] := ColBd[ i ] + colWidth[ i ];
		end
		RowBd[ 0 ] := 0;
		foreach int i in 0 .. num_tile_rows_minus1 do
			RowBd[ i + 1 ] := RowBd[ i ] + rowHeight[ i ];
		end

		/*********************************************************************
		 * 6.5 Conversion process for coding tree block address 
		 * in coding tree block raster order to tile scan order
		 ********************************************************************/
		if PicHeightInCtbsY * PicWidthInCtbsY >= CTB_ADDR_TS_MAX then
			println("Error read_SliceData.init : CtbAddrTS : "+(PicHeightInCtbsY * PicWidthInCtbsY)+" >= "+CTB_ADDR_TS_MAX);
		end
		foreach int ctbAddrRS_v in 0 .. PicSizeInCtbsY - 1 do
			tbX   := ctbAddrRS_v mod PicWidthInCtbsY;
			tbY   := ctbAddrRS_v / PicWidthInCtbsY;
			tileX := 0;
			tileY := 0;
			foreach int i in 0 .. num_tile_columns_minus1 do
				if tbX < ColBd[i + 1] then
					tileX := i;
					i := num_tile_columns_minus1;
				end
			end
			foreach int j in 0 .. num_tile_rows_minus1 do
				if tbY < RowBd[j + 1] then
					tileY := j;
					j := num_tile_rows_minus1;
				end
			end
			val := 0;
			foreach int i in 0 .. tileX-1 do
				val := val + rowHeight[ tileY ] * colWidth[ i ];
			end
			foreach int j in 0 .. tileY-1 do
				val := val + PicWidthInCtbsY * rowHeight[ j ];
			end
			val 						 := val + ( tbY - RowBd[tileY] ) * colWidth[tileX] + tbX - ColBd[tileX];
			ctbAddrRStoTS[ ctbAddrRS_v ] := val;
			ctbAddrTStoRS[ val ] 		 := ctbAddrRS_v;			
		end
		
		tIdx := 0;
		foreach int j in 0 .. num_tile_rows_minus1 do
			foreach int i in 0 .. num_tile_columns_minus1 do
				foreach int y in RowBd[ j ] .. RowBd[ j + 1 ] - 1 do
					foreach int x in ColBd[ i ] .. ColBd[ i + 1 ] - 1 do
						TileId[ ctbAddrRStoTS[ y*PicWidthInCtbsY + x ] ] := tIdx;						
					end
				end
				tIdx := tIdx + 1;
			end
		end
		InitScanningArray(ScanOrder);
		if num_entry_point_offsets > 0 then
			sliceData_idx := 20;
		else
			sliceData_idx := 21;
		end
	end
	
	read_SliceData.sendInfoSlice: action ==> TilesCoord:[0 ,0 ,pictSize[0] ,pictSize[1]]
	guard 
		sliceData_idx = 21
	do
		sliceData_idx := 2;
	end
	
	uint countRow := 0;
	uint countCol := 0;
	
	read_SliceData.sendInfoTilesLoop: action ==> TilesCoord:[x0 ,y0 ,x1 ,y1]
	guard 
                sliceData_idx = 20,  cnt_i < num_entry_offsets 
	var
		uint x0 := 0,
		uint y0 := 0,
		uint x1 := pictSize[0],
		uint y1 := pictSize[1]
	do
		//colTileInPix[0] :=0;
		x0 := colTileInPix[countCol];
		x1 := colTileInPix[countCol + 1];
		y0 := rowTileInPix[countRow];
		y1 := rowTileInPix[countRow + 1];
		
		countCol := countCol + 1;
		if countCol  = pps_num_tile_columns_minus1[pps_id]+1 then
			countCol := 0;
			countRow := countRow + 1;
		end
		cnt_i := cnt_i + 1;
		if TILE_SPLIT_ENABLE = 1 then
			x0 := 0;
			x1 := pictOrTileSize[0];
			y0 := 0;
			y1 := pictOrTileSize[1];
		end
	end
	
	read_SliceData.sendRealInfoTilesLoop: action ==> RealTilesCoord:[x0 ,y0 ,x1 ,y1]
	guard 
                sliceData_idx = 22,  cnt_i < num_entry_offsets 
	var
		uint x0 := 0,
		uint y0 := 0,
		uint x1 := pictSize[0],
		uint y1 := pictSize[1]
	do
		x0 := colTileInPix[countCol];
		x1 := colTileInPix[countCol + 1];
		y0 := rowTileInPix[countRow];
		y1 := rowTileInPix[countRow + 1];
		
		countCol := countCol + 1;
		if countCol  = pps_num_tile_columns_minus1[pps_id]+1 then
			countCol := 0;
			countRow := countRow + 1;
		end
		cnt_i := cnt_i + 1;
	end
	
	read_SliceData.senInfoTilesEnd: action ==> 
	guard 
                sliceData_idx = 20,  cnt_i = num_entry_offsets 
	do
		countCol := 0;
		countRow := 0;
		cnt_i    := 0;
		sliceData_idx := 22;
	end
	
	read_SliceData.senRealInfoTilesEnd: action ==> 
	guard 
                sliceData_idx = 22,  cnt_i = num_entry_offsets 
	do
		countCol := 0;
		countRow := 0;
		cnt_i    := 0;
		sliceData_idx := 2;
	end
		
        read_SliceData.noInit: action ==> MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id], slice_temporal_mvp_enable_flag]
	guard
		sliceData_idx = 1,
        first_slice_segment_in_pic_flag = 0 and dependent_slice_segment_flag = 1 and prev_pps_id = pps_id
	do
        if num_entry_offsets > 0 then
            sliceData_idx := 20;
        else
            sliceData_idx := 21;
        end
    end
        
        read_SliceData.noInit_isSlc: action ==> MvPredSyntaxElem:[pps_log2_parallel_merge_level[pps_id],slice_temporal_mvp_enable_flag, collocated_from_lX , collocated_ref_idx],
        										IsPicSlcLcu:[1]
        										//SaoSe:[ slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1)],
        										//LFAcrossSlcTile:[pps_loop_filter_across_slice_enabled_flag[pps_id] + (pps_loop_filter_across_slice_enabled_flag[pps_id]<<1)]
        guard
            sliceData_idx = 1,
            first_slice_segment_in_pic_flag = 0 and dependent_slice_segment_flag = 0 and prev_pps_id = pps_id
        do
        		
		if num_entry_point_offsets > 0 then
			sliceData_idx := 20;
		else
			sliceData_idx := 21;
		end
	end
	/**************************************************************************
	 * read_SliceData.start
	 *************************************************************************/	
	//bool flag := true;
	uint(size=32) CtbAddrRS;
	uint(size=32) CtbAddrTS;
	uint(size=32) end_of_slice_flag;
	 
	read_SliceData.start : action ==> SliceAddr:[xCtb, yCtb]
	guard
		sliceData_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=32) CtbSize = 1 << Log2CtbSize
	do
		showBits(8, fifo, res);
		//println("showbits8Start = " + res[0]);
				//println("initTab");
		CtbAddrRS     := slice_segment_address;
		CtbAddrTS     := ctbAddrRStoTS[CtbAddrRS];
		xCtb           := InverseRasterScan( CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 0 ) ;
		yCtb           := InverseRasterScan( CtbAddrRS, CtbSize, CtbSize, sps_pic_width_in_luma_samples[sps_id], 1 ) ;
		end_of_slice_flag  := 0;
		sliceData_idx := 3;
	end
	/**************************************************************************
	 * read_SliceData_gotoCodingTree
	 *************************************************************************/	
	read_SliceData_gotoCodingTree.start : action ==>
	guard
		sliceData_idx = 3, byPassFlag = false
	do
		sliceData_idx  := 4;
		codingTree_idx := 1;
	end
	
	read_SliceData_gotoCodingTree.byPass : action ==>
	guard
		sliceData_idx = 3, byPassFlag = true
	do
		sliceData_idx  := 4;
		codingTree_idx := 0;
	end
	
	read_CodingTree.byPassBeforeTileLoop: action ==> 
	guard
		codingTree_idx = 0 and isFifoFull(fifo), cnt_i < totalByPass + TilesInfo[1] 
	do
		if (localizeAEB & 1) = 0 then 
			flushBits_name(8, fifo, "bypassed");
		else
			countAEB := countAEB + 1;
		end
		//println("bypassed " + cnt_i);
		cnt_i := cnt_i + 1;
	end

	read_CodingTree.byPassBeforeTileEnd: action ==> 
	guard
		codingTree_idx = 0 and isFifoFull(fifo), cnt_i = totalByPass + TilesInfo[1] 
	do
		//println("totalByPass = " +totalByPass);
		cnt_i := 0;
		byPassFlag := false;
		codingTree_idx := 1;
		//flushBits_name(8, fifo, "bypassed");
		tile_idx := TilesInfo [1];
		CtbAddrTS := nbCtbTile[tile_idx - 1];
		//println("CtbAddrTS" + CtbAddrTS);
		CtbAddrRS := ctbAddrTStoRS[CtbAddrTS];
		//println("CtbAddrRS" + CtbAddrRS);
	end	
	
        int counter := 0;

	read_SliceData.retCodingTree : action ==>
	guard
		sliceData_idx = 4 and isFifoFull(fifo)
	var
		uint(size=32) res[1] := [0]
	do
		//println("retcodingtree"); 
		get_END_OF_SLICE_FLAG(codIRange, codIOffset, fifo, res);
		end_of_slice_flag := res[0];
		CtbAddrTS := CtbAddrTS + 1;
		CtbAddrRS := ctbAddrTStoRS[CtbAddrTS];
	 	if end_of_slice_flag = 0 then
			if pps_entropy_coding_sync_enabled_flag[pps_id] = 1 and (CtbAddrTS mod PicWidthInCtbsY) = 2 then
				ctxTableWPP := [[ctxTable[i][j]	    : for int j in 0 .. NB_MAX_NUM_CTX-1] : for int i in 0 .. NB_MAX_SE-1];
			end
			sliceData_idx := 3;
			if pps_tiles_enabled_flag[pps_id] = 1 and (TileId[ CtbAddrTS ] != TileId[ CtbAddrTS - 1]) then
	 			//println("endOfTile ###################################################"); 
	 			if TILE_SPLIT_ENABLE = 0 then
	 				sliceData_idx := 3;
	 			else
	 				sliceData_idx := 5;
				end
			end
		else
			//println("endOfSlice ################################################### counter = " + counter);
                        counter := counter + 1;
			sliceData_idx := 5;
			//curr_Tile := 0;
			CtbAddrTS := 0;
			CtbAddrRS := 0;
			//numByPassBytes := [0: for int i in 0 .. MAX_NUM_TILES - 1];
			byPassFlag := false;
		end
	end
	/**************************************************************************
	 * read_SliceData_end
	 *************************************************************************/	
	read_SliceData_end: action ==>
	guard
		sliceData_idx = 5	
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Coding Tree                          *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size=16) xCtb;
	uint(size=16) yCtb;
	uint(size=32) CtbAddrInSlice;
	uint(size= 8) codingTree_idx;
	uint(size= 8) ctStack_idx;
	uint(size=16) ctStack[5][CT_STRUCT_SIZE];
        uint(size=8) first_qp_group;
	    bool ctb_left_flag;
	    bool ctb_up_flag;
	    int ctb_addr_in_slice ;
	/**************************************************************************
	 * read_CodingTree.start
	 *************************************************************************/	
	read_CodingTree.start : action ==>
	guard
		codingTree_idx = 1
	var
		uint(size=32) res[1],
		uint(size=32) CtbSize = 1 << Log2CtbSize,
        uint CtbAddrRS := ctbAddrTStoRS[CtbAddrTS],
        int tile_left_boundary,
        int tile_up_boundary,
        uint indexTS := 0,
        uint indexRS_0 := 0,
        uint indexRS_1 := 0
        do
            ctb_addr_in_slice := CtbAddrRS - slice_addr; //println("initcabac");
			if CtbAddrTS != 0 then
            	indexTS := CtbAddrTS -1;
            end
            if CtbAddrRS != 0 then
            	indexRS_0 := CtbAddrRS - 1;
            end
            if CtbAddrTS >= ctb_width then
            	indexRS_1 := CtbAddrTS - ctb_width;
            end
                
            xCtb := InverseRasterScan(CtbAddrRS, CtbSize, CtbSize,
            sps_pic_width_in_luma_samples[sps_id], 0);
            yCtb := InverseRasterScan(CtbAddrRS, CtbSize, CtbSize,
            sps_pic_width_in_luma_samples[sps_id], 1);
            if pps_entropy_coding_sync_enabled_flag[pps_id] = 1 then
            	if (xCtb = 0 and (yCtb & (CtbSize - 1)) = 0) then
            		first_qp_group := 1;
            	end
            	elsif pps_tiles_enabled_flag[pps_id] = 1 then if (CtbAddrTS
            	!= 0 and TileId[CtbAddrTS] != TileId[indexTS]) then
            		first_qp_group := 1;
            	end
            end
            if (pps_tiles_enabled_flag[pps_id] = 1) then
            	tile_left_boundary := if (xCtb > 0 && TileId[CtbAddrTS] !=
            	TileId[ctbAddrRStoTS[indexRS_0]]) then
            		1
            	else
            		0
            	end;
            	tile_up_boundary := if (yCtb > 0 && TileId[CtbAddrTS] !=
            	TileId[ctbAddrRStoTS[indexRS_1]]) then
            		1
            	else
            		0
            	end;
            else
            	tile_left_boundary := 0;
            	tile_up_boundary := 0;
            end
            ctb_left_flag := (xCtb > 0) and (ctb_addr_in_slice > 0) and
            (tile_left_boundary = 0);
            ctb_up_flag := (yCtb > 0) && (ctb_addr_in_slice >= ctb_width)
            && tile_up_boundary = 0;

			CtbAddrInSlice := CtbAddrRS - slice_segment_address;
			codingTree_idx := 2;
            if CtbAddrTS = ctbAddrRStoTS[slice_segment_address] then //                      println("codIRangeINITCABACbegin := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
            	decodeStart(codIRange, codIOffset, fifo); //                      println("codIRangeINITCABAC1 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
            	if (dependent_slice_segment_flag = 0 or
            	(pps_tiles_enabled_flag[pps_id] = 1 and (TileId[CtbAddrTS] !=
            	TileId[indexTS]))) then
            		contextInit(slice_qp, slice_type, ctxTable,
            		cabac_init_flag); //                              println("codIRangeINITCABAC2 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
			end
            	if first_slice_segment_in_pic_flag = 0 and
            	pps_entropy_coding_sync_enabled_flag[pps_id] = 1 then
				if (CtbAddrTS mod PicWidthInCtbsY) = 0 then
					if PicWidthInCtbsY = 1 then
            				contextInit(slice_qp, slice_type, ctxTable,
            				cabac_init_flag); //                                              println("codIRangeINITCABAC3 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
            			else
            				if dependent_slice_segment_flag = 1 then
            					ctxTable := [ [ ctxTableWPP[i][j] : for int j in 0 ..
            					NB_MAX_NUM_CTX - 1 ] : for int i in 0 .. NB_MAX_SE - 1 ];
						 end
					end
				end
			end
		else 
        	if CtbAddrTS = 0 or pps_tiles_enabled_flag[pps_id] = 1 and
        	(TileId[CtbAddrTS] != TileId[indexTS]) then //showBits(9, fifo, res);
			//println("showbits9 = " + res[0]);
    		decodeReInit(codIRange, codIOffset, fifo); //                              println("codIRangeINITCABAC4 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
    		contextInit(slice_qp, slice_type, ctxTable, cabac_init_flag); //                              println("codIRangeINITCABAC5 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
			end
			if pps_entropy_coding_sync_enabled_flag[pps_id] = 1 then
				if (CtbAddrTS mod PicWidthInCtbsY) = 0 then
	        		get_END_OF_SUB_STREAM_ONE_BIT(codIRange, codIOffset, fifo, res);
	        		decodeReInit(codIRange, codIOffset, fifo); //                                      println("codIRangeINITCABAC6 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
					if PicWidthInCtbsY = 1 then
	    				contextInit(slice_qp, slice_type, ctxTable,
	    				cabac_init_flag); //                                              println("codIRangeINITCABAC7 := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
					else
	    				ctxTable := [ [ ctxTableWPP[i][j] : for int j in 0 ..
	    				NB_MAX_NUM_CTX - 1 ] : for int i in 0 .. NB_MAX_SE - 1 ];
			 		end
			 	end 	
			end
		end
//		println("codIRangeINITCABACfinal := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
	end
	/**************************************************************************
	 * read_CodingTree_gotoSaoParam
	 *************************************************************************/	
	read_CodingTree_gotoSaoParam : action ==>
	guard
		codingTree_idx = 2,
		slice_sample_adaptive_offset_flag[0] = 1 or slice_sample_adaptive_offset_flag[1] = 1
	do
		codingTree_idx	:= 3;
		sao_idx			:= 1;
		sao_rx			:= xCtb >> Log2CtbSize;
		sao_ry			:= yCtb >> Log2CtbSize;
		sao_cIdx		:= 0;
	end
	read_CodingTree.noGotoSaoParam : action ==>
	guard
		codingTree_idx = 2,
		slice_sample_adaptive_offset_flag[0] = 0 and slice_sample_adaptive_offset_flag[1] = 0
	do
		codingTree_idx := 3;
	end
	/**************************************************************************
	 * read_CodingTree_gotoCodingQuadTree
	 *************************************************************************/	
	read_CodingTree_gotoCodingQuadTree : action ==>  IsPicSlcLcu:[NEW_LCU]
	guard
		codingTree_idx = 3
	do
		codingTree_idx				:= 4;
		ctStack_idx					:= 0;
		ctStack[0][CT_idx]			:= 1;
		ctStack[0][CT_x0]			:= xCtb;
		ctStack[0][CT_y0]			:= yCtb;
		ctStack[0][CT_log2CbSize]	:= Log2CtbSize;
		ctStack[0][CT_ctDepth]		:= 0;
	end
	/**************************************************************************
	 * read_CodingTree_end
	 *************************************************************************/	
	read_CodingTree_end : action ==>
	guard
		codingTree_idx = 4
	end
	/**************************************************************************
	 **************************************************************************
	 ********        sao_param                            *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 3) sao_cIdx;
	uint(size=16) sao_rx;
	uint(size=16) sao_ry;
	uint(size= 8) sao_idx;
	/**************************************************************************
	 * read_SaoParam.start
	 *************************************************************************/	
	read_SaoParam.start : action ==> SaoSeChromaU:[sao_merge], SaoSeLuma:[sao_merge], SaoSeChromaV:[sao_merge]
	guard
		sao_idx = 1 and isFifoFull(fifo)
	var
		 int(size=32) res[1],
		uint(size= 1) sao_merge_left_flag	:= 0,
		uint(size= 1) sao_merge_up_flag		:= 0,
		 int(size= 9) sao_merge             := SAO_NO_MERGE,
		uint indexLeft := 0,
		uint indexUp   := 0
	do
        	if(pps_tiles_enabled_flag[pps_id] = 1) then
		if CtbAddrRS != 0 then
            indexLeft := CtbAddrRS - 1;
        end
        if CtbAddrRS >= PicWidthInCtbsY then
            indexUp   := CtbAddrRS - PicWidthInCtbsY;
        end
                ctb_left_flag := CtbAddrInSlice > 0 and (TileId[ CtbAddrTS ] = TileId[ ctbAddrRStoTS[ indexLeft ] ]);
                ctb_up_flag := CtbAddrInSlice >= PicWidthInCtbsY and (TileId[ CtbAddrTS ] = TileId[ ctbAddrRStoTS[ indexUp] ]);
			end
		if sao_rx > 0 then
                        if ctb_left_flag then
				get_SAO_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				sao_merge_left_flag := res[0];
				if sao_merge_left_flag = 1 then
				    sao_merge       := SAO_MERGE_LEFT;
				end
			end
		end
		if sao_ry > 0 and sao_merge_left_flag = 0 then
                        if ctb_up_flag then
				get_SAO_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				sao_merge_up_flag := res[0];
                if sao_merge_up_flag = 1 then
                    sao_merge     := SAO_MERGE_UP;
                end
			end
		end
		sao_idx  := 2;
		if sao_merge_left_flag = 0 and sao_merge_up_flag = 0 then
			sao_cIdx := 0;
		else 
			sao_cIdx := 3;
		end		
	end		
	/**************************************************************************
	 * read_SaoParam.loop
	 *************************************************************************/	
     int(size= 9) sao_typeIdx;
     int(size= 9) sao_eo;
    read_SaoParam.loop.luma : action ==> SaoSeLuma:[sao_typeIdx]
    guard
        sao_idx  = 2 and isFifoFull(fifo),
        sao_cIdx = 0 and sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 1
    var
         int(size=32) res[1]
    do
        if sao_cIdx != 2 then
            sao_typeIdx := SAO_NOT_APPLIED;
            get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, res);
            sao_typeIdx := res[0];
        end
        if sao_typeIdx != SAO_NOT_APPLIED then
            sao_idx := 3;
        else
            sao_cIdx := sao_cIdx + 1;
        end
    end

    read_SaoParam.loop.chromaU : action ==> SaoSeChromaU:[sao_typeIdx]
    guard
        sao_idx  = 2 and isFifoFull(fifo),
        sao_cIdx = 1 and sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 1
    var
         int(size=32) res[1]
    do
        if sao_cIdx != 2 then
            sao_typeIdx := SAO_NOT_APPLIED;
            get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, res);
            sao_typeIdx := res[0];
        end
        if sao_typeIdx != SAO_NOT_APPLIED then
            sao_idx := 4;
        else
            sao_cIdx := sao_cIdx + 1;
        end
    end

    read_SaoParam.loop.chromaV : action ==> SaoSeChromaV:[sao_typeIdx]
    guard
        sao_idx  = 2 and isFifoFull(fifo),
        sao_cIdx = 2 and sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 1
    var
         int(size=32) res[1]
    do
        if sao_cIdx != 2 then
            sao_typeIdx := SAO_NOT_APPLIED;
            get_SAO_TYPE_IDX(codIRange, codIOffset, ctxTable, fifo, res);
            sao_typeIdx := res[0];
        end
        if sao_typeIdx != SAO_NOT_APPLIED then
            sao_idx := 5;
        else
            sao_cIdx := sao_cIdx + 1;
        end
    end

	read_SaoParam.loop2_luma : action ==> SaoSeLuma:[offset[0],offset[1],offset[2],offset[3],sao_eo]
	guard
		sao_idx  = 3 and isFifoFull(fifo)
	var
		uint(size= 8) offsetTh   = (1<<3)-1,
		 int(size= 9) offset[4] := [0, 0, 0, 0],
		 int(size=32) res[1]    := [0]
	do
        foreach int i in 0 .. 3 do
            get_SAO_OFFSET_ABS(offsetTh, codIRange, codIOffset, fifo, res);            
            offset[i] := res[0];
        end
        if sao_typeIdx = SAO_BAND then
			foreach int i in 0 .. 3 do
				if offset[i] != 0 then
					get_SAO_OFFSET_SIGN(codIRange, codIOffset, fifo, res);
					if res[0] != 0 then
						offset[i] := -offset[i];
					end 
				end
			end
			get_SAO_BAND_POSITION(codIRange, codIOffset, fifo, res);
			sao_eo := res[0];
		else
		    offset[2] := -offset[2];
		    offset[3] := -offset[3];
			if sao_cIdx != 2 then
				get_SAO_EO(codIRange, codIOffset, fifo, res);
				sao_eo := res[0];
			end
		end
		sao_cIdx := sao_cIdx + 1;
        sao_idx  := 2;
	end

	read_SaoParam.loop2_chromaU : action ==> SaoSeChromaU:[offset[0],offset[1],offset[2],offset[3],sao_eo]
	guard
		sao_idx  = 4 and isFifoFull(fifo)
	var
		uint(size= 8) offsetTh   = (1<<3)-1,
		 int(size= 9) offset[4] := [0, 0, 0, 0],
		 int(size=32) res[1]    := [0]
	do
        foreach int i in 0 .. 3 do
            get_SAO_OFFSET_ABS(offsetTh, codIRange, codIOffset, fifo, res);            
            offset[i] := res[0];
        end
        if sao_typeIdx = SAO_BAND then
			foreach int i in 0 .. 3 do
				if offset[i] != 0 then
					get_SAO_OFFSET_SIGN(codIRange, codIOffset, fifo, res);
					if res[0] != 0 then
						offset[i] := -offset[i];
					end 
				end
			end
			get_SAO_BAND_POSITION(codIRange, codIOffset, fifo, res);
			sao_eo := res[0];
		else
		    offset[2] := -offset[2];
		    offset[3] := -offset[3];
			if sao_cIdx != 2 then
				get_SAO_EO(codIRange, codIOffset, fifo, res);
				sao_eo := res[0];
			end
		end
		sao_cIdx := sao_cIdx + 1;
        sao_idx  := 2;
	end

	read_SaoParam.loop2_chromaV : action ==> SaoSeChromaV:[offset[0],offset[1],offset[2],offset[3],sao_eo]
	guard
		sao_idx  = 5 and isFifoFull(fifo)
	var
		uint(size= 8) offsetTh   = (1<<3)-1,
		 int(size= 9) offset[4] := [0, 0, 0, 0],
		 int(size=32) res[1]    := [0]
	do
        foreach int i in 0 .. 3 do
            get_SAO_OFFSET_ABS(offsetTh, codIRange, codIOffset, fifo, res);            
            offset[i] := res[0];
        end
        if sao_typeIdx = SAO_BAND then
			foreach int i in 0 .. 3 do
				if offset[i] != 0 then
					get_SAO_OFFSET_SIGN(codIRange, codIOffset, fifo, res);
					if res[0] != 0 then
						offset[i] := -offset[i];
					end 
				end
			end
			get_SAO_BAND_POSITION(codIRange, codIOffset, fifo, res);
			sao_eo := res[0];
		else
		    offset[2] := -offset[2];
		    offset[3] := -offset[3];
			if sao_cIdx != 2 then
				get_SAO_EO(codIRange, codIOffset, fifo, res);
				sao_eo := res[0];
			end
		end
		sao_cIdx := sao_cIdx + 1;
        sao_idx  := 2;
	end

	read_SaoParam.nextLoop : action ==>
	guard
		sao_idx  = 2 ,
		sao_cIdx < 3 and slice_sample_adaptive_offset_flag[sao_cIdx] = 0
	do
		sao_cIdx := sao_cIdx + 1;
	end
	read_SaoParam_endLoop : action ==>
	guard
		sao_idx  = 2 ,
		sao_cIdx = 3
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Coding quadTree                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 1) IsCuQpDeltaCoded;
	 int(size=16) CuQpDelta;
         uint(size= 8) ct_log2CbSize;
	/**************************************************************************
	 * read_CodingQuadTree.start
	 *************************************************************************/	
	read_CodingQuadTree.start : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=16) ct_x0			= ctStack[ctStack_idx][CT_x0],
		uint(size=16) ct_y0			= ctStack[ctStack_idx][CT_y0],
		uint(size= 8) ct_ctDepth	= ctStack[ctStack_idx][CT_ctDepth],
		uint(size= 8) top_ctDepth	:= cu_top_ctDepth[ct_x0 >> Log2MinCbSize],
		uint(size= 8) left_ctDepth	:= cu_left_ctDepth[ct_y0 >> Log2MinCbSize],
		uint(size= 1) split_cu_flag,
		uint(size= 8) Log2MinCuQpDeltaSize = Log2CtbSize - pps_diff_cu_qp_delta_depth[pps_id],
		uint(size=16) tbX = ( (ct_x0>>Log2MinCbSize) << Log2MinCbSize ) >> Log2CtbSize,
		uint(size=16) tbY = ( (ct_y0>>Log2MinCbSize) << Log2MinCbSize ) >> Log2CtbSize,
		
		uint(size=16) MinCbAddrZS,
		uint(size=16) m,
		uint(size=16) x0b = ct_x0 & ((1 << Log2CtbSize) - 1),
    	uint(size=16) y0b = ct_y0 & ((1 << Log2CtbSize) - 1),
		uint indexLeft := 0,
		uint indexUp   :=0
	do
    	    ct_log2CbSize := ctStack[ctStack_idx][CT_log2CbSize];
		CtbAddrRS := PicWidthInCtbsY * tbY + tbX ;
    	    MinCbAddrZS := ctbAddrRStoTS[CtbAddrRS] << ((Log2CtbSize -
    	    Log2MinCbSize) * 2);
    	    if pps_tiles_enabled_flag[pps_id] = 1 or dependent_slice_segment_flag = 0 then
		if CtbAddrRS != 0 then
            indexLeft := CtbAddrRS - 1;
        end
        if CtbAddrRS >= PicWidthInCtbsY then
            indexUp   := CtbAddrRS - PicWidthInCtbsY;
        end
    	    	ctb_left_flag := (ct_x0 > 0) and CtbAddrInSlice > 0 and
    	    	(TileId[CtbAddrTS] = TileId[ctbAddrRStoTS[indexLeft]]);
    	    	ctb_up_flag := (ct_y0 > 0) and CtbAddrInSlice >= PicWidthInCtbsY and
    	    	(TileId[CtbAddrTS] = TileId[ctbAddrRStoTS[indexUp]]);
    	   	end
		if DEBUG_CABAC and DEBUG_TRACE1 then
    	    	println("read_CodingTree.start (" + ct_x0 + ", " + ct_y0 + ", " + (1
    	    	<< ct_log2CbSize) + ", " + ctStack[ctStack_idx][CT_ctDepth] + ")");
    	    	elsif DEBUG_CABAC then println("read_CodingTree.start");
		end
		foreach int i in 0 .. Log2CtbSize - Log2MinCbSize - 1 do
			m := 1 << i;
    	    	MinCbAddrZS := MinCbAddrZS + if (m & (ct_x0 >> Log2MinCbSize)) != 0
    	    	then
    	    		m * m
    	    	else
    	    		0
    	    	end + if (m & (ct_y0 >> Log2MinCbSize)) != 0 then
    	    		2 * m * m
    	    	else
    	    		0
    	    	end;
		end	
    	    if (ctb_left_flag) or (x0b > 0) then
			left_ctDepth	:= cu_left_ctDepth[ct_y0 >> Log2MinCbSize];
		end
    	    if (ctb_up_flag) or (y0b > 0) then
			top_ctDepth	:= cu_top_ctDepth[ct_x0 >> Log2MinCbSize];
		end
		if	ct_x0 + ( 1 << ct_log2CbSize ) <= sps_pic_width_in_luma_samples[sps_id] and
			ct_y0 + ( 1 << ct_log2CbSize ) <= sps_pic_height_in_luma_samples[sps_id] and
			ct_log2CbSize > Log2MinCbSize then
    	    	get_SPLIT_CODING_UNIT_FLAG(codIRange, codIOffset, ctxTable, fifo,
    	    	res, ct_ctDepth, (ctb_left_flag) or (x0b > 0), left_ctDepth,
    	    	(ctb_up_flag) or (y0b > 0), top_ctDepth);
			split_cu_flag := res[0];
		else
    	    	split_cu_flag := if ct_log2CbSize > Log2MinCbSize then
    	    		1
    	    	else
    	    		0
    	    	end;
		end
    	    if ((pps_cu_qp_delta_enabled_flag[pps_id] != 0) and ct_log2CbSize >=
    	    Log2MinCuQpDeltaSize) then
			IsCuQpDeltaCoded := 0;
			CuQpDelta        := 0;
		end

		if split_cu_flag = 1 then
			ctStack[ctStack_idx][CT_x1]  := ct_x0 + ( ( 1 << ct_log2CbSize ) >> 1 );
			ctStack[ctStack_idx][CT_y1]  := ct_y0 + ( ( 1 << ct_log2CbSize ) >> 1 );
			ctStack[ctStack_idx][CT_idx] := 2;
		else
			ctStack[ctStack_idx][CT_idx] := 6;
		end
	end

	/**************************************************************************
	 * read_CodingQuadTree.case1
	 *************************************************************************/	
	read_CodingQuadTree.case1 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 2
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 3;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x0];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y0];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end

	/**************************************************************************
	 * read_CodingQuadTree.case2
	 *************************************************************************/		
	read_CodingQuadTree.case2 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 3,
		ctStack[ctStack_idx][CT_x1] < sps_pic_width_in_luma_samples[sps_id]
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 4;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x1];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y0];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end
	
	
	read_CodingQuadTree.noCase2 : action ==> CUInfo:[cuInfo] repeat 5, TileCUInfo:[tilecuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 3,
		ctStack[ctStack_idx][CT_x1] >= sps_pic_width_in_luma_samples[sps_id]
	var
		uint(size=16) tilecuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x1]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]- rowTileInPix[rowIndex],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)],
		uint(size=16) cuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x1], ctStack[ctStack_idx][CT_y0],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 4;
	end
	/**************************************************************************
	 * read_CodingQuadTree.case3
	 *************************************************************************/	
	read_CodingQuadTree.case3 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 4,
		ctStack[ctStack_idx][CT_y1] < sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 5;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x0];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y1];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end
	read_CodingQuadTree.noCase3 : action ==> CUInfo:[cuInfo] repeat 5, TileCUInfo:[tilecuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 4,
		ctStack[ctStack_idx][CT_y1] >= sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size=16) tilecuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x0]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y1]- rowTileInPix[rowIndex],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)],
		uint(size=16) cuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y1],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 5;
	end
	/**************************************************************************
	 * read_CodingQuadTree.case4
	 *************************************************************************/	
	read_CodingQuadTree.case4 : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 5,
		ctStack[ctStack_idx][CT_x1] < sps_pic_width_in_luma_samples[sps_id],
		ctStack[ctStack_idx][CT_y1] < sps_pic_height_in_luma_samples[sps_id]		
	var
		uint(size= 8) idx =  ctStack_idx
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
		ctStack_idx							:= ctStack_idx + 1;
		ctStack[ctStack_idx][CT_idx]        := 1;
		ctStack[ctStack_idx][CT_x0]         := ctStack[idx][CT_x1];
		ctStack[ctStack_idx][CT_y0]         := ctStack[idx][CT_y1];
		ctStack[ctStack_idx][CT_log2CbSize] := ctStack[idx][CT_log2CbSize] - 1;
		ctStack[ctStack_idx][CT_ctDepth]    := ctStack[idx][CT_ctDepth] + 1;
	end
	read_CodingQuadTree.noCase4 : action ==> CUInfo:[cuInfo] repeat 5, TileCUInfo:[tilecuInfo] repeat 5,
		 PartMode:[PART_2Nx2N]
	guard
		ctStack[ctStack_idx][CT_idx] = 5,
		ctStack[ctStack_idx][CT_x1] >= sps_pic_width_in_luma_samples[sps_id] or
		ctStack[ctStack_idx][CT_y1] >= sps_pic_height_in_luma_samples[sps_id]
	var
		uint(size=16) tilecuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x1]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y1]- rowTileInPix[rowIndex],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)],
		uint(size=16) cuInfo[5] = [OTHER,
			ctStack[ctStack_idx][CT_x1], ctStack[ctStack_idx][CT_y1],
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1),
			1<<(ctStack[ctStack_idx][CT_log2CbSize]-1)]
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
	end
	/**************************************************************************
	 * read_CodingQuadTree_gotoCodingUnit
	 *************************************************************************/	
	read_CodingQuadTree_gotoCodingUnit : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 6
	do
		ctStack[ctStack_idx][CT_idx]        := 7;
		cu_idx			:= 1;
		cu_x0			:= ctStack[ctStack_idx][CT_x0];
		cu_y0			:= ctStack[ctStack_idx][CT_y0];
		cu_log2CbSize	:= ctStack[ctStack_idx][CT_log2CbSize];
		cu_ctDepth		:= ctStack[ctStack_idx][CT_ctDepth];
	end
	/**************************************************************************
	 * read_CodingQuadTree_end
	 *************************************************************************/
	read_CodingQuadTree.noEnd : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 7,
		ctStack_idx != 0
	do
		ctStack_idx := ctStack_idx - 1;
	end
	read_CodingQuadTree_end : action ==>
	guard
		ctStack[ctStack_idx][CT_idx] = 7,
		ctStack_idx = 0
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Coding Unit                          *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) cu_idx;
	uint(size=16) cu_x0;
	uint(size=16) cu_y0;
	uint(size= 8) cu_log2CbSize;
	uint(size= 8) cu_ctDepth;
	uint(size= 8) predMode;
	uint(size= 8) partMode;
	uint(size= 1) IntraSplitFlag;
	uint(size= 8) MaxTrafoDepth;
	uint(size= 1) cu_transquant_bypass_flag;
	uint(size= 8) cu_top_ctDepth[PICT_WIDTH];
	uint(size= 8) cu_left_ctDepth[PICT_WIDTH];
	uint(size= 1) skip_flag;
	uint(size= 1) merge_flag;
	uint(size=6) intraChrPredModIdx;
	uint(size=6) intraPredModeC[5][5] =
		[[34,  0,  0,  0,  0],
		 [26, 34, 26, 26, 26],
		 [10, 10, 34, 10, 10],
		 [ 1,  1,  1, 34,  1],
		 [0, 26, 10, 1, 0]];

	
		/**************************************************************************
	 * read_CodingUnit.start
	 *************************************************************************/
	uint(size= 8) cu_nCbS;
        int counterfillSkip := 0;
	read_CodingUnit.start : action ==>
	guard 
		cu_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 8) length 		 = (1 << cu_log2CbSize) >> Log2MinCbSize,
                int(size=32) x_cb                        = cu_x0 >> Log2MinCbSize,
		        int(size=32) y_cb                        = cu_y0 >> Log2MinCbSize,
    	
		        int(size=32) ct_x0                      = ctStack[ctStack_idx][CT_x0],
		                int(size=32) ct_y0                      = ctStack[ctStack_idx][CT_y0],
		        int(size=32) x0b = ct_x0 & ((1 << Log2CtbSize) - 1),
		        int(size=32) y0b = ct_y0 & ((1 << Log2CtbSize) - 1),
    	bool leftFlag,
    	bool upFlag,
		uint indexLeft := 0,
		uint indexUp   :=0
	do
        	if (pps_tiles_enabled_flag[pps_id] = 1) then
		if CtbAddrRS != 0 then
            indexLeft := CtbAddrRS - 1;
        end
        if CtbAddrRS >= PicWidthInCtbsY then
            indexUp   := CtbAddrRS - PicWidthInCtbsY;
        end
        		ctb_left_flag := ct_x0 > 0 and CtbAddrInSlice > 0 and
        		(TileId[CtbAddrTS] = TileId[ctbAddrRStoTS[indexLeft]]);
        		ctb_up_flag := ct_y0 > 0 and CtbAddrInSlice >= PicWidthInCtbsY and
        		(TileId[CtbAddrTS] = TileId[ctbAddrRStoTS[indexUp]]);
        	end
        	leftFlag := ctb_left_flag or (x0b > 0);
        	upFlag := ctb_up_flag or (y0b > 0);
		skip_flag  := 0;
		merge_flag := 0;
		intra_pred_mode := [1 : for int i in 0 .. 3];
		if DEBUG_CABAC and DEBUG_TRACE1 then
        		println("read_CodingUnit.start (" + cu_x0 + ", " + cu_y0 + ", " +
        		cu_log2CbSize + ")");
        		elsif DEBUG_CABAC then println("read_CodingUnit.start");
	 	end
		predMode := INTRA;
		if pps_transquant_bypass_enable_flag[pps_id] != 0 then
        		get_CU_TRANSQUANT_BYPASS_FLAG(codIRange, codIOffset, ctxTable, fifo,
        		res);
			cu_transquant_bypass_flag := res[0];
        		if cu_transquant_bypass_flag = 1 then //##set_deblocking_bypass();
			end
		else
			cu_transquant_bypass_flag := 0;
		end
		if slice_type != I_SLICE then
        		get_SKIP_FLAG(codIRange, codIOffset, ctxTable, fifo, res,
        		skip_flag_tab, x_cb, y_cb, leftFlag, upFlag);
			skip_flag := res[0];
			predMode := SKIP;
        		predMode := if skip_flag = 1 then
        			SKIP
        		else
        			INTER
        		end;
			foreach uint i  in 0 .. length-1 do
				skip_flag_tab[x_cb+i][0] := skip_flag;
				skip_flag_tab[y_cb+i][1] := skip_flag;
			end
        		counterfillSkip := counterfillSkip + 1;
		end
		cu_nCbS			:= ( 1 << cu_log2CbSize );		
		partMode		:= PART_2Nx2N;		
		cu_idx := 2; 
	end
	/**************************************************************************
	 * read_CodingUnit_gotoPredictionUnit.goto1
	 *************************************************************************/
	read_CodingUnit_gotoPredictionUnit.goto1 : action ==> CUInfo:[cuInfo] repeat 5, TileCUInfo:[tilecuInfo] repeat 5, Cbf :[false],
		 PartMode:[PART_2Nx2N], SplitTransform:[false], TUSize:[1<<cu_log2CbSize, 1, 0, 0, slice_qp, TEXT_LUMA, 0, //luma
		 														1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_U, 0,	//cb
		 														1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_V, 0] //cr
                                                                                                                                , Qp:[qp_y, qp_y, qp_y]
	guard 
		cu_idx = 2,
		skip_flag != 0
	var
		uint(size=16) tilecuInfo[5] = [SKIP,
		ctStack[ctStack_idx][CT_x0]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]- rowTileInPix[rowIndex],
		1<<cu_log2CbSize, 1<<cu_log2CbSize],
		uint(size=16) cuInfo[5] = [SKIP,
		ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
		1<<cu_log2CbSize, 1<<cu_log2CbSize]
	do
		cu_idx		:= 10; 
		pu_idx		:= 1;
		pu_PbW		:= cu_nCbS;
		pu_PbH		:= cu_nCbS;
		intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);
	end
	/**************************************************************************
	 * read_CodingUnit.noGoto1
	 *************************************************************************/
	
	uint(size= 8) intra_pred_mode[4];
	uint(size= 8) intra_pred_mode_c;
	read_CodingUnit_noGoto1 : action ==> PartMode:[partMode]
	guard 
		cu_idx = 2 and isFifoFull(fifo),
		skip_flag = 0
	var
		uint(size= 1) prev_intra_luma_pred_flag[4],
		uint(size= 8) intra_chroma_table[4] = [0, 26, 10, 1],
		uint(size=32) res[1],
		uint(size= 8) Log2MinIPCMCUSize = Log2MinCbSize,
		uint(size= 8) pbOffset,
		uint(size= 8) pbEnd,
		uint(size=16) ct_x0			= ctStack[ctStack_idx][CT_x0],
		uint(size=16) ct_y0			= ctStack[ctStack_idx][CT_y0],
		uint indexLeft := 0,
		uint indexUp   :=0
	do
        	if (pps_tiles_enabled_flag[pps_id] = 1) then
		if CtbAddrRS != 0 then
            indexLeft := CtbAddrRS - 1;
        end
        if CtbAddrRS >= PicWidthInCtbsY then
            indexUp   := CtbAddrRS - PicWidthInCtbsY;
        end
		        ctb_left_flag := ct_x0 > 0 and CtbAddrInSlice > 0 and (TileId[ CtbAddrTS ] = TileId[ ctbAddrRStoTS[ indexLeft ] ]);
	            ctb_up_flag   := ct_y0 > 0 and CtbAddrInSlice  >= PicWidthInCtbsY and (TileId[ CtbAddrTS ] = TileId[ ctbAddrRStoTS[ indexUp ] ]);
		        
		    end
		IntraSplitFlag	:= 0;
		if slice_type != I_SLICE then
			//println("codIRangeget_PRED_MODE_FLAG := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
			get_PRED_MODE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			predMode := res[0];
		end
		if predMode != INTRA or cu_log2CbSize = Log2MinCbSize then
			//println("codIRangeget_PART_SIZE := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
			get_PART_SIZE(codIRange, codIOffset, ctxTable, fifo, res, predMode = INTRA, cu_log2CbSize, Log2MinCbSize, amp_enabled_flag);
			partMode := res[0];
			IntraSplitFlag := if ((partMode=PART_NxN) and (predMode=INTRA)) then 1 else 0 end;
		end
		cu_idx := 4;
		if( predMode = INTRA ) then
 			pcm_flag := 0;
			if  partMode = PART_2Nx2N and sps_pcm_enabled_flag[sps_id] = 1 and
                                cu_log2CbSize >= log2_min_pcm_cb_size[sps_id] and
                                cu_log2CbSize <= log2_max_pcm_cb_size[sps_id] then
				//println("codIRangePCMFlag := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
				get_PCM_FLAG(codIRange, codIOffset, fifo, res);
			end
			if( pcm_flag = 1) then
				byte_align(fifo);
				intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);
				cu_idx := 3;
			else 
				pbOffset := if partMode = PART_NxN then cu_nCbS>>1 else cu_nCbS end;
				pbEnd    := if partMode = PART_NxN then 1 else 0 end;
				foreach int i in 0 .. pbEnd do
					foreach int j in 0 .. pbEnd do 
						get_PREV_INTRA_LUMA_PRED_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
						prev_intra_luma_pred_flag[ (i<<1) + j ] := res[0];
					end
				end
				foreach int i in 0 .. pbEnd do
					foreach int j in 0 .. pbEnd do
						if prev_intra_luma_pred_flag[ (i<<1) + j ] = 1 then
							get_MPM_IDX(codIRange, codIOffset, fifo, res);
						else
							get_REM_INTRA_LUMA_PRED_MODE(codIRange, codIOffset, fifo, res);
						end
						
                                                luma_intra_pred_mode(cu_x0 + j*pbOffset, cu_y0 + i*pbOffset, pbOffset, prev_intra_luma_pred_flag[ (i<<1) + j ], res[0], res, Log2MinIPCMCUSize-1 ,Log2CtbSize, intraPredMode, ctb_up_flag, ctb_left_flag);
						intra_pred_mode[ (i<<1) + j ] := res[0];
					end
				end
				get_INTRA_CHROMA_PRED_MODE(codIRange, codIOffset, ctxTable, fifo, res);
				intraChrPredModIdx := res[0];
				if res[0] != 4 then
        			if intra_pred_mode[0] = intra_chroma_table[res[0]] then
            			intra_pred_mode_c := 34;
        			else
	            		intra_pred_mode_c := intra_chroma_table[res[0]];
        			end
    			else
	        		intra_pred_mode_c := intra_pred_mode[0];
    			end    			
				cu_idx := 8;
			end
		else
			intra_prediction_unit_default_value( cu_x0, cu_y0, cu_log2CbSize, partMode, Log2MinCbSize-1, intraPredMode);			
		end
	end

	sendIntraPredMode.skip: action ==>
	guard
		predMode != INTRA
	end

	sendIntraPredMode.part2Nx2N: action ==> IntraPredMode:[intra_pred_mode[0], predMode_v], CUInfo:[cuInfo] repeat 5,  TileCUInfo:[tilecuInfo] repeat 5
	guard
		partModeToNumPart[partMode] = 1 and predMode = INTRA
	var
		uint(size=16) tilecuInfo[5] =
			[predMode, ctStack[ctStack_idx][CT_x0]- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]- rowTileInPix[rowIndex],
				1<<cu_log2CbSize, 1<<cu_log2CbSize],
		uint(size=16) cuInfo[5] =
			[predMode, ctStack[ctStack_idx][CT_x0], ctStack[ctStack_idx][CT_y0],
				1<<cu_log2CbSize, 1<<cu_log2CbSize],
		uint(size=6) predMode_v,
		uint(size=3) idx
	do		
		if(intraChrPredModIdx=4) then
			predMode_v := intra_pred_mode[0];
		else
			idx :=
				if(intra_pred_mode[0] = 0) then
					0
				elsif(intra_pred_mode[0] = 26) then
					1
				elsif(intra_pred_mode[0] = 10) then
					2
				elsif(intra_pred_mode[0] = 1) then
					3
				else
					4
				end;
			predMode_v := intraPredModeC[intraChrPredModIdx][idx];
		end
	end

	sendIntraPredMode.partNxN: action ==> IntraPredMode:[intraPredMode] repeat 8, CUInfo:[cuInfo] repeat 20, TileCUInfo:[tilecuInfo] repeat 20
	guard
		partModeToNumPart[partMode] != 1 and predMode = INTRA
	var
		uint(size=7) CUSize = (1<<(cu_log2CbSize-1)),
		uint(size=16) tilecuInfo[20] =
			[predMode, ctStack[ctStack_idx][CT_x0]       - colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]       - rowTileInPix[rowIndex], CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]       - rowTileInPix[rowIndex], CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]       - colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]+CUSize- rowTileInPix[rowIndex], CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize- colTileInPix[colIndex], ctStack[ctStack_idx][CT_y0]+CUSize- rowTileInPix[rowIndex], CUSize, CUSize],
		uint(size=16) cuInfo[20] =
			[predMode, ctStack[ctStack_idx][CT_x0]       , ctStack[ctStack_idx][CT_y0]       , CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize, ctStack[ctStack_idx][CT_y0]       , CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]       , ctStack[ctStack_idx][CT_y0]+CUSize, CUSize, CUSize,
			 predMode, ctStack[ctStack_idx][CT_x0]+CUSize, ctStack[ctStack_idx][CT_y0]+CUSize, CUSize, CUSize],
		uint(size=6) intraPredMode[8],
		uint(size=3) idx
	do
		foreach uint i in 0 .. 3
		do
			intraPredMode[2*i] := intra_pred_mode[i];

			if(intraChrPredModIdx=4) then
				intraPredMode[2*i+1] := intra_pred_mode[i];
			else
				idx :=
					if(intra_pred_mode[i] = 0) then
						0
					elsif(intra_pred_mode[i] = 26) then
						1
					elsif(intra_pred_mode[i] = 10) then
						2
					elsif(intra_pred_mode[i] = 1) then
						3
					else
						4
					end;
				intraPredMode[2*i+1] := intraPredModeC[intraChrPredModIdx][idx];
			end
		end
	end

	/**************************************************************************
	 * read_CodingUnit_gotoPCMSample
	 *************************************************************************/
	read_CodingUnit_gotoPCMSample : action ==>
	guard 
		cu_idx = 3
	do
		PCMSample_log2CbSize := cu_log2CbSize;
		cu_idx				 := 8;
	end
	/**************************************************************************
	 * read_CodingUnit_gotoPredictionUnit.goto2
	 *************************************************************************/
	read_CodingUnit_gotoPredictionUnit.goto2 : action ==> TileCUInfo:[predMode, x0- colTileInPix[colIndex], y0- rowTileInPix[rowIndex], pu_PbW, pu_PbH],
	CUInfo:[predMode, x0, y0, pu_PbW, pu_PbH]
	guard 
		cu_idx = 4 or cu_idx = 5 or
		cu_idx = 6 or cu_idx = 7
	var
		uint(size= 8) nCbS_2   = cu_nCbS >> 1,
		uint(size= 8) nCbS_4   = cu_nCbS >> 2,
		uint(size= 8) nCbS_3_4 = cu_nCbS - nCbS_4,
		int x0 := ctStack[ctStack_idx][CT_x0],
		int y0 := ctStack[ctStack_idx][CT_y0]
	do	
		pu_idx := 1;
		pu_PbW := cu_nCbS;
		pu_PbH := cu_nCbS;
		if partMode = PART_2Nx2N then
			//prediction_unit( x0, y0, nCbS, nCbS )
			cu_idx    := 8;
		elsif partMode = PART_2NxN then
			pu_PbH := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS / 2 )
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS / 2 ), nCbS, nCbS / 2 )
				cu_idx := 8;
				y0 := y0  + nCbS_2;
			end
		elsif partMode = PART_Nx2N then
			pu_PbW := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS / 2, nCbS )
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS / 2 ), y0, nCbS / 2, nCbS )
				cu_idx := 8;
				x0 := x0 + nCbS_2;
			end
		elsif partMode = PART_2NxnU then
			pu_PbH := nCbS_4;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS / 4 )
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS / 4 ), nCbS, nCbS *3 / 4 )
				pu_PbH := nCbS_3_4;
				cu_idx := 8;
				y0 := y0  + nCbS_4;
			end
		elsif partMode = PART_2NxnD then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS, nCbS *3 / 4 )
				pu_PbH := nCbS_3_4;
				cu_idx := 5;
			else
				//prediction_unit( x0, y0 + ( nCbS * 3 / 4 ), nCbS, nCbS / 4 )
				pu_PbH := nCbS_4;
				cu_idx := 8;
				y0 := y0  + nCbS_3_4;
			end
		elsif partMode = PART_nLx2N then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS /4, nCbS )
				pu_PbW := nCbS_4;
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS / 4 ), y0, nCbS *3 / 4, nCbS)
				pu_PbW := nCbS_3_4;
				x0 := x0  + nCbS_4;
				cu_idx := 8;
			end
		elsif partMode = PART_nRx2N then
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS *3 / 4, nCbS )
				pu_PbW := nCbS_3_4;
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS * 3 / 4 ), y0, nCbS / 4, nCbS )
				pu_PbW := nCbS_4;
				x0 := x0  + nCbS_3_4;
				cu_idx := 8;
			end
		else /* PART_NxN */
			pu_PbW := nCbS_2;
			pu_PbH := nCbS_2;
			if cu_idx = 4 then
				//prediction_unit( x0, y0, nCbS / 2, nCbS / 2)
				cu_idx := 5;
			elsif cu_idx = 5 then
				//prediction_unit( x0 + ( nCbS / 2 ), y0, nCbS / 2, nCbS / 2 )
				x0 := x0  + nCbS_2;
				cu_idx := 6;
			elsif cu_idx = 6 then
				//prediction_unit( x0, y0 + ( nCbS / 2 ), nCbS / 2, nCbS / 2 )
				y0 := y0  + nCbS_2;
				cu_idx := 5;
			else
				//prediction_unit( x0 + ( nCbS / 2 ), y0 + ( nCbS / 2 ), nCbS / 2, nCbS / 2 )
				x0 := x0  + nCbS_2;
				y0 := y0  + nCbS_2;
				cu_idx := 8;
			end
		end
	end
	/**************************************************************************
	 * read_CodingUnit.endFunction
	 *************************************************************************/
	read_CodingUnit.endFunction : action ==>
	guard 
		cu_idx = 8
	var
		uint(size=32) res[1] := [1]
	do
		cu_idx := 10;
		if pcm_flag = 0 then
			if( predMode != INTRA and not(partMode = PART_2Nx2N and merge_flag = 1) ) then
				get_NO_RESIDUAL_SYNTAX_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
				//no_residual_data_flag
			end
			if res[0] != 0 then
				MaxTrafoDepth := if predMode = INTRA then
									sps_max_transform_hierarchy_depth_intra[sps_id] + IntraSplitFlag
								else
									sps_max_transform_hierarchy_depth_inter[sps_id]
								end;
				cu_idx	:= 9;
				//transform_tree( x0, y0, x0, y0, x0, y0, log2CbSize, log2CbSize, log2CbSize, 0, 0 )
			elsif predMode != INTRA then // ### not conform to openhevc !
				cu_idx	:= 11;
			end			
		end
	end

	read_CodingUnit.endFunctionSend : action ==> SplitTransform:[false], TUSize:[1<<cu_log2CbSize, 1, 0, 0, slice_qp, TEXT_LUMA, 0, //luma
		 														1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_U, 0,	//cb
		 														1<<(cu_log2CbSize-1), 1, 0, 0, 0, TEXT_CHROMA_V, 0], //cr 
                                                                                                                                Cbf:[false], Qp:[qp_y, qp_y, qp_y]
	guard 
		cu_idx = 11
	do
		cu_idx	:= 10;
	end

	/**************************************************************************
	 * read_CodingUnit_gotoTransformTree
	 *************************************************************************/
	read_CodingUnit_gotoTransformTree : action ==>
	guard 
		cu_idx = 9
	do
		cu_idx							:= 10;
		ttStack_idx						:=  0;
		ttStack[0][TT_idx]				:=  1;
		ttStack[0][TT_x0]				:=  cu_x0;
		ttStack[0][TT_y0]				:=  cu_y0;
		ttStack[0][TT_xBase]			:=  cu_x0;
		ttStack[0][TT_yBase]			:=  cu_y0;
		ttStack[0][TT_log2TrafoSize]	:=  cu_log2CbSize;
		ttStack[0][TT_trafoDepth]		:=  0;
		ttStack[0][TT_blkIdx]			:=  0;
	end
	/**************************************************************************
	 * read_CodingUnit_end
	 *************************************************************************/
	read_CodingUnit_end : action ==>
	guard 
		 cu_idx = 10
	var
		uint(size= 8) length = (1 << cu_log2CbSize) >> Log2MinCbSize,
		uint(size=16) x_cb = cu_x0 >> Log2MinCbSize,
    	uint(size=16) y_cb = cu_y0 >> Log2MinCbSize
	do
//		println("read_CodingUnit_end ");
    	foreach uint i  in 0 .. length-1 do
    		cu_top_ctDepth[x_cb + i]  := cu_ctDepth;
    		cu_left_ctDepth[y_cb + i] := cu_ctDepth;
		end
	end
	
	/**************************************************************************
	 **************************************************************************
	 ********        Prediction Unit                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) pu_idx;
	uint(size= 8) pu_PbW;
	uint(size= 8) pu_PbH;
	uint(size= 1) pcm_flag;
	uint(size= 2) inter_pred_idc;
	 int(size=16) mergeIdx;
	 int(size=16) mvp_lx[2];
	 int(size=16) ref_idx_lx[2];
	 int(size=16) mvd[4];
	
	/**************************************************************************
	 * read_PredictionUnit.start
	 *************************************************************************/
	read_PredictionUnit.start : action ==>
	guard 
		isFifoFull(fifo),
		pu_idx = 1
	var
		uint(size=32) res[1]
	do
		inter_pred_idc	:= PRED_L0;
		mergeIdx		:= -1;
		mvp_lx			:= [-1, -1]; 
		ref_idx_lx		:= [-1, -1];
		mvd				:= [0, 0, 0, 0];
		mvd_x			:= 0;
		mvd_y			:= 0;
		if ( skip_flag = 1) then
			if( MaxNumMergeCand > 1 ) then
            		get_MERGE_IDX(codIRange, codIOffset, ctxTable, fifo, res,
            		MaxNumMergeCand);
				mergeIdx := res[0];
            	else
            		mergeIdx := 0;
			end
			pu_idx := 7;
            else

            /* MODE_INTER */
			get_MERGE_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			merge_flag := res[0];
			if res[0] = 1 then
				if MaxNumMergeCand > 1 then
            			get_MERGE_IDX(codIRange, codIOffset, ctxTable, fifo, res,
            			MaxNumMergeCand);
					mergeIdx := res[0];
            		else
            			mergeIdx := 0;
				end
				pu_idx := 7;
			else
				if( slice_type = B_SLICE ) then
            			get_INTER_PRED_IDC(codIRange, codIOffset, ctxTable, fifo,
            			res, partMode, pu_PbW, pu_PbH, cu_ctDepth);
					inter_pred_idc := res[0];
				end
				if( inter_pred_idc != PRED_L1 ) then
					ref_idx_lx[0] := 0;
					if( num_ref_idx_l0_active > 1 ) then
            				get_REF_IDX_LX(codIRange, codIOffset, ctxTable, fifo, res,
            				num_ref_idx_l0_active - 1);
						ref_idx_lx[0] := res[0];
            			end // goto mvd_coding
					pu_idx := 3;
				else
					pu_idx := 4;
				end	
			end
		end
	end
	/**************************************************************************
	 * read_PredictionUnit.retMVDcoding_goto1
	 *************************************************************************/
	read_PredictionUnit.retMVDcoding_goto1 : action ==>
	guard 
		pu_idx = 4
	var
		uint(size=32) res[1]
	do
		mvd[0]	:= mvd_x;
		mvd[1]	:= mvd_y;
		mvd_x	:= 0;
		mvd_y	:= 0;
		if( inter_pred_idc != PRED_L1 ) then
			get_MVP_LX_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			mvp_lx[0] := res[0];
		end	
		pu_idx := 7;
		if( inter_pred_idc != PRED_L0 ) then
			ref_idx_lx[1] := 0;
			if( num_ref_idx_l1_active > 1 ) then
				get_REF_IDX_LX(codIRange, codIOffset, ctxTable, fifo, res, num_ref_idx_l1_active-1);
				ref_idx_lx[1] := res[0];
			end
			if( mvd_l1_zero_flag = 1 and inter_pred_idc = BI_PRED ) then
				//mvd_l1[ x0 ][ y0 ][ 0 ] = 0
				//mvd_l1[ x0 ][ y0 ][ 1 ] = 0
				pu_idx := 6;
			else
				pu_idx := 5;
			end
		end
	end
	/**************************************************************************
	 * read_PredictionUnit_gotoMVDCoding
	 *************************************************************************/
	read_PredictionUnit_gotoMVDCoding : action ==>
	guard 
		pu_idx = 3 or pu_idx = 5
	do
		pu_idx := pu_idx + 1;
	end
	/**************************************************************************
	 * read_PredictionUnit.retMVDcoding_goto2
	 *************************************************************************/
	read_PredictionUnit.retMVDcoding_goto2 : action ==>
	guard 
		pu_idx = 6
	var
		uint(size=32) res[1]
	do
		mvd[2] := mvd_x;
		mvd[3] := mvd_y;
		get_MVP_LX_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		mvp_lx[1] := res[0];
		pu_idx := 7;
	end
	/**************************************************************************
	 * read_PredictionUnit_end
	 *************************************************************************/
	read_PredictionUnit_end.mergeIdx_Eq_min1 : action ==> MvPredSyntaxElem:[mergeIdx,
															mvp_lx[0]     , mvp_lx[1],
															ref_idx_lx[0] , ref_idx_lx[1],
	 														mvd[0], mvd[1], mvd[2], mvd[3]]
	guard 
		pu_idx = 7, mergeIdx = -1
	end
	read_PredictionUnit_end.mergeIdx_notEq_min1 : action ==> MvPredSyntaxElem:[mergeIdx,
															mvd[0], mvd[1], mvd[2], mvd[3]]
	guard 
		pu_idx = 7, mergeIdx != -1
	end
	/**************************************************************************
	 **************************************************************************
	 ********        MVD Coding                           *********************
	 **************************************************************************
	 *************************************************************************/
	 int(size=32) mvd_x;
	 int(size=32) mvd_y;
	 uint(size= 1) abs_mvd_greater1_flag_1;
	 uint(size= 1) abs_mvd_greater0_flag_1;
	 
	 
	read_MVDCoding.start : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) abs_mvd_greater0_flag_0,
		uint(size= 1) abs_mvd_greater1_flag_0,
		 int(size=16) abs_mvd_minus2_0 := 0,
		uint(size= 1) mvd_sign_flag_0  := 0
	do
		get_ABS_MVD_GREATER0_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		abs_mvd_greater0_flag_0 := res[0];
		get_ABS_MVD_GREATER0_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
		abs_mvd_greater0_flag_1 := res[0];
		if abs_mvd_greater0_flag_0 = 1 then
			get_ABS_MVD_GREATER1_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			abs_mvd_greater1_flag_0 := res[0];
		end
		if abs_mvd_greater0_flag_1 = 1 then
		get_ABS_MVD_GREATER1_FLAG(codIRange, codIOffset, ctxTable, fifo, res);
			abs_mvd_greater1_flag_1 := res[0];
		end
		if abs_mvd_greater0_flag_0 = 1 then
			abs_mvd_minus2_0 := -1;
			if abs_mvd_greater1_flag_0 = 1 then
				get_ABS_MVD_MINUS2(codIRange, codIOffset, fifo, res);
				abs_mvd_minus2_0 := res[0];
			end
			get_MVD_SIGN_FLAG(codIRange, codIOffset, fifo, res);
			mvd_sign_flag_0 := res[0];
		end
		mvd_x := abs_mvd_greater0_flag_0 * ( abs_mvd_minus2_0 + 2 ) * ( 1 - (mvd_sign_flag_0 << 1) );
	end	
	
	read_MVDCoding.ended : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1],
		 int(size=16) abs_mvd_minus2_1 := 0,
		uint(size= 1) mvd_sign_flag_1  := 0
	do
		if abs_mvd_greater0_flag_1 = 1 then
			abs_mvd_minus2_1 := -1;
			if abs_mvd_greater1_flag_1 = 1 then
				get_ABS_MVD_MINUS2(codIRange, codIOffset, fifo, res);
				abs_mvd_minus2_1 := res[0];
			end
			get_MVD_SIGN_FLAG(codIRange, codIOffset, fifo, res);
			mvd_sign_flag_1 := res[0];
		end
		mvd_y := abs_mvd_greater0_flag_1 * ( abs_mvd_minus2_1 + 2 ) * ( 1 - (mvd_sign_flag_1 << 1) );
	end

	/**************************************************************************
	 **************************************************************************
	 ********        PCM Sample                           *********************
	 **************************************************************************
	 *************************************************************************/

	uint(size= 8) PCMSample_log2CbSize;
	read_PCMSample.start : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1]		
	do
		if DEBUG_CABAC then
			println("read_PCMSample");
		end
		foreach int i  in 0 .. 1 << ( PCMSample_log2CbSize << 1 ) do
			vld_u_name(  1, fifo, res, "pcm_sample_luma[i]                      ");
			//pcm_sample_luma[ i ];
		end
		foreach int i  in 0 .. 1 << ( PCMSample_log2CbSize << 1 ) do
			vld_u_name(  1, fifo, res, "pcm_sample_chroma[i]                    ");
			//pcm_sample_chroma[ i ]
		end
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Transform Tree                       *********************
	 **************************************************************************
	 *************************************************************************/

	uint(size= 8) ttStack_idx;
	uint(size=16) ttStack[10][TT_STRUCT_SIZE];
	uint(size= 1) cbf_cb[MAX_TU_SIZE][MAX_TU_SIZE][4];
	uint(size= 1) cbf_cr[MAX_TU_SIZE][MAX_TU_SIZE][4];
	uint(size= 1) cbf_luma;
	uint(size= 8) cur_intra_pred_mode;
	uint(size= 1) split_transform_flag;
        uint(size=16) cbf_xBase;
        uint(size=16) cbf_yBase;                
	
	/**************************************************************************
	 * read_TransformTree.start
	 *************************************************************************/
	read_TransformTree.start : action ==>
	guard 
		isFifoFull(fifo),
		ttStack[ttStack_idx][TT_idx] = 1
	var
		uint(size=16) x0				= ttStack[ttStack_idx][TT_x0],
		uint(size=16) y0				= ttStack[ttStack_idx][TT_y0],
		uint(size=16) xBase				= ttStack[ttStack_idx][TT_xBase],
		uint(size=16) yBase				= ttStack[ttStack_idx][TT_yBase],
		uint(size= 8) log2TrafoSize	    = ttStack[ttStack_idx][TT_log2TrafoSize],
		uint(size= 8) trafoDepth		= ttStack[ttStack_idx][TT_trafoDepth],
		uint(size=16) cbf_x0			= x0 & ((1<<log2TrafoSize)-1),
		uint(size=16) cbf_y0			= y0 & ((1<<log2TrafoSize)-1),
		uint(size=32) res[1] := [0],
		uint(size= 1) IntraSplitFlag   = if predMode = INTRA and partMode = PART_NxN then 1 else 0 end,
		uint(size= 1) InterSplitFlag   = if sps_max_transform_hierarchy_depth_inter[sps_id] = 0 and predMode = INTER and partMode != PART_2Nx2N and trafoDepth = 0 then 1 else 0 end
	do	
    		cbf_xBase := xBase & ((1 << log2TrafoSize) - 1);
    		cbf_yBase := yBase & ((1 << log2TrafoSize) - 1);
		if DEBUG_CABAC and DEBUG_TRACE1 then
    			println("read_TransformTree.start(" + x0 + ", " + y0 + ", " + xBase
    			+ ", " + yBase + ", " + log2TrafoSize + ", " + trafoDepth + ", " +
    			ttStack[ttStack_idx][TT_blkIdx] + ")");
    			elsif DEBUG_CABAC then println("read_TransformTree.start");
		end
		if IntraSplitFlag = 1 then
        	if trafoDepth = 1 then
    				cur_intra_pred_mode :=
    				intra_pred_mode[ttStack[ttStack_idx][TT_blkIdx]];
            end
    	else
        	cur_intra_pred_mode := intra_pred_mode[0];
    	end
		split_transform_flag := 0;
    		if (log2TrafoSize <= Log2MaxTrafoSize and log2TrafoSize >
    		Log2MinTrafoSize and trafoDepth < MaxTrafoDepth and
    		not(IntraSplitFlag = 1 and trafoDepth = 0)) then
    			get_SPLIT_TRANSFORM_FLAG(codIRange, codIOffset, ctxTable, fifo,
    			res, log2TrafoSize);
			split_transform_flag := res[0];
    			elsif log2TrafoSize > Log2MaxTrafoSize or (IntraSplitFlag = 1 and
    			trafoDepth = 0) or InterSplitFlag = 1 then split_transform_flag :=
    			1;
		end
		cbf_cb[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := 0;
		cbf_cr[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := 0;
		if trafoDepth = 0 or log2TrafoSize > 2  then
			if trafoDepth = 0 then
    				get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res,
    				trafoDepth);
				cbf_cb[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := res[0];
    				get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res,
    				trafoDepth);
				cbf_cr[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := res[0];
			else
				if cbf_cb[ cbf_xBase ][ cbf_yBase ][ trafoDepth-1 ] = 1 then
    					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res,
    					trafoDepth);
					cbf_cb[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := res[0];
				end
				if cbf_cr[ cbf_xBase ][ cbf_yBase ][ trafoDepth-1 ] = 1 then
    					get_CBF_CB_CR(codIRange, codIOffset, ctxTable, fifo, res,
    					trafoDepth);
					cbf_cr[ cbf_x0 ][ cbf_y0 ][ trafoDepth ] := res[0];
				end
			end
		end
		if trafoDepth > 0 and log2TrafoSize = 2  then
    			cbf_cb[cbf_x0][cbf_y0][trafoDepth] :=
    			cbf_cb[cbf_xBase][cbf_yBase][trafoDepth - 1];
    			cbf_cr[cbf_x0][cbf_y0][trafoDepth] :=
    			cbf_cr[cbf_xBase][cbf_yBase][trafoDepth - 1];
		end
		if split_transform_flag = 1 then
			ttStack[ttStack_idx][TT_x1]  := x0 + ( ( 1 << log2TrafoSize ) >> 1 );
			ttStack[ttStack_idx][TT_y1]  := y0 + ( ( 1 << log2TrafoSize ) >> 1 );
			ttStack[ttStack_idx][TT_idx] := 3;
		else
			cbf_luma := 1;
			if predMode = INTRA or trafoDepth != 0 or
    			cbf_cb[cbf_x0][cbf_y0][trafoDepth] = 1 or
    			cbf_cr[cbf_x0][cbf_y0][trafoDepth] = 1 then
    				get_CBF_LUMA(codIRange, codIOffset, ctxTable, fifo, res,
    				trafoDepth);
				cbf_luma := res[0];
			end
			ttStack[ttStack_idx][TT_idx] := 2;
		end
    		if not(partMode = PART_NxN and ttStack[ttStack_idx][TT_trafoDepth] =
    		0) then
            ttStack[ttStack_idx][TT_idx] := 10;		
		end
	end

	read_TransformTree.start_nonPartNxN : action ==> SplitTransform:[(split_transform_flag != 0)]
	guard 
		ttStack[ttStack_idx][TT_idx] = 10
	do	
        ttStack[ttStack_idx][TT_idx] := 2 + split_transform_flag;
	end
	/**************************************************************************
	 * read_TransformTree_gotoTransformUnit
	 *************************************************************************/
	read_TransformTree_gotoTransformUnit : action ==> Cbf:[cbf_luma = 1]
	guard
		ttStack[ttStack_idx][TT_idx] = 2
	do
		ttStack[ttStack_idx][TT_idx]	:= 7;
		tu_idx							:= 1;
		tu_x0							:= ttStack[ttStack_idx][TT_x0];
		tu_y0							:= ttStack[ttStack_idx][TT_y0];
		tu_xBase						:= ttStack[ttStack_idx][TT_xBase];
		tu_yBase						:= ttStack[ttStack_idx][TT_yBase];
		tu_log2TrafoSize				:= ttStack[ttStack_idx][TT_log2TrafoSize];
		tu_trafoDepth					:= ttStack[ttStack_idx][TT_trafoDepth];
		tu_blkIdx						:= ttStack[ttStack_idx][TT_blkIdx];
	end
	/**************************************************************************
	 * read_TransformTree.gotoTransformTree
	 *************************************************************************/
	read_TransformTree.gotoTransformTree : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 3 or ttStack[ttStack_idx][TT_idx] = 4 or
		ttStack[ttStack_idx][TT_idx] = 5 or ttStack[ttStack_idx][TT_idx] = 6
	var
		uint(size= 8) idx = ttStack_idx
	do
		ttStack[ttStack_idx][TT_idx]				:= ttStack[ttStack_idx][TT_idx] + 1;
		ttStack_idx 								:= ttStack_idx + 1;
		ttStack[ttStack_idx][TT_idx]				:= 1;
		ttStack[ttStack_idx][TT_x0]					:= ttStack[idx][TT_x0];
		ttStack[ttStack_idx][TT_y0]					:= ttStack[idx][TT_y0];
		ttStack[ttStack_idx][TT_xBase]				:= ttStack[idx][TT_x0];
		ttStack[ttStack_idx][TT_yBase]				:= ttStack[idx][TT_y0];
		ttStack[ttStack_idx][TT_log2TrafoSize]		:= ttStack[idx][TT_log2TrafoSize] - 1;
		ttStack[ttStack_idx][TT_trafoDepth]			:= ttStack[idx][TT_trafoDepth] + 1;
		if ttStack[idx][TT_idx] = 4 then
			ttStack[ttStack_idx][TT_blkIdx]			:= 0;
		elsif ttStack[idx][TT_idx] = 5 then
			ttStack[ttStack_idx][TT_x0]		    	:= ttStack[idx][TT_x1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 1;
		elsif ttStack[idx][TT_idx] = 6 then
			ttStack[ttStack_idx][TT_y0]				:= ttStack[idx][TT_y1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 2;
		else
			ttStack[ttStack_idx][TT_x0]				:= ttStack[idx][TT_x1];
			ttStack[ttStack_idx][TT_y0]				:= ttStack[idx][TT_y1];
			ttStack[ttStack_idx][TT_blkIdx]			:= 3;
		end
	end
	/**************************************************************************
	 * read_TransformTree_end
	 *************************************************************************/
	read_TransformTree_end : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx = 0 
	end
	read_TransformTree.endCall : action ==>
	guard
		ttStack[ttStack_idx][TT_idx] = 7 and ttStack_idx != 0 
	do
		ttStack_idx := ttStack_idx - 1;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Transform Unit                       *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 8) tu_idx;
	uint(size=16) tu_x0;
	uint(size=16) tu_y0;
	uint(size=16) tu_xBase;
	uint(size=16) tu_yBase;
	uint(size= 8) tu_trafoDepth;
	uint(size= 8) tu_blkIdx;
	uint(size= 8) tu_log2TrafoSize;
        int qp_y_tab [4096]; // to be checked
	
	/**************************************************************************
	 * read_TransformUnit.start
	 *************************************************************************/
	read_TransformUnit.start : action ==>
	guard 
		isFifoFull(fifo),
		tu_idx = 1
	var
        uint(size=32) res[1] := [0],
        		int qPy_local := 0,
		uint(size=16) cbf_x0			= tu_x0 & ((1<<tu_log2TrafoSize)-1),
                uint(size=16) cbf_y0                    = tu_y0 & ((1<<tu_log2TrafoSize)-1),
			    int MinCuQpDeltaSizeMask := (1 << (Log2CtbSize -
			                                      pps_diff_cu_qp_delta_depth[pps_id])) - 1,
			    int xQgBase              := cbf_xBase - (cbf_xBase & MinCuQpDeltaSizeMask),
			    int yQgBase              := cbf_xBase - (cbf_xBase & MinCuQpDeltaSizeMask),
			    //int min_cb_width         := min_cb_width,
			    //int min_cb_height        := min_cb_height,
			    int x_cb                 := xQgBase >> sps_log2_min_coding_block_size[NB_MAX_SPS],
			    int y_cb                 := yQgBase >> sps_log2_min_coding_block_size[NB_MAX_SPS],
			    int availableA           := 0,//if ((cbf_xBase   & ctb_size_mask) != 0 and (xQgBase & ctb_size_mask) != 0) then 1 else 0 end,
			    int availableB           := 0,//if (cbf_xBase   & ctb_size_mask) != 0 and (yQgBase & ctb_size_mask) != 0 then 1 else 0 end,
    			int qPy_pred:=0,
                
                int qPy_a := 0,
    			int qPy_b := 0
//    			int xC0b := (cbf_x0 - (cbf_x0 & ctb_size_mask)) >> sps_log2_min_coding_block_size[NB_MAX_SPS],
//            	int yC0b := (cbf_y0 - (cbf_y0 & ctb_size_mask)) >> sps_log2_min_coding_block_size[NB_MAX_SPS],
//	            int idxX := (xQgBase  & ctb_size_mask)  >> sps_log2_min_coding_block_size[NB_MAX_SPS],
//	            int idxY := (yQgBase  & ctb_size_mask)  >> sps_log2_min_coding_block_size[NB_MAX_SPS],
//	            int idx_mask := ctb_size_mask >> sps_log2_min_transform_block_size[NB_MAX_SPS],
//	            int offsetX[8][8] = [
//                [ -1, 1, 3, 1, 7, 1, 3, 1 ],
//                [  0, 0, 0, 0, 0, 0, 0, 0 ],
//                [  1, 3, 1, 3, 1, 3, 1, 3 ],
//                [  2, 2, 2, 2, 2, 2, 2, 2 ],
//                [  3, 5, 7, 5, 3, 5, 7, 5 ],
//                [  4, 4, 4, 4, 4, 4, 4, 4 ],
//                [  5, 7, 5, 7, 5, 7, 5, 7 ],
//                [  6, 6, 6, 6, 6, 6, 6, 6 ]
//            ],
//            int offsetY[8][8] = [
//                [ 7, 0, 1, 2, 3, 4, 5, 6 ],
//                [ 0, 1, 2, 3, 4, 5, 6, 7 ],
//                [ 1, 0, 3, 2, 5, 4, 7, 6 ],
//                [ 0, 1, 2, 3, 4, 5, 6, 7 ],
//                [ 3, 0, 1, 2, 7, 4, 5, 6 ],
//                [ 0, 1, 2, 3, 4, 5, 6, 7 ],
//                [ 1, 0, 3, 2, 5, 4, 7, 6 ],
//                [ 0, 1, 2, 3, 4, 5, 6, 7 ]
//            ]
	do
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_TransformUnit.start("+tu_x0+", "+tu_y0+", "+tu_xBase+", "+tu_yBase+", "+
					tu_log2TrafoSize+", "+tu_log2TrafoSize+", "+tu_trafoDepth+", "+tu_blkIdx+")");
		elsif DEBUG_CABAC then
			println("read_TransformUnit.start");
		end
                if cbf_luma = 1 or cbf_cb[cbf_x0][cbf_y0][tu_trafoDepth] = 1 or
			cbf_cr[ cbf_x0 ][ cbf_y0 ][ tu_trafoDepth ] = 1 then
                	if pps_cu_qp_delta_enabled_flag[pps_id] = 1 and
                	IsCuQpDeltaCoded = 0 then
                		get_CU_QP_DELTA_ABS(codIRange, codIOffset, ctxTable, fifo,
                		res);
			     CuQpDelta := res[0];
			     if CuQpDelta != 0 then
                			get_CU_QP_DELTA_SIGN_FLAG(codIRange, codIOffset, fifo,
                			res);
                     if res[0] = 1 then
                        CuQpDelta := -CuQpDelta;
                     end
                 end
   				IsCuQpDeltaCoded := 1;
                		
                		if first_qp_group != 0 then
        					first_qp_group := if IsCuQpDeltaCoded != 0 then 0 else 1 end;
        					qPy_pred := slice_qp;
        				else
        					qPy_pred := qp_y;
        					
        					if (ct_log2CbSize < Log2CtbSize -pps_diff_cu_qp_delta_depth[pps_id]) then
					            
					            //qPy_pred := qp_y_tab[y * min_cb_width + x];
        					end
        				end
        				
        				
        				if (availableA = 0) then
				        	qPy_a := qPy_pred;
					    else
					        qPy_a := qp_y_tab[(x_cb - 1) + y_cb * min_cb_width];
						  end
					    if (availableB = 0) then
					        qPy_b := qPy_pred;
					    else
					        qPy_b := qp_y_tab[x_cb + (y_cb - 1) * min_cb_width];
					    end
					    qPy_local :=  (qPy_a + qPy_b + 1) >> 1;
					    
                		if CuQpDelta != 0 then
                			qp_y    := ((qPy_local + CuQpDelta + 52 + 2 * qp_bd_offset_luma) mod (52 + qp_bd_offset_luma)) - qp_bd_offset_luma;
                		else
				        	qp_y := qPy_local;
                		end
			end
		end
		tu_idx				:= 8; // skipResidualCoding
		rc_x0 				:= tu_x0;
		rc_y0 				:= tu_y0;
		rc_log2TrafoSize	:= tu_log2TrafoSize;
		rc_scanIdx			:= getScanIdx(predMode, tu_log2TrafoSize, cur_intra_pred_mode);
		rc_cIdx				:= TEXT_LUMA;
		if cbf_luma = 1 then
			tu_idx 			:= 2;
		end
	end
	/**************************************************************************
	 * read_TransformUnit.retLuma
	 *************************************************************************/
	read_TransformUnit.retLuma : action ==>
	guard 
		tu_idx = 3
	var
		uint(size=16) cbf_x0			= tu_x0 & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_y0			= tu_y0 & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_xBase			= tu_xBase & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_yBase			= tu_yBase & ((1<<tu_log2TrafoSize)-1)
	do
		tu_idx 				:= 5;
		rc_log2TrafoSize	:= tu_log2TrafoSize;
		rc_scanIdx			:= getScanIdx(predMode, rc_log2TrafoSize, intra_pred_mode_c);
		rc_cIdx				:= TEXT_CHROMA_U;						
		if tu_log2TrafoSize > 2 then
			tu_idx 				:= 10;  // skipResidualCoding
			rc_x0 				:= tu_x0;
			rc_y0 				:= tu_y0;
			rc_log2TrafoSize	:= tu_log2TrafoSize - 1;
			if cbf_cb[ cbf_x0 ][ cbf_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx			:= 4;
			end				
		elsif tu_blkIdx = 3 then
			tu_idx 			:= 10;  // skipResidualCoding
			rc_x0    		:= tu_xBase;
			rc_y0 	 		:= tu_yBase;
			if cbf_cb[ cbf_xBase ][ cbf_yBase ][ tu_trafoDepth ] = 1 then
				tu_idx		:= 4;
			end
		end
	end
	/**************************************************************************
	 * read_TransformUnit.retCb
	 *************************************************************************/
	read_TransformUnit.retCb : action ==>
	guard 
		tu_idx = 5
	var
		uint(size=16) cbf_x0			= tu_x0 & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_y0			= tu_y0 & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_xBase			= tu_xBase & ((1<<tu_log2TrafoSize)-1),
		uint(size=16) cbf_yBase			= tu_yBase & ((1<<tu_log2TrafoSize)-1)
	do	
		tu_idx	 := 7;
		rc_cIdx	 := TEXT_CHROMA_V;						
		if tu_log2TrafoSize > 2 then
			tu_idx	 			:= 12;  // skipResidualCoding
			rc_log2TrafoSize	:= tu_log2TrafoSize - 1;
			if cbf_cr[ cbf_x0 ][ cbf_y0 ][ tu_trafoDepth ] = 1 then
				tu_idx 			:= 6;
			end
		elsif tu_blkIdx = 3 then
			tu_idx	 := 12;  // skipResidualCoding
			if cbf_cr[ cbf_xBase ][ cbf_yBase ][ tu_trafoDepth ] = 1 then
				tu_idx			:= 6;
			end
		end
	end
	/**************************************************************************
	 * read_TransformUnit_gotoResidualCoding
	 *************************************************************************/
	read_TransformUnit_gotoResidualCoding : action ==>
	guard 
		tu_idx = 2 or tu_idx = 4 or tu_idx = 6
	do	
		tu_idx := tu_idx + 1;
	end
	/**************************************************************************
	 * read_TransformUnit.skipResidualCoding
	 *************************************************************************/
    read_TransformUnit.skipResidualCoding : action ==> TUSize:[1<<rc_log2TrafoSize, 2, 0, 0, slice_qp, rc_cIdx, 0], Qp:[qp_y]
	guard 
		tu_idx = 8 or tu_idx = 10 or tu_idx = 12
	do	
		tu_idx := tu_idx - 5;
	end
        
	/**************************************************************************
	 * read_TransformUnit_end
	 *************************************************************************/
	read_TransformUnit_end : action ==>
	guard 
		tu_idx = 7
	do
		if DEBUG_CABAC then
			println("read_TransformUnit_end");
		end
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Residual Coding                      *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size=16) rc_x0;
	uint(size=16) rc_y0;
	uint(size= 8) rc_log2TrafoSize;
	uint(size= 8) rc_scanIdx;
	uint(size= 8) rc_cIdx;
	//
	uint(size= 8) ScanOrder[4][3][(BLW_WIDTH_MAX/4)*(BLW_HEIGHT_MAX/4)][2];
	uint(size= 8) significant_coeff_flag_idx[16];
	uint(size= 8) nb_significant_coeff_flag;
	uint(size= 1) coded_sub_block_flag[8][8];
	uint(size= 8) LastSignificantCoeffX;
	uint(size= 8) LastSignificantCoeffY;
	
	// DR 1403
	
	uint(size=16) num_coeff;
	
    uint(size= 8) horiz_scan8x8_inv[8][8] = [
      [  0,  1,  2,  3, 16, 17, 18, 19 ],
      [  4,  5,  6,  7, 20, 21, 22, 23 ],
      [  8,  9, 10, 11, 24, 25, 26, 27 ],
      [ 12, 13, 14, 15, 28, 29, 30, 31 ],
      [ 32, 33, 34, 35, 48, 49, 50, 51 ],
      [ 36, 37, 38, 39, 52, 53, 54, 55 ],
      [ 40, 41, 42, 43, 56, 57, 58, 59 ],
      [ 44, 45, 46, 47, 60, 61, 62, 63 ]
    ];

    uint(size= 8)  diag_scan8x8_inv[8][8] = [
      [  0,  2,  5,  9, 14, 20, 27, 35 ],
      [  1,  4,  8, 13, 19, 26, 34, 42 ],
      [  3,  7, 12, 18, 25, 33, 41, 48 ],
      [  6, 11, 17, 24, 32, 40, 47, 53 ],
      [ 10, 16, 23, 31, 39, 46, 52, 57 ],
      [ 15, 22, 30, 38, 45, 51, 56, 60 ],
      [ 21, 29, 37, 44, 50, 55, 59, 62 ],
      [ 28, 36, 43, 49, 54, 58, 61, 63 ]
    ];

    uint(size= 8) diag_scan4x4_inv[4][4] = [
      [ 0,  2,  5,  9 ],
      [ 1,  4,  8, 12 ],
      [ 3,  7, 11, 14 ],
      [ 6, 10, 13, 15 ]
    ];

    uint(size= 8) diag_scan2x2_inv[2][2] = [
      [ 0, 2 ],
      [ 1, 3 ]
    ];
		
	/**************************************************************************
	 * read_ResidualCoding.start
	 *************************************************************************/
	uint(size= 8) rc_lastScanPos;
	 int(size= 8) rc_lastSubBlock;
	 int(size= 8) rc_i;
	 int(size= 16) tabTransCoeffLevel[32*32];
	 int add;
	 int scale;
	 int scale_m;
	 int dc_scale := 16; 
	 uint(size=8) scale_matrix [64];
	 uint(size= 8) shift;
         int(size= 8) qp_y := 0;
         int(size=16) qp;
	 
		
        read_ResidualCoding.start : action ==> TUSize:[sz, 0, isDST, transform_skip_flag, slice_qp, rc_cIdx,
											if rc_cIdx = TEXT_CHROMA_U then
												pps_cb_qp_offset[pps_id] + slice_cb_qp_offset
	         								else
												pps_cr_qp_offset[pps_id] + slice_cr_qp_offset
                                                                                        end], Qp:[qp]
	guard 
		isFifoFull(fifo)
	var
		 int(size=32) res[1],
		 uint(size=16) xS := 0,
		 uint(size=16) yS := 0,
		 int(size=16) xC := -1,
		 int(size=16) yC := -1,
		 int sz = 1 << rc_log2TrafoSize,
		 uint(size=1) transform_skip_flag,
		 int matrix_id,
		 int qp_offset,
		 int(size=16) qp_i,
		 
		 int x_cg_last_sig, 
		 int y_cg_last_sig,
		 int last_x_c,
         int last_y_c,
         
         
        uint(size= 8) qp_c[15] = [ 29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37],
		uint(size= 8) levelScale[6] = [ 40, 45, 51, 57, 64, 72 ],
		 uint(size=1) isDST = if (predMode = INTRA and rc_cIdx = TEXT_LUMA and sz = 4) then 1 else 0 end
	do	
		if DEBUG_CABAC and DEBUG_TRACE1 then
			println("read_ResidualCoding.start "+if rc_cIdx = TEXT_LUMA then "cbY" elsif rc_cIdx = TEXT_CHROMA_U then "cbU" else "cbV" end+"("+rc_x0+", "+rc_y0+", "+rc_log2TrafoSize+", "+rc_scanIdx+", "+rc_cIdx+")");
		elsif DEBUG_CABAC then
			println("read_ResidualCoding.start "+if rc_cIdx = TEXT_LUMA then "cbY" elsif rc_cIdx = TEXT_CHROMA_U then "cbU" else "cbV" end);
		end
		
		
		shift := if rc_cIdx = 0 then sps_bit_depth_luma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 
							  else sps_bit_depth_chroma_minus8[sps_id] + 8 + rc_log2TrafoSize - 5 end;
		if rc_cIdx = 0 then
            qp := qp_y + qp_bd_offset_luma;
        else
        	if rc_cIdx = 1 then
        		qp_offset := pps_cb_qp_offset[pps_id] + slice_cb_qp_offset;
        	else
        		qp_offset := pps_cr_qp_offset[pps_id] + slice_cr_qp_offset;
        	end
            qp_i := clip_i32(qp_y + qp_offset, - qp_bd_offset_luma, 57);
            if qp_i < 30 then
                qp := qp_i;
            elsif qp_i > 43 then
                qp := qp_i - 6;
            else
                qp := qp_c[qp_i - 30];
            end
            	qp := qp + qp_bd_offset_luma;
	    end
	    add := 1 << (shift - 1 );
	    scale := levelScale[ rem6[qp] ] << (div6[qp]);
		scale_m := 16;
		if sps_scaling_list_enabled_flag[sps_id] = 1 then
            matrix_id := if predMode != INTRA then 1 else 0 end;

            if rc_log2TrafoSize != 5 then
                matrix_id := 3 * matrix_id + rc_cIdx;
			end
			if pps_scaling_list_data_present_flag[pps_id] = 1 then
				foreach int i in 0 .. 63 do
	            	scale_matrix[i] := pps_sl[pps_id][rc_log2TrafoSize - 2][matrix_id][i];
	            end
	            if rc_log2TrafoSize >= 4 then
	                dc_scale := pps_sl_dc[pps_id][rc_log2TrafoSize - 4][matrix_id];
	            end
	        else
	        	foreach int i in 0 .. 63 do
	        		scale_matrix[i] := sps_sl[sps_id][rc_log2TrafoSize - 2][matrix_id][i];
	        	end
	            if rc_log2TrafoSize >= 4 then
	                dc_scale := sps_sl_dc[sps_id][rc_log2TrafoSize - 4][matrix_id];
	            end
	        end
        end
		
		foreach int i in 0 .. sz * sz - 1 do
			tabTransCoeffLevel[i] := 0;
		end 
		coded_sub_block_flag := [[0	: for int j in 0 .. 7]	: for int i in 0 .. 7];
		if pps_transform_skip_enabled_flag[pps_id] = 1 and cu_transquant_bypass_flag = 0 and
			rc_log2TrafoSize = 2 then
			get_TRANSFORM_SKIP_FLAG(codIRange, codIOffset, ctxTable, fifo, res, rc_cIdx);
			transform_skip_flag := res[0];
		else
			transform_skip_flag := 0;
		end

		get_LAST_SIGNIFICANT_COEFF_X_PREFIX(codIRange, codIOffset, ctxTable, fifo, res, rc_log2TrafoSize, rc_cIdx);
		LastSignificantCoeffX := res[0];
		get_LAST_SIGNIFICANT_COEFF_Y_PREFIX(codIRange, codIOffset, ctxTable, fifo, res, rc_log2TrafoSize, rc_cIdx);
		LastSignificantCoeffY := res[0];
		if LastSignificantCoeffX > 3 then
			get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, fifo, res, LastSignificantCoeffX);
			LastSignificantCoeffX := (1 << ((LastSignificantCoeffX >> 1) - 1)) *
									 (2  +  (LastSignificantCoeffX & 1 )) + res[0];			
		end
		if LastSignificantCoeffY > 3 then 
			get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(codIRange, codIOffset, fifo, res, LastSignificantCoeffY);
			LastSignificantCoeffY := (1 << ((LastSignificantCoeffY >> 1) - 1)) *
									 (2  +  (LastSignificantCoeffY & 1 )) + res[0];
		end
		
		
		if rc_scanIdx = SCAN_VER then
			res[0] := LastSignificantCoeffX;
			LastSignificantCoeffX := LastSignificantCoeffY;
			LastSignificantCoeffY := res[0];
		end
		
		x_cg_last_sig := LastSignificantCoeffX >> 2;
        y_cg_last_sig := LastSignificantCoeffY >> 2;

        if rc_scanIdx = 0 then
          last_x_c := LastSignificantCoeffX & 3;
          last_y_c := LastSignificantCoeffY & 3;

          num_coeff := diag_scan4x4_inv[last_y_c][last_x_c];

          if rc_log2TrafoSize = 3 then
            num_coeff := (num_coeff + (diag_scan2x2_inv[y_cg_last_sig][x_cg_last_sig] << 4));
          elsif rc_log2TrafoSize = 4 then
            num_coeff := (num_coeff + (diag_scan4x4_inv[y_cg_last_sig][x_cg_last_sig] << 4));
           else // rc_log2TrafoSize = 5 then
            num_coeff := (num_coeff + (diag_scan8x8_inv[y_cg_last_sig][x_cg_last_sig] << 4));
          end
        
        elsif rc_scanIdx = 1 then
          num_coeff := horiz_scan8x8_inv[LastSignificantCoeffY][LastSignificantCoeffX];
        
        elsif rc_scanIdx = 2 then
          num_coeff := horiz_scan8x8_inv[LastSignificantCoeffX][LastSignificantCoeffY];
        end
      
        num_coeff := num_coeff + 1;
        rc_lastSubBlock := (num_coeff - 1) >> 4;
        rc_lastScanPos := num_coeff - (rc_lastSubBlock << 4) - 1;

		rc_i := rc_lastSubBlock;
 	end
        
	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.start
	 *************************************************************************/
	uint(size=16) rc_xS;
	uint(size=16) rc_yS;
	 int(size= 8) m_end;
	read_ResidualCoding.for_numLastSubset.start : action ==>
	guard 
		isFifoFull(fifo)
	var
		int(size=32) res[1],
		uint(size= 8) n,
		uint(size=16) xC,
		uint(size=16) yC,
		uint(size= 1) inferSigCoeffFlag
	do	   
		rc_xS := ScanOrder[rc_log2TrafoSize-2][ rc_scanIdx ][ rc_i ][ 0 ];
   		rc_yS := ScanOrder[rc_log2TrafoSize-2][ rc_scanIdx ][ rc_i ][ 1 ]; 
	    inferSigCoeffFlag := 0; 
        if rc_i < rc_lastSubBlock and rc_i > 0 then 
	        get_CODED_SUB_BLOCK_FLAG( codIRange, codIOffset, ctxTable, fifo, res, coded_sub_block_flag, rc_xS, rc_yS, rc_cIdx, rc_log2TrafoSize);
	        coded_sub_block_flag[ rc_xS ][ rc_yS ] := res[0];
           	inferSigCoeffFlag := 1;
        else
        	if (rc_xS = LastSignificantCoeffX>>2 and rc_yS = LastSignificantCoeffY>>2) or (rc_xS = 0 and rc_yS = 0) then
        		coded_sub_block_flag[ rc_xS ][ rc_yS ] := 1;
        	end
        end
 
       	m_end                     := 15;
		nb_significant_coeff_flag := 0;
		if rc_i = rc_lastSubBlock then
        	m_end                         := rc_lastScanPos - 1;
	    	significant_coeff_flag_idx[0] := rc_lastScanPos;
			nb_significant_coeff_flag     := 1;
        end
        foreach int m in 0 .. m_end do
  			n  := m_end - m;  
			xC := ( rc_xS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 0 ]; 
			yC := ( rc_yS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 1 ];			
			if coded_sub_block_flag[ rc_xS ][ rc_yS ] = 1 and ( n > 0 or inferSigCoeffFlag = 0 ) then
				get_SIGNIFICANT_COEFF_FLAG( codIRange, codIOffset, ctxTable, fifo, res, coded_sub_block_flag, xC, yC, rc_cIdx, rc_log2TrafoSize, rc_scanIdx);
				if res[0] = 1 then
				    significant_coeff_flag_idx[nb_significant_coeff_flag] := n;
                   	nb_significant_coeff_flag := nb_significant_coeff_flag + 1;
                   	inferSigCoeffFlag := 0;
               	end
            else
            	if (xC = LastSignificantCoeffX and yC = LastSignificantCoeffY) or
            	   (( (xC&3) = 0 and (yC&3) = 0) and inferSigCoeffFlag = 1 and coded_sub_block_flag[ rc_xS ][ rc_yS ] = 1 ) then
				    significant_coeff_flag_idx[nb_significant_coeff_flag] := n;
                   	nb_significant_coeff_flag := nb_significant_coeff_flag + 1;
            	end
			end
		end
		m_end := nb_significant_coeff_flag-1;
	end
	/**************************************************************************
	 * read_ResidualCoding_end
	 *************************************************************************/
	read_ResidualCoding_end.xIT4 : action ==>
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 4 * 4 - 1]] repeat 4 * 4
	guard 
		rc_i < 0,
		rc_log2TrafoSize = 2
	do
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
	end

	read_ResidualCoding_end.xIT8 : action ==>
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 8 * 8 - 1]] repeat 8 * 8
	guard 
		rc_i < 0,
		rc_log2TrafoSize = 3
	do
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
	end

	read_ResidualCoding_end.xIT16 : action ==> 
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 16 * 16 - 1]] repeat 16 * 16
	guard 
		rc_i < 0,
		rc_log2TrafoSize = 4
	do
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
	end

	read_ResidualCoding_end.xIT32 : action ==> 
						Coeff:[[tabTransCoeffLevel[i]: for int i in 0 .. 32 * 32 - 1]] repeat 32 * 32
	guard 
		rc_i < 0,
		rc_log2TrafoSize = 5
	do
		if DEBUG_CABAC then
			println("read_ResidualCoding_end");
		end
	end
	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG
	 *************************************************************************/
	uint(size= 8) rc_ctxSet[1];
	uint(size= 8) rc_greater1Ctx[1];
	uint(size= 8) rc_firstSigScanPos;
	 int(size= 8) rc_firstGreater1ScanPos;
	 int(size= 8) rc_m;
	uint(size= 8) coeff_abs_level_greater1_flag[16];
	uint(size= 8) coeff_abs_level_greater2_flag;
	uint(size=16) coeff_sign_flag;
	uint(size= 1) rc_signHidden;
	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG : action ==>
	guard 
		isFifoFull(fifo)
	var
		 int(size=32) res[1] := [0],
		 int          n,
		 int(size= 8) lastSigScanPos  := -1,
		uint(size= 8) numGreater1Flag :=  0,
		uint(size= 9) ctxIdxInc[1]
	do	
		rc_firstSigScanPos		:= 16;
		rc_firstGreater1ScanPos	:= -1;
		coeff_abs_level_greater1_flag := [ 0 : for int i in 0 .. 15 ];
		foreach int m in 0 .. m_end do		
  			n  := significant_coeff_flag_idx[m];
			if numGreater1Flag < 8 then
                        	context_93315(rc_cIdx, rc_i, numGreater1Flag = 0,
                        	rc_i = rc_lastSubBlock, rc_ctxSet, rc_greater1Ctx,
                        	ctxIdxInc);
                        	get_COEFF_ABS_LEVEL_GREATER1_FLAG(codIRange,
                        	codIOffset, ctxTable, fifo, res, ctxIdxInc[0]);
				if res[0] = 1 then
    				rc_greater1Ctx[0] := 0;
                        		elsif rc_greater1Ctx[0] > 0 and rc_greater1Ctx[0] <
                        		3 then rc_greater1Ctx[0] := rc_greater1Ctx[0] + 1;
   				end
   				coeff_abs_level_greater1_flag[ n ] := res[0];
				numGreater1Flag := numGreater1Flag + 1; 
                        	if (coeff_abs_level_greater1_flag[n] = 1 and
                        	rc_firstGreater1ScanPos = -1) then
					rc_firstGreater1ScanPos := n;
				end
			end
			if lastSigScanPos = -1 then
				lastSigScanPos := n;
			end
			rc_firstSigScanPos := n;
		end
				
		rc_signHidden := if lastSigScanPos - rc_firstSigScanPos > 3 and cu_transquant_bypass_flag = 0 then 1 else 0 end;
		if rc_firstGreater1ScanPos != -1 then 
			get_COEFF_ABS_LEVEL_GREATER2_FLAG(codIRange, codIOffset, ctxTable, fifo, res, rc_cIdx, rc_ctxSet[0]);
			coeff_abs_level_greater2_flag := res[0];
		end
		if (pps_sign_data_hiding_flag[pps_id] = 0 or rc_signHidden = 0) then
			get_COEFF_SIGN_FLAG(codIRange, codIOffset, fifo, res, nb_significant_coeff_flag);
			coeff_sign_flag := res[0] << (16 - nb_significant_coeff_flag);
		else
			get_COEFF_SIGN_FLAG(codIRange, codIOffset, fifo, res, nb_significant_coeff_flag - 1);
			coeff_sign_flag := res[0] << (16 - (nb_significant_coeff_flag - 1));
		end
		rc_numSigCoeff		:= 0;
		rc_sumAbsLevel		:= 0;
		rc_cLastRiceParam	:= 0;
		rc_m   := 0;
	end
	/**************************************************************************
	 * read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL
	 *************************************************************************/
	uint(size= 8) rc_numSigCoeff;
	uint(size= 8) rc_sumAbsLevel;
	uint(size= 8) rc_cLastRiceParam;
	
	
	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL : action ==> 
	guard 
		isFifoFull(fifo)
	var
		 int(size=32) res[1] := [0],
		 int          n       = significant_coeff_flag_idx[rc_m],
	     int(size=16) transCoeffLevel := 0,
	     int pos,
		uint(size=16) xC,
		uint(size=16) yC
	do			
		xC := ( rc_xS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 0 ]; 
		yC := ( rc_yS << 2 ) + ScanOrder[2][ rc_scanIdx ][ n ][ 1 ];			
		transCoeffLevel := 1 + coeff_abs_level_greater1_flag[ n ] + if n = rc_firstGreater1ScanPos then coeff_abs_level_greater2_flag else 0 end;
		if transCoeffLevel = ( if rc_numSigCoeff < 8 then if n = rc_firstGreater1ScanPos then 3 else 2 end else 1 end) then
			get_COEFF_ABS_LEVEL(codIRange, codIOffset, fifo, res, rc_cLastRiceParam);				
			transCoeffLevel := transCoeffLevel + res[0];
			rc_cLastRiceParam := min(if transCoeffLevel> 3 * ( 1 << rc_cLastRiceParam ) then rc_cLastRiceParam + 1 else rc_cLastRiceParam end, 4);			
		end
		if pps_sign_data_hiding_flag[pps_id] = 1 and rc_signHidden = 1 then
			rc_sumAbsLevel := rc_sumAbsLevel + transCoeffLevel;
			if n = rc_firstSigScanPos and ( rc_sumAbsLevel & 1 ) = 1 then
				transCoeffLevel := - transCoeffLevel;
			end
		end
		if (coeff_sign_flag >> 15) = 1 then
			transCoeffLevel := - transCoeffLevel;
		end
		coeff_sign_flag := coeff_sign_flag << 1;
		
		if cu_transquant_bypass_flag = 0 then
			if sps_scaling_list_enabled_flag[sps_id] = 1 then
				if yC != 0 or xC != 0 or (rc_log2TrafoSize < 4) then
					if rc_log2TrafoSize = 3 then
						pos := (yC << 3) + xC;
					elsif rc_log2TrafoSize = 4 then
						pos := ((yC >> 1) << 3) + (xC >> 1);
					elsif rc_log2TrafoSize = 5 then
						pos := ((yC >> 2) << 3) + (xC >> 2);
					else
						pos := (yC << 2) + xC;
					end
					scale_m := scale_matrix[pos];
				else
					scale_m := dc_scale;			
				end
			end 
			transCoeffLevel := clip_i32(( ( transCoeffLevel * scale_m * scale + add )) >> shift, -32768, 32767 );
		end

		tabTransCoeffLevel[xC+(1<<rc_log2TrafoSize)*yC] := transCoeffLevel;
		rc_numSigCoeff := rc_numSigCoeff + 1;
		rc_m := rc_m + 1;		
	end
	
	read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_end : action ==>
	guard 
		rc_m > m_end
	do
		rc_i	:= rc_i - 1;
	end
	
	
	/**************************************************************************
	 **************************************************************************
	 ********        undefined                            *********************
	 **************************************************************************
	 *************************************************************************/
  	
  	bool actorNotFinished := true;
	
	undefined: action ==>
	guard
		actorNotFinished
	do
		println("Algo_Parser doesn't manage this case yet");
		actorNotFinished := false;
	end

	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
  	schedule fsm start_code:
		// byte align
		byte_align          			( byte_align_a						) --> start_code;
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.VPS_header	  			) --> read_VPS_Header;
		find_header	  					( look_for.SEI_header	  			) --> read_SEI_Header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		// read VPS header
		read_VPS_Header	  				( read_VPS_Header	    			) --> read_VPS_Header;
		read_VPS_Header	  				( read_VPS_Header_done    			) --> byte_align;
		// read SEI header
		read_SEI_Header	  				( read_SEI_Header	    			) --> read_SEI_Header;
		read_SEI_Header	  				( read_SEI_Header_done    			) --> byte_align;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> byte_align;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> byte_align;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
		read_SliceHeader				( read_SliceHeader_done				) --> read_SliceData;
		// read_SliceData
		read_SliceData				    ( read_SliceData	  				) --> read_SliceData;
		read_SliceData				    ( read_SliceData_gotoCodingTree		) --> read_CodingTree;
		read_SliceData				    ( read_SliceData_end	  			) --> byte_align;
		// read_CodingTree
		read_CodingTree				    ( read_CodingTree	  				) --> read_CodingTree;
		read_CodingTree				    ( read_CodingTree_gotoSaoParam		) --> read_SaoParam;
		read_CodingTree				    ( read_CodingTree_gotoCodingQuadTree) --> read_CodingQuadTree;
		read_CodingTree				    ( read_CodingTree_end	 			) --> read_SliceData;
		// read_SaoParam
		read_SaoParam					( read_SaoParam						) --> read_SaoParam;
		read_SaoParam					( read_SaoParam_endLoop				) --> read_CodingTree;
		// read_CodingQuadTree
		read_CodingQuadTree			    ( read_CodingQuadTree	  				) --> read_CodingQuadTree;
		read_CodingQuadTree			    ( read_CodingQuadTree_gotoCodingUnit	) --> read_CodingUnit;
		read_CodingQuadTree				( read_CodingQuadTree_end	 			) --> read_CodingTree;
		// read_CodingUint
		read_CodingUnit				    ( read_CodingUnit                   ) --> read_CodingUnit;
		read_CodingUnit				    ( read_CodingUnit_noGoto1           ) --> send_IntraPredMode;
		read_CodingUnit				    ( read_CodingUnit_gotoPCMSample		) --> read_PCMSample;
		read_CodingUnit				    ( read_CodingUnit_gotoPredictionUnit) --> read_PredictionUnit;
		read_CodingUnit				    ( read_CodingUnit_gotoTransformTree ) --> read_TransformTree;
		read_CodingUnit				    ( read_CodingUnit_end				) --> read_CodingQuadTree;

		send_IntraPredMode              (sendIntraPredMode                  ) --> read_CodingUnit;
		// read_PredictionUnit
		read_PredictionUnit			    ( read_PredictionUnit	  			) --> read_PredictionUnit;
		read_PredictionUnit			    ( read_PredictionUnit_gotoMVDCoding ) --> read_MVDCoding;
		read_PredictionUnit			    ( read_PredictionUnit_end			) --> read_CodingUnit;
		// read_MVDCoding
		read_MVDCoding				    ( read_MVDCoding.start	  			) --> read_MVDCoding_end;
		read_MVDCoding_end				( read_MVDCoding.ended	  			) --> read_PredictionUnit;
		// read_PCMSample
		read_PCMSample				    ( read_PCMSample	  				) --> undefined;//read_PredictionUnit;
		// read_TransformTree
		read_TransformTree			    ( read_TransformTree	  			) --> read_TransformTree;
		read_TransformTree			    ( read_TransformTree_gotoTransformUnit) --> read_TransformUnit;
		read_TransformTree			    ( read_TransformTree_end	  		) --> read_CodingUnit;
		// read_TransformUnit
		read_TransformUnit			    ( read_TransformUnit	  			) --> read_TransformUnit;
		read_TransformUnit			    ( read_TransformUnit_gotoResidualCoding) --> read_ResidualCoding;
		read_TransformUnit			    ( read_TransformUnit_end			) --> read_TransformTree;
		// read_ResidualCoding
		read_ResidualCoding				( read_ResidualCoding.start  		) --> read_ResidualCodingStart;
		read_ResidualCodingStart        ( read_ResidualCoding.for_numLastSubset.start ) --> read_ResidualCodingGreater1;
		read_ResidualCodingGreater1     ( read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_GREATER1_FLAG ) --> read_ResidualCodingGetCoeff;
		read_ResidualCodingGetCoeff     ( read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL ) --> read_ResidualCodingGetCoeff;
		read_ResidualCodingGetCoeff     ( read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_end ) --> read_ResidualCodingStart;
		read_ResidualCodingStart		( read_ResidualCoding_end			) --> read_TransformUnit;
		
		find_header                     ( look_for_other_header             ) --> byte_align;		
		
		// undefined
		undefined	  					( undefined		    				) --> undefined;
	end
	
	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
		read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL_end > read_ResidualCoding.for_numLastSubset.get_COEFF_ABS_LEVEL;
		read_ResidualCoding_end > read_ResidualCoding.for_numLastSubset.start;
	end
end
