package motion;

actor Memory ()
//(width1,height1,width2,height2,accuracy2)

//list image_p,

//list image_sw,
int address_x, int addr_half_x, int addr_half_y, bool start_inter_h, bool
start_inter_q ==> bool start_gen, int col_pat, int col_sw, bool start_h, bool
start_q :

	int width1 := 16;

	int height1 := 16;

	int width2 := 56;

	int height2 := 40;

	List(type: int(size=8), size=width1 * height1) P := [ 0 : for int i in 1 ..
	width1 * height1 ];

	List(type: int(size=8), size=16) P1 := [ 0 : for int i in 1 .. 16 ];

	List(type: int(size=8), size=width2 * height2) SW := [ 0 : for int i in 1 ..
	width2 * height2 ];

	List(type: int(size=8), size=16) addresse_4x4_x := [ 0 : for int i in 1 .. 16
	];

	List(type: int(size=8), size=16) addresse_4x4_y := [ 0 : for int i in 1 .. 16
	];

	List(type: int(size=8), size=165) half_t := [ 0 : for int i in 1 .. 165 ];
	//11*15=1287
	List(type: int(size=8), size=81) H_mem := [ 0 : for int i in 1 .. 81 ];
	//9*9=81
	List(type: int(size=8), size=361) quart_t := [ 0 : for int i in 1 .. 361 ];
	//19*19=361
	List(type: int(size=8), size=225) Q_mem := [ 0 : for int i in 1 .. 225 ];
	//19*19=361
	List(type: int(size=8), size=2) addr_int := [ 0 : for int i in 1 .. 2 ];

	List(type: int(size=8), size=16) col1 := [ 0 : for int i in 1 .. 16 ];

	List(type: int(size=8), size=40) col2 := [ 0 : for int i in 1 .. 40 ];

	List(type: int(size=8), size=9) col3 := [ 0 : for int i in 1 .. 9 ];

	List(type: int(size=8), size=15) col4 := [ 0 : for int i in 1 .. 15 ];

	List(type: int(size=8), size=4) col5 := [ 0 : for int i in 1 .. 4 ];

	bool start_gen_temp;

	bool read0;

	bool read1;

	bool envoi;

	bool ack0;

	int x;

	int pattern_H = height1;

	int pattern_L = width1;

	int SW_H = height2;

	int SW_L = width2;

	int inc;

	int cpt1;

	int cpt;

	bool inter_h;

	bool read_address;

	int u;

	int w;

	int w1;

	int width_h;

	int width_sw;

	bool read11;

	bool envoi1;

	bool ack10;

	bool ack20;

	bool read21;

	bool envoi11;

	bool start_inter_h_temp_1;

	bool start_inter_q_temp_1;

	bool inter_q;

	int adddr;

	int width_q;

	int inc1;

	int i0;

	int j0;

	int compteur;

	int compteur1;

	int compteur2;

	int compteur3;

	int compteur4;

	bool wait;

	int pix_sw;

	int pix_p;

	int accuracy2;

	function inte(int valeur) --> int :
	// calcule de valeur absolue
		if (valeur < 0) then
			0
		else
			valeur
		end
	end
	//*************************************************************//
	Init: action ==>
	do
		read0 := true;
		ack0 := false;
		read1 := false;
		envoi := false;
		//		incr:=false;
		wait := false;
		inc := 0;
		inc1 := 0;
		compteur := 0;
		compteur1 := 0;
		compteur2 := 0;
		compteur3 := 0;
		compteur4 := 0;
		cpt1 := 0;
		i0 := 0;
		j0 := 0;
	end

	Read0: action
	//image_p:[image1_temp] ,

	//image_sw:[image2_temp]
		==>
	guard
		read0 = true
	do
	//     	println("-----read0_mem0-----");

	///P:=image1_temp;

	///SW:=image2_temp;
		read0 := false;
		ack0 := true;
	end

	Ack0: action ==> start_gen:[ start_gen_temp ]
	guard
		ack0 = true
	do
	//    	println("-----ack0_mem0-----");
		start_gen_temp := true;
		ack0 := false;
		read1 := true;
	end

	Read1: action address_x:[ addr ], start_inter_h:[ start_inter_h_temp ] ==>
		start_h:[ start_inter_h_temp ]
	guard
		read1 = true
	do
	//        println("-----read1_mem0-----");
		start_inter_h_temp_1 := start_inter_h_temp;
		read1 := false;
		compteur := 0;
		x := addr;
		println("addr1:" + x);
		envoi := true;
	end

	Envoi: action ==>
	guard
		envoi = true
	var
		int m
	do
	//		println("-----envoi_mem0-----");
		m := 0;
		while (m < pattern_H) do
			col1[m] := P[m * pattern_L + inc];
			m := m + 1;
		end
		m := 0;
		while m < SW_H do
			col2[m] := SW[m * SW_L + x + inc];
			// inc: compteur de colonnes, 
			m := m + 1;
			//x= abscisse, m*SW: selection des pixels colonnes
		end
		compteur := compteur + 1;
		envoi := false;
	end

	EnvoiColP1_a: action ==> col_pat:[ pix_p ]
	guard
		cpt < 15
	do
		pix_p := col1[cpt];
		cpt := cpt + 1;
	end

	EnvoiColP2_a: action ==> col_sw:[ pix_sw ]
	guard
		cpt = 15
	do
		pix_p := col1[cpt];
		cpt := 0;
	end

	EnvoiColSW1_a: action ==> col_sw:[ pix_sw ]
	guard
		cpt < 39
	do
		pix_sw := col2[cpt];
		cpt := cpt + 1;
	end

	EnvoiColSW2_a: action ==> col_pat:[ pix_p ]
	guard
		cpt = 39
	do
		pix_sw := col2[cpt];
		cpt := 0;
	end

	Incr1: action ==>
	guard
		compteur < 16
	do
	//			println("-----incr1_mem0-----");
		envoi := true;
		inc := inc + 1;
	end

	Incr2: action ==>
	guard
		compteur = 16,
		start_inter_h_temp_1 = false
	do
	//			println("-----incr2_mem0-----");
		ack0 := true;
		inc := 0;
	end

	Incr3: action ==>
	guard
		compteur = 16,
		start_inter_h_temp_1 = true
	do
	//    	println("-----incr3_mem0-----");
		read_address := true;
		compteur := 0;
		inc := 0;
	end

	Read_address: action addr_half_x:[ addr_half_x ], addr_half_y:[ addr_half_y ]
		==>
	guard
		read_address = true
	do
	//	println("read_address_mem0 ");
		addresse_4x4_x[compteur] := addr_half_x;
		addresse_4x4_y[compteur] := addr_half_y;
		width_h := 11;
		width_sw := 56;
		inc := 0;
		compteur := compteur + 1;
		read_address := false;
	end

	Incr_read1: action ==>
	guard
		compteur < 16
	do
		read_address := true;
	end

	Incr_read2: action ==>
	guard
		compteur = 16
	var
		int i , int j , int j1
	do
	//	   println("incr_read2_mem0 ");

	//   println("addresse_4x4_x:"+addresse_4x4_x);

	//   println("addresse_4x4_y:"+addresse_4x4_y);
		i := 0;
		j := 0;
		while i < 16 do
			addresse_4x4_x[i] := addresse_4x4_x[i] + 4 * j;
			i := i + 1;
			j := j + 1;
			if j = 4 then
				j := 0;
			end
		end
		i := 0;
		j := 0;
		j1 := 0;
		while i < 16 do
			addresse_4x4_y[i] := addresse_4x4_y[i] + 4 * j1;
			i := i + 1;
			j := j + 1;
			if j = 4 then
				j := 0;
				j1 := j1 + 1;
			end
		end
		wait := true;
		//  println("addresse_4x4_x:"+addresse_4x4_x);

		//  println("addresse_4x4_y:"+addresse_4x4_y);

	end

	Wait: action ==>
	guard
		wait = true
	var
		int m1 , int m2
	do
		println("wait_mem0 ");
		//	println("#######################################################compteur3#####:"+compteur3);

		//	println("#######################################################cpt#####:"+cpt);

		//w:=addresse_4x4_x[compteur3]+ 56*addresse_4x4_y[compteur3];
		width_q := 19;
		w1 := 3 * width_h + 1;
		m1 := 0;
		m2 := 0;
		while m1 < 16 do
			P1[m1] := P[cpt1 + m2];
			m1 := m1 + 1;
			m2 := m2 + 1;
			if m2 = 4 then
				m2 := 0;
				cpt1 := cpt1 + 16;
			end
		end
		wait := false;
		inter_h := true;
		//		println("P1:"+P1);

		//println("addresse_4x4_x:"+addresse_4x4_x);

		//println("addresse_4x4_y:"+addresse_4x4_y);

	end

	Inter_h: action ==>
	guard
		inter_h = true
	var
		int i , int j , int k , int k1 , int r1 , int r2
	do
	//	println("inter_h_mem0 ");
		w := addresse_4x4_x[compteur3] + 56 * addresse_4x4_y[compteur3];
		//********************************************//

		//**********Interpolation demi pixel**********//

		//********************************************//

		//les trois lignes supp en haut
		i := 0;
		j := 0;
		k := 0;
		u := w;
		while j < 3 do
			half_t[i + j * width_h] := SW[u - 3 * width_sw + k - 1];
			i := i + 2;
			k := k + 1;
			if k = 6 then
			// println("-----inter0-----");
				i := 0;
				k := 0;
				j := j + 1;
				u := u + width_sw;
			end
		end
		i := 0;
		j := 0;
		k := 0;
		u := w;
		while j < 3 do
			half_t[i + 1 + j * width_h] := inte((SW[u - 3 * width_sw + k - 3] + SW[u - 3
			* width_sw + k + 3] - 5 * (SW[u - 3 * width_sw + k - 2] + SW[u - 3 *
			width_sw + k + 2]) + 20 * (SW[u - 3 * width_sw + k - 1] + SW[u - 3 *
			width_sw + k + 1]))) / 32;
			i := i + 2;
			k := k + 1;
			if k = 5 then
			// println("-----inter0-----");
				i := 0;
				k := 0;
				j := j + 1;
				u := u + width_sw;
			end
		end
		///////////////////////////

		//les trois lignes supp en bas
		i := 0;
		j := 0;
		k := 0;
		u := w;
		while j < 3 do
			half_t[i + (j + 12) * width_h] := SW[u + 4 * width_sw + k - 1];
			i := i + 2;
			k := k + 1;
			if k = 6 then
			// println("-----inter0-----");
				i := 0;
				k := 0;
				j := j + 1;
				u := u + width_sw;
			end
		end
		i := 0;
		j := 0;
		k := 0;
		u := w;
		while j < 3 do
			half_t[i + 1 + (j + 12) * width_h] := inte((SW[u + 4 * width_sw + k - 3] +
			SW[u + 4 * width_sw + k + 3] - 5 * (SW[u + 4 * width_sw + k - 2] + SW[u + 4
			* width_sw + k + 2]) + 20 * (SW[u + 4 * width_sw + k - 1] + SW[u + 4 *
			width_sw + k + 1]))) / 32;
			i := i + 2;
			k := k + 1;
			if k = 5 then
			// println("-----inter0-----");
				i := 0;
				k := 0;
				j := j + 1;
				u := u + width_sw;
			end
		end
		///////////////////////////

		//remplissage des pixel entiers	 
		i := 0;
		j := 0;
		k := 0;
		u := w;
		while j < 9 do
			half_t[i + (j + 4) * width_h] := SW[u + k - 1];
			i := i + 2;
			k := k + 1;
			if k = 6 then
			//  println("-----inter0-----");
				i := 0;
				k := 0;
				j := j + 2;
				u := u + width_sw;
			end
		end
		///////////////////////////

		// calcul des demis pixels
		i := 0;
		j := 0;
		k := 0;
		u := w;
		while j < 9 do
			half_t[i + 1 + (j + 4) * width_h] := inte((SW[u + k - 3] + SW[u + k + 3] - 5
			* (SW[u + k - 2] + SW[u + k + 2]) + 20 * (SW[u + k - 1] + SW[u + k + 1]))) /
			32;
			i := i + 2;
			k := k + 1;
			if k = 5 then
				i := 0;
				k := 0;
				j := j + 2;
				u := u + width_sw;
			end
		end
		///////////////////////////
		i := 0;
		//j:=0;k:=0;u:=v;
		while i < 11 do
			half_t[i + 3 * width_h] := inte((half_t[i] + half_t[i + 8 * width_h] - 5 *
			(half_t[i + 1 * width_h] + half_t[i + 6 * width_h]) + 20 * (half_t[i + 2 *
			width_h] + half_t[i + 4 * width_h]) + 16)) / 32;
			i := i + 1;
		end
		///////////////////////////
		i := 0;
		//j:=0;k:=0;u:=v;
		while i < 11 do
			half_t[i + 5 * width_h] := inte((half_t[i + width_h] + half_t[i + 10 *
			width_h] - 5 * (half_t[i + 2 * width_h] + half_t[i + 8 * width_h]) + 20 *
			(half_t[i + 4 * width_h] + half_t[i + 6 * width_h]) + 16)) / 32;
			i := i + 1;
		end
		///////////////////////////

		///////////////////////////
		i := 0;
		//j:=0;k:=0;u:=v;
		while i < 11 do
			half_t[i + 7 * width_h] := inte((half_t[i + 2 * width_h] + half_t[i + 12 *
			width_h] - 5 * (half_t[i + 4 * width_h] + half_t[i + 10 * width_h]) + 20 *
			(half_t[i + 6 * width_h] + half_t[i + 8 * width_h]) + 16)) / 32;
			i := i + 1;
		end
		////////////////////////////
		i := 0;
		//j:=0;k:=0;u:=v;
		while i < 11 do
			half_t[i + 9 * width_h] := inte((half_t[i + 4 * width_h] + half_t[i + 13 *
			width_h] - 5 * (half_t[i + 6 * width_h] + half_t[i + 12 * width_h]) + 20 *
			(half_t[i + 8 * width_h] + half_t[i + 12 * width_h]) + 16)) / 32;
			i := i + 1;
		end
		///////////////////////////
		i := 0;
		//j:=0;k:=0;u:=v;
		while i < 11 do
			half_t[i + 11 * width_h] := inte((half_t[i + 6 * width_h] + half_t[i + 14 *
			width_h] - 5 * (half_t[i + 8 * width_h] + half_t[i + 13 * width_h]) + 20 *
			(half_t[i + 10 * width_h] + half_t[i + 12 * width_h]) + 16)) / 32;
			i := i + 1;
		end
		///////////////////////////
		i := 0;
		j := 0;
		while j < 9 do
			H_mem[i + j * 9] := half_t[i + 1 + (3 + j) * width_h];
			i := i + 1;
			if i = 9 then
			//	println("-----inter0-----");
				i := 0;
				j := j + 1;
			end
		end
		//

		//si le mode choisie est quart de pixel alor on interpole

		//
		if accuracy2 = 1 then
		//	println("inter_q_mem0");

		//********************************************//

		// *******Interpolation quart de pixel********//

		//********************************************//

		// remplissage des demis-pixels et calculs des quart de pixels
			i := 0;
			j := 0;
			k := 0;
			r1 := 0;
			r2 := 0;
			while j < 9 do
				quart_t[i + 1 + (r1 + 1) * width_q] := half_t[w1 + k + r2 * width_h];
				i := i + 2;
				k := k + 1;
				if k = 9 then
					r1 := r1 + 2;
					r2 := r2 + 1;
					k := 0;
					i := 0;
					j := j + 1;
				end
			end
			i := 0;
			j := 0;
			k := 0;
			r1 := 0;
			r2 := 0;
			while j < 9 do
				quart_t[i + (r1 + 1) * width_q] := (half_t[w1 + k - 1 + r2 *
				width_h] + half_t[w1 + k + r2 * width_h] + 1) >> 1;
				i := i + 2;
				k := k + 1;
				if k = 10 then
					r1 := r1 + 2;
					r2 := r2 + 1;
					k := 0;
					i := 0;
					j := j + 1;
				end
			end
			//////*///

			//////¤

			//////*
			i := 0;
			j := 0;
			k := 0;
			k1 := 0;
			r1 := 0;
			r2 := 0;
			while j < 10 do
				quart_t[i + 1 + r1 * width_q] := (half_t[w1 + k + r2 * width_h] +
				half_t[w1 + k + (r2 - 1) * width_h] + 1) >> 1;
				i := i + 2;
				k := k + 1;
				//k1:=k1+1;
				if k = 9 then
					r1 := r1 + 2;
					r2 := r2 + 1;
					k := 0;
					//k1:=0;
					i := 0;
					j := j + 1;
				end
			end
			//////*///

			////¤

			//*
			i := 0;
			j := 0;
			k := 0;
			k1 := 0;
			r1 := 0;
			r2 := 0;
			while j < 5 do
				quart_t[i + r1 * width_q] := (half_t[w1 + k - 1 + r2 * width_h] +
				half_t[w1 + k + (r2 - 1) * width_h] + 1) >> 1;
				i := i + 4;
				k := k + 2;
				k1 := k1 + 1;
				if k1 = 5 then
					r1 := r1 + 4;
					r2 := r2 + 2;
					k := 0;
					k1 := 0;
					i := 0;
					j := j + 1;
				end
			end
			//*///////

			////¤

			//////*
			i := 0;
			j := 0;
			k := 0;
			k1 := 0;
			r1 := 0;
			r2 := 0;
			while j < 5 do
				quart_t[i + 2 + r1 * width_q] := (half_t[w1 + k + 1 + r2 * width_h]
				+ half_t[w1 + k + (r2 - 1) * width_h] + 1) >> 1;
				i := i + 4;
				k := k + 2;
				k1 := k1 + 1;
				if k1 = 5 then
					r1 := r1 + 4;
					r2 := r2 + 2;
					k := 0;
					k1 := 0;
					i := 0;
					j := j + 1;
				end
			end
			//*

			////¤

			//////*///
			i := 0;
			j := 0;
			k := 0;
			k1 := 0;
			r1 := 0;
			r2 := 0;
			while j < 5 do
				quart_t[i + (r1 + 2) * width_q] := (half_t[w1 + k - 1 + r2 *
				width_h] + half_t[w1 + k + (r2 + 1) * width_h] + 1) >> 1;
				i := i + 4;
				k := k + 2;
				k1 := k1 + 1;
				if k1 = 5 then
					r1 := r1 + 4;
					r2 := r2 + 2;
					k := 0;
					k1 := 0;
					i := 0;
					j := j + 1;
				end
			end
			//////*

			////¤

			//*////////
			i := 0;
			j := 0;
			k := 0;
			k1 := 0;
			r1 := 0;
			r2 := 0;
			while j < 5 do
				quart_t[i + 2 + (r1 + 2) * width_q] := (half_t[w1 + k + 1 + r2 *
				width_h] + half_t[w1 + k + (r2 + 1) * width_h] + 1) >> 1;
				i := i + 4;
				k := k + 2;
				k1 := k1 + 1;
				if k1 = 5 then
					r1 := r1 + 4;
					r2 := r2 + 2;
					k := 0;
					k1 := 0;
					i := 0;
					j := j + 1;
				end
			end
			//println("quart_t:"+quart_t);
		end
		//println("-----FIN_inter0-----");*/

		//	println("half_t:"+half_t);

		//		println("H_mem:"+H_mem);

		//	println("quart_t:"+quart_t);

		//println("quart_t:"+quart_t);
		inter_h := false;
		ack10 := true;
	end

	Ack10: action ==> start_gen:[ start_gen_temp ]
	guard
		ack10 = true
	do
	//	println("ack10_mem0 ");
		start_gen_temp := true;
		ack10 := false;
		read11 := true;
	end

	Read11: action address_x:[ addr ], start_inter_q:[ start_inter_q_temp ] ==>
		start_q:[ start_inter_q_temp ]
	guard
		read11 = true
	do
	// 	println("read11_mem0 ");
		start_inter_q_temp_1 := start_inter_q_temp;
		read11 := false;
		compteur1 := 0;
		x := addr;
		//println("addr1:"+x);
		envoi1 := true;
	end

	Envoi1: action ==>
	guard
		envoi1 = true
	var
		int m
	do
	//	println("envoi1_mem0 ");
		m := 0;
		while m < 4 do
			col5[m] := P1[m * 4 + inc];
			m := m + 1;
		end
		m := 0;
		while m < 9 do
			col3[m] := H_mem[m * 9 + x + inc1];
			m := m + 1;
		end
		//println("colp:"+col1);

		//println("colsw:"+col3);
		compteur1 := compteur1 + 1;
		envoi1 := false;
	end

	EnvoiColP1_b: action ==> col_pat:[ pix_p ]
	guard
		cpt < 3
	do
		pix_p := col5[cpt];
		cpt := cpt + 1;
	end

	EnvoiColP2_b: action ==> col_sw:[ pix_sw ]
	guard
		cpt = 3
	do
		pix_p := col5[cpt];
		cpt := 0;
	end

	EnvoiColSW1_b: action ==> col_sw:[ pix_sw ]
	guard
		cpt < 8
	do
		pix_sw := col3[cpt];
		cpt := cpt + 1;
	end

	EnvoiColSW2_b: action ==> col_pat:[ pix_p ]
	guard
		cpt = 8
	do
		pix_sw := col3[cpt];
		cpt := 0;
	end

	Incr11: action ==>
	guard
		compteur1 < 4
	do
	//	println("incr11_mem0 ");
		envoi1 := true;
		inc := inc + 1;
		inc1 := inc1 + 2;
	end

	Incr12: action ==>
	guard
		compteur1 = 4,
		start_inter_q_temp_1 = false
	do
	//	println("incr12_mem0 ");
		ack10 := true;
		inc := 0;
		inc1 := 0;
	end

	Incr13: action ==>
	guard
		compteur1 = 4,
		start_inter_q_temp_1 = true
	do
	//	println("incr13_mem0 ");
		read_address := true;
		inc := 0;
		inc1 := 0;
	end

	Read_address1: action addr_half_x:[ addr_half_x_temp ], addr_half_y:[
		addr_half_y_temp ] ==>
	guard
		read_address = true
	do
	// 	println("read_address1_mem0 ");

	//	println("**************************************addr************************************:"+address);
		addr_int[0] := addr_half_x_temp;
		addr_int[1] := addr_half_y_temp;
		inter_q := true;
		width_h := 11;
		width_q := 19;
		inc := 0;
		//	println("addr_int:"+addr_int);
		adddr := addr_int[0] + 9 * (addr_int[1] + 3);
		//w1:=adddr;
		w1 := 2 * (addr_int[0] + width_q * addr_int[1]);
		read_address := false;
		inter_q := true;
	end

	Inter_q: action ==>
	guard
		inter_q = true
	var
		int i , int j
	do
	//    println("-----interq_mem0-----");
		i := 0;
		j := 0;
		while j < 15 do
			Q_mem[i + j * 15] := quart_t[w1 + i + j * width_q];
			i := i + 1;
			if i = 15 then
				i := 0;
				j := j + 1;
			end
		end
		//	println("Q_mem:"+Q_mem);
		inter_q := false;
		ack20 := true;
	end

	Ack20: action ==> start_gen:[ start_gen_temp ]
	guard
		ack20 = true
	do
	//  	println("ack20_mem0 ");
		start_gen_temp := true;
		ack20 := false;
		read21 := true;
	end

	Read21: action address_x:[ addr ] ==>
	guard
		read21 = true
	do
	//   	println("read21_mem0 ");
		inc := 0;
		inc1 := 0;
		read21 := false;
		compteur1 := 0;
		x := addr;
		//println("addr1:"+x);
		envoi11 := true;
	end

	Envoi11: action ==>
	guard
		envoi11 = true
	var
		int m
	do
	//	println("envoi11_mem0 ");
		m := 0;
		while m < 4 do
			col5[m] := P1[m * 4 + inc];
			m := m + 1;
		end
		//println("col2:"+col2);
		m := 0;
		while m < 15 do
			col4[m] := Q_mem[m * 15 + x + inc1];
			///H_mem
			m := m + 1;
		end
		compteur1 := compteur1 + 1;
		envoi11 := false;
	end

	EnvoiColP1_c: action ==> col_pat:[ pix_p ]
	guard
		cpt < 3
	do
		pix_p := col5[cpt];
		cpt := cpt + 1;
	end

	EnvoiColP2_c: action ==> col_sw:[ pix_sw ]
	guard
		cpt = 3
	do
		pix_p := col5[cpt];
		cpt := 0;
	end

	EnvoiColSW1_c: action ==> col_sw:[ pix_sw ]
	guard
		cpt < 14
	do
		pix_sw := col4[cpt];
		cpt := cpt + 1;
	end

	EnvoiColSW2_c: action ==> col_pat:[ pix_p ]
	guard
		cpt = 14
	do
		pix_sw := col4[cpt];
		cpt := 0;
	end

	Incr21: action ==>
	guard
		compteur1 < 4
	do
	//	println("incr21_mem0 ");
		envoi11 := true;
		inc := inc + 1;
		inc1 := inc1 + 4;
	end

	Incr22_a: action ==>
	guard
		compteur1 = 4,
		compteur4 < 8
	do
	//	println("incr22_a_mem0 ");
		ack20 := true;
		inc := 0;
		compteur4 := compteur4 + 1;
		inc1 := 0;
	end

	Incr22_b: action addr_half_x:[ addr_half_x ], addr_half_y:[ addr_half_y ] ==>
	guard
		compteur1 = 4,
		compteur4 = 8
	do
	//	println("incr22_b_1_mem0 ");
		inc := 0;
		inc1 := 0;
		compteur1 := 0;
		compteur2 := 0;
		compteur4 := 0;
		compteur3 := compteur3 + 1;
		j0 := j0 + 1;
		if j0 = 4 then
			i0 := i0 + 64;
			j0 := 0;
		end
		cpt1 := i0 + 4 * j0;
		wait := true;
		if compteur3 = 16 then
			wait := false;
		end
	end

	schedule fsm state1 :
	state1 ( Init ) --> state2;
	state2 ( Read0 ) --> state3;
	state3 ( Ack0 ) --> state4;
	state4 ( Read1 ) --> state5;
	state5 ( Envoi ) --> state6;
	state6 ( EnvoiColP1_a ) --> state6;
	state6 ( EnvoiColP2_a ) --> state7;
	state7 ( EnvoiColSW1_a ) --> state7;
	state7 ( EnvoiColSW2_a ) --> state8;
	state8 ( Incr1 ) --> state5;
	state8 ( Incr2 ) --> state3;
	state8 ( Incr3 ) --> state9;
	state9 ( Read_address ) --> state10;
	state10 ( Incr_read1 ) --> state9;
	state10 ( Incr_read2 ) --> state11;
	state11 ( Wait ) --> state12;
	state12 ( Inter_h ) --> state13;
	state13 ( Ack10 ) --> state14;
	state14 ( Read11 ) --> state15;
	state15 ( Envoi1 ) --> state16;
	state16 ( EnvoiColP1_b ) --> state16;
	state16 ( EnvoiColP2_b ) --> state17;
	state17 ( EnvoiColSW1_b ) --> state17;
	state17 ( EnvoiColSW2_b ) --> state18;
	state18 ( Incr11 ) --> state15;
	state18 ( Incr12 ) --> state13;
	state18 ( Incr13 ) --> state19;
	state19 ( Read_address1 ) --> state20;
	state20 ( Inter_q ) --> state21;
	state21 ( Ack20 ) --> state22;
	state22 ( Read21 ) --> state23;
	state23 ( Envoi11 ) --> state24;
	state24 ( EnvoiColP1_c ) --> state24;
	state24 ( EnvoiColP2_c ) --> state25;
	state25 ( EnvoiColSW1_c ) --> state25;
	state25 ( EnvoiColSW2_c ) --> state26;
	state26 ( Incr21 ) --> state23;
	state26 ( Incr22_a ) --> state21;
	state26 ( Incr22_b ) --> state11;
	end

end      	